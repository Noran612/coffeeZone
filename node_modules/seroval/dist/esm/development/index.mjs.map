{
  "version": 3,
  "sources": ["../../../src/core/compat.ts", "../../../src/core/constants.ts", "../../../src/core/assert.ts", "../../../src/core/get-identifier.ts", "../../../src/core/tree/context.ts", "../../../src/core/string.ts", "../../../src/core/UnsupportedTypeError.ts", "../../../src/core/literals.ts", "../../../src/core/keys.ts", "../../../src/core/reference.ts", "../../../src/core/base-primitives.ts", "../../../src/core/tree/primitives.ts", "../../../src/core/shared.ts", "../../../src/core/tree/web-api.ts", "../../../src/core/web-api.ts", "../../../src/core/promise-to-result.ts", "../../../src/core/tree/async.ts", "../../../src/core/tree/deserialize.ts", "../../../src/core/assignments.ts", "../../../src/core/tree/serialize.ts", "../../../src/core/tree/sync.ts", "../../../src/core/tree/index.ts", "../../../src/core/cross/context.ts", "../../../src/core/cross/primitives.ts", "../../../src/core/cross/web-api.ts", "../../../src/core/cross/async.ts", "../../../src/core/cross/serialize.ts", "../../../src/core/cross/stream.ts", "../../../src/core/cross/sync.ts", "../../../src/core/cross/index.ts", "../../../src/core/Serializer.ts", "../../../src/index.ts"],
  "sourcesContent": ["/**\n * References\n * - https://kangax.github.io/compat-table/es6/\n * - MDN\n */\n\nexport const enum Feature {\n  AggregateError = 0x01,\n  ArrayPrototypeValues = 0x02,\n  ArrowFunction = 0x04,\n  BigInt = 0x08,\n  ErrorPrototypeStack = 0x10,\n  Map = 0x20,\n  MethodShorthand = 0x40,\n  ObjectAssign = 0x80,\n  Promise = 0x100,\n  Set = 0x200,\n  Symbol = 0x400,\n  TypedArray = 0x800,\n  BigIntTypedArray = 0x1000,\n  WebAPI = 0x2000,\n}\n\nexport const ALL_ENABLED = 0x3FFF;\n", "import type { SerovalConstantNode } from './types';\n\nexport const enum SerovalConstant {\n  Null = 0,\n  Undefined = 1,\n  True = 2,\n  False = 3,\n  NegativeZero = 4,\n  Infinity = 5,\n  NegativeInfinity = 6,\n  NaN = 7,\n}\n\nexport const enum SerovalNodeType {\n  Number = 0,\n  String = 1,\n  Constant = 2,\n  BigInt = 3,\n  IndexedValue = 4,\n  Date = 5,\n  RegExp = 6,\n  Set = 7,\n  Map = 8,\n  Array = 9,\n  Object = 10,\n  NullConstructor = 11,\n  Promise = 12,\n  Error = 13,\n  AggregateError = 14,\n  TypedArray = 15,\n  BigIntTypedArray = 16,\n  WKSymbol = 17,\n  URL = 18,\n  URLSearchParams = 19,\n  Reference = 20,\n  ArrayBuffer = 21,\n  DataView = 22,\n  Blob = 23,\n  File = 24,\n  Headers = 25,\n  FormData = 26,\n  Boxed = 27,\n  PromiseConstructor = 28,\n  PromiseResolve = 29,\n  PromiseReject = 30,\n  ReadableStreamConstructor = 31,\n  ReadableStreamEnqueue = 32,\n  ReadableStreamClose = 33,\n  ReadableStreamError = 34,\n}\n\nexport const enum SerovalObjectFlags {\n  None = 0,\n  NonExtensible = 1,\n  Sealed = 2,\n  Frozen = 3,\n}\n\nexport const enum Symbols {\n  AsyncIterator = 0,\n  HasInstance = 1,\n  IsConcatSpreadable = 2,\n  Iterator = 3,\n  Match = 4,\n  MatchAll = 5,\n  Replace = 6,\n  Search = 7,\n  Species = 8,\n  Split = 9,\n  ToPrimitive = 10,\n  ToStringTag = 11,\n  Unscopables = 12,\n}\n\nexport const SYMBOL_STRING: Record<Symbols, string> = {\n  [Symbols.AsyncIterator]: 'Symbol.asyncIterator',\n  [Symbols.HasInstance]: 'Symbol.hasInstance',\n  [Symbols.IsConcatSpreadable]: 'Symbol.isConcatSpreadable',\n  [Symbols.Iterator]: 'Symbol.iterator',\n  [Symbols.Match]: 'Symbol.match',\n  [Symbols.MatchAll]: 'Symbol.matchAll',\n  [Symbols.Replace]: 'Symbol.replace',\n  [Symbols.Search]: 'Symbol.search',\n  [Symbols.Species]: 'Symbol.species',\n  [Symbols.Split]: 'Symbol.split',\n  [Symbols.ToPrimitive]: 'Symbol.toPrimitive',\n  [Symbols.ToStringTag]: 'Symbol.toStringTag',\n  [Symbols.Unscopables]: 'Symbol.unscopables',\n};\n\nexport const INV_SYMBOL_REF = {\n  [Symbol.asyncIterator]: Symbols.AsyncIterator,\n  [Symbol.hasInstance]: Symbols.HasInstance,\n  [Symbol.isConcatSpreadable]: Symbols.IsConcatSpreadable,\n  [Symbol.iterator]: Symbols.Iterator,\n  [Symbol.match]: Symbols.Match,\n  [Symbol.matchAll]: Symbols.MatchAll,\n  [Symbol.replace]: Symbols.Replace,\n  [Symbol.search]: Symbols.Search,\n  [Symbol.species]: Symbols.Species,\n  [Symbol.split]: Symbols.Split,\n  [Symbol.toPrimitive]: Symbols.ToPrimitive,\n  [Symbol.toStringTag]: Symbols.ToStringTag,\n  [Symbol.unscopables]: Symbols.Unscopables,\n};\n\nexport type WellKnownSymbols = keyof typeof INV_SYMBOL_REF;\n\nexport const SYMBOL_REF: Record<Symbols, WellKnownSymbols> = {\n  [Symbols.AsyncIterator]: Symbol.asyncIterator,\n  [Symbols.HasInstance]: Symbol.hasInstance,\n  [Symbols.IsConcatSpreadable]: Symbol.isConcatSpreadable,\n  [Symbols.Iterator]: Symbol.iterator,\n  [Symbols.Match]: Symbol.match,\n  [Symbols.MatchAll]: Symbol.matchAll,\n  [Symbols.Replace]: Symbol.replace,\n  [Symbols.Search]: Symbol.search,\n  [Symbols.Species]: Symbol.species,\n  [Symbols.Split]: Symbol.split,\n  [Symbols.ToPrimitive]: Symbol.toPrimitive,\n  [Symbols.ToStringTag]: Symbol.toStringTag,\n  [Symbols.Unscopables]: Symbol.unscopables,\n};\n\nexport function serializeConstant(node: SerovalConstantNode): string {\n  switch (node.s) {\n    case SerovalConstant.True:\n      return '!0';\n    case SerovalConstant.False:\n      return '!1';\n    case SerovalConstant.Undefined:\n      return 'void 0';\n    case SerovalConstant.Null:\n      return 'null';\n    case SerovalConstant.NegativeZero:\n      return '-0';\n    case SerovalConstant.Infinity:\n      return '1/0';\n    case SerovalConstant.NegativeInfinity:\n      return '-1/0';\n    case SerovalConstant.NaN:\n      return 'NaN';\n    default:\n      throw new Error('invariant');\n  }\n}\n\nexport function deserializeConstant(node: SerovalConstantNode): unknown {\n  switch (node.s) {\n    case SerovalConstant.True:\n      return true;\n    case SerovalConstant.False:\n      return false;\n    case SerovalConstant.Undefined:\n      return undefined;\n    case SerovalConstant.Null:\n      return null;\n    case SerovalConstant.NegativeZero:\n      return -0;\n    case SerovalConstant.Infinity:\n      return Infinity;\n    case SerovalConstant.NegativeInfinity:\n      return -Infinity;\n    case SerovalConstant.NaN:\n      return NaN;\n    default:\n      throw new Error('invariant');\n  }\n}\n", "export default function assert(cond: unknown, error: Error): asserts cond {\n  if (!cond) {\n    throw error;\n  }\n}\n", "// Written by https://github.com/DylanPiercey and is distributed under the MIT license.\nconst REF_START_CHARS = 'hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_'; // Avoids chars that could evaluate to a reserved word.\nconst REF_START_CHARS_LEN = REF_START_CHARS.length;\nconst REF_CHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_';\nconst REF_CHARS_LEN = REF_CHARS.length;\n\nexport default function getIdentifier(index: number): string {\n  let mod = index % REF_START_CHARS_LEN;\n  let ref = REF_START_CHARS[mod];\n  index = (index - mod) / REF_START_CHARS_LEN;\n  while (index > 0) {\n    mod = index % REF_CHARS_LEN;\n    ref += REF_CHARS[mod];\n    index = (index - mod) / REF_CHARS_LEN;\n  }\n  return ref;\n}\n", "import { ALL_ENABLED } from '../compat';\nimport type { BaseParserContext, BaseSerializerContext } from '../context';\nimport getIdentifier from '../get-identifier';\n\nexport interface ParserReference {\n  ids: Map<unknown, number>;\n  marked: Set<number>;\n}\n\nexport interface ParserContext extends BaseParserContext {\n  reference: ParserReference;\n}\n\nexport interface ParserOptions {\n  disabledFeatures: number;\n}\n\nexport function createParserContext(options: Partial<ParserOptions> = {}): ParserContext {\n  return {\n    reference: {\n      ids: new Map(),\n      marked: new Set(),\n    },\n    features: ALL_ENABLED ^ (options.disabledFeatures || 0),\n  };\n}\n\nexport interface SerializerReference {\n  size: number;\n  // Map tree refs to actual refs\n  valid: (number | undefined)[];\n  // Refs that are...referenced\n  marked: Set<number>;\n}\n\nexport interface SerializerContext extends BaseSerializerContext {\n  reference: SerializerReference;\n  // Variables\n  vars: (string | undefined)[];\n}\n\nexport interface SerializerOptions {\n  markedRefs: number[] | Set<number>;\n  features: number;\n}\n\nexport function createSerializerContext(options: SerializerOptions): SerializerContext {\n  return {\n    stack: [],\n    vars: [],\n    assignments: [],\n    reference: {\n      valid: [],\n      size: 0,\n      marked: new Set(options.markedRefs),\n    },\n    features: options.features,\n    flags: [],\n  };\n}\n\n/**\n * Increments the number of references the referenced value has\n */\nexport function markRef(\n  ctx: ParserContext | SerializerContext,\n  current: number,\n): void {\n  ctx.reference.marked.add(current);\n}\n/**\n * Creates the reference param (identifier) from the given reference ID\n * Calling this function means the value has been referenced somewhere\n */\nexport function getRefParam(ctx: SerializerContext, index: number): string {\n  /**\n   * Creates a new reference ID from a given reference ID\n   * This new reference ID means that the reference itself\n   * has been referenced at least once, and is used to generate\n   * the variables\n   */\n  let actualIndex = ctx.reference.valid[index];\n  if (actualIndex == null) {\n    actualIndex = ctx.reference.size++;\n    ctx.reference.valid[index] = actualIndex;\n  }\n  let identifier = ctx.vars[actualIndex];\n  if (identifier == null) {\n    identifier = getIdentifier(actualIndex);\n    ctx.vars[actualIndex] = identifier;\n  }\n  return identifier;\n}\n\nexport function createIndexedValue<T>(\n  ctx: ParserContext,\n  current: T,\n): number {\n  const ref = ctx.reference.ids.get(current);\n  if (ref == null) {\n    const id = ctx.reference.ids.size;\n    ctx.reference.ids.set(current, id);\n    return id;\n  }\n  markRef(ctx, ref);\n  return ref;\n}\n\nexport interface DeserializerContext {\n  values: Map<number, unknown>;\n  refs: Set<number>;\n}\n\nexport interface DeserializerOptions {\n  markedRefs: number[] | Set<number>;\n}\n\nexport function createDeserializerContext(\n  options: DeserializerOptions,\n): DeserializerContext {\n  return {\n    values: new Map(),\n    refs: new Set(options.markedRefs),\n  };\n}\n", "export function serializeChar(str: string): string | undefined {\n  switch (str) {\n    case '\"': return '\\\\\"';\n    case '\\\\': return '\\\\\\\\';\n    case '\\n': return '\\\\n';\n    case '\\r': return '\\\\r';\n    case '\\b': return '\\\\b';\n    case '\\t': return '\\\\t';\n    case '\\f': return '\\\\f';\n    case '<': return '\\\\x3C';\n    case '\\u2028': return '\\\\u2028';\n    case '\\u2029': return '\\\\u2029';\n    default: return undefined;\n  }\n}\n\n// Written by https://github.com/DylanPiercey and is distributed under the MIT license.\n// Creates a JavaScript double quoted string and escapes all characters\n// not listed as DoubleStringCharacters on\n// Also includes \"<\" to escape \"</script>\" and \"\\\" to avoid invalid escapes in the output.\n// http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.4\nexport function serializeString(str: string): string {\n  let result = '';\n  let lastPos = 0;\n  let replacement: string | undefined;\n  for (let i = 0, len = str.length; i < len; i++) {\n    replacement = serializeChar(str[i]);\n    if (replacement) {\n      result += str.slice(lastPos, i) + replacement;\n      lastPos = i + 1;\n    }\n  }\n  if (lastPos === 0) {\n    result = str;\n  } else {\n    result += str.slice(lastPos);\n  }\n  return result;\n}\n\nexport function deserializeString(str: string): string {\n  return str\n    .replace(/\\\\\"/g, '\"')\n    .replace(/\\\\\\\\/g, '\\\\')\n    .replace(/\\\\n/g, '\\n')\n    .replace(/\\\\r/g, '\\r')\n    .replace(/\\\\b/g, '\\b')\n    .replace(/\\\\t/g, '\\t')\n    .replace(/\\\\f/g, '\\f')\n    .replace(/\\\\x3C/g, '<')\n    .replace(/\\\\u2028/g, '\\u2028')\n    .replace(/\\\\u2029/g, '\\u2029');\n}\n", "// eslint-disable-next-line @typescript-eslint/unbound-method\nconst { toString } = Object.prototype;\n\nexport default class UnsupportedTypeError extends Error {\n  constructor(public value: unknown) {\n    super('Unsupported type \"' + toString.call(value) + '\"');\n  }\n}\n", "import { SerovalConstant, SerovalNodeType } from './constants';\nimport type { SerovalConstantNode } from './types';\n\nfunction createConstantNode(value: SerovalConstant): SerovalConstantNode {\n  return {\n    t: SerovalNodeType.Constant,\n    i: undefined,\n    s: value,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nexport const TRUE_NODE = createConstantNode(SerovalConstant.True);\nexport const FALSE_NODE = createConstantNode(SerovalConstant.False);\nexport const UNDEFINED_NODE = createConstantNode(SerovalConstant.Undefined);\nexport const NULL_NODE = createConstantNode(SerovalConstant.Null);\nexport const NEG_ZERO_NODE = createConstantNode(SerovalConstant.NegativeZero);\nexport const INFINITY_NODE = createConstantNode(SerovalConstant.Infinity);\nexport const NEG_INFINITY_NODE = createConstantNode(SerovalConstant.NegativeInfinity);\nexport const NAN_NODE = createConstantNode(SerovalConstant.NaN);\n", "import { serializeString } from './string';\n\n// Used for mapping isomorphic references\nexport const REFERENCES_KEY = '__SEROVAL_REFS__';\n\nexport const GLOBAL_CONTEXT_API = '_$';\n\nexport const GLOBAL_CONTEXT_REFERENCES = '$R';\n\nexport const LOCAL_CONTEXT_PROMISE_RESOLVE = 's';\n\nexport const LOCAL_CONTEXT_PROMISE_REJECT = 'f';\n\nexport const GLOBAL_CONTEXT_PROMISE_CONSTRUCTOR = 'P';\n\nexport const GLOBAL_CONTEXT_PROMISE_RESOLVE = 'Ps';\n\nexport const GLOBAL_CONTEXT_PROMISE_REJECT = 'Pf';\n\nexport const LOCAL_CONTEXT_STREAM_CONTROLLER = 'c';\n\nexport const GLOBAL_CONTEXT_STREAM_CONSTRUCTOR = 'S';\n\nexport const GLOBAL_CONTEXT_STREAM_EMIT = 'Se';\n\nexport const GLOBAL_CONTEXT_API_SCRIPT = `self.${GLOBAL_CONTEXT_API}=self.${GLOBAL_CONTEXT_API}||{`\n  + `${GLOBAL_CONTEXT_PROMISE_CONSTRUCTOR}:function(s,f,p){return(p=new Promise(function(a,b){s=a,f=b})).${LOCAL_CONTEXT_PROMISE_RESOLVE}=s,p.${LOCAL_CONTEXT_PROMISE_REJECT}=f,p},`\n  + `uP:function(p){delete p.${LOCAL_CONTEXT_PROMISE_RESOLVE};delete p.${LOCAL_CONTEXT_PROMISE_REJECT}},`\n  + `${GLOBAL_CONTEXT_PROMISE_RESOLVE}:function(p,d){p.${LOCAL_CONTEXT_PROMISE_RESOLVE}(d),p.value=d,this.uP(p)},`\n  + `${GLOBAL_CONTEXT_PROMISE_REJECT}:function(p,d){p.${LOCAL_CONTEXT_PROMISE_REJECT}(d),this.uP(p)},`\n  + `uS:function(s){delete s.${LOCAL_CONTEXT_STREAM_CONTROLLER}},`\n  + `${GLOBAL_CONTEXT_STREAM_EMIT}:function(s,t,d,c){switch(c=s.${LOCAL_CONTEXT_STREAM_CONTROLLER},t){case 0:return c.enqueue(d);case 1:return(this.uS(s),c.error(d));case 2:return(this.uS(s),c.close())}},`\n  + `${GLOBAL_CONTEXT_STREAM_CONSTRUCTOR}:function(s,c){return(s=new ReadableStream({start:function(x){c=x}})).${LOCAL_CONTEXT_STREAM_CONTROLLER}=c,s}`\n  + '}';\n\nexport function getCrossReferenceHeader(id?: string): string {\n  if (id == null) {\n    return `self.${GLOBAL_CONTEXT_REFERENCES}=self.${GLOBAL_CONTEXT_REFERENCES}||[];`;\n  }\n  return `(self.${GLOBAL_CONTEXT_REFERENCES}=self.${GLOBAL_CONTEXT_REFERENCES}||{})[\"${serializeString(id)}\"]=[]`;\n}\n", "/* eslint-disable no-restricted-globals */\nimport assert from './assert';\nimport { REFERENCES_KEY } from './keys';\n\nconst REFERENCE = new Map<unknown, string>();\nconst INV_REFERENCE = new Map<string, unknown>();\n\nexport function createReference<T>(id: string, value: T): T {\n  REFERENCE.set(value, id);\n  INV_REFERENCE.set(id, value);\n  return value;\n}\n\nexport function hasReferenceID<T>(value: T): boolean {\n  return REFERENCE.has(value);\n}\n\nexport function hasReference(id: string): boolean {\n  return INV_REFERENCE.has(id);\n}\n\nexport function getReferenceID<T>(value: T): string {\n  assert(hasReferenceID(value), new Error('Missing reference id'));\n  return REFERENCE.get(value)!;\n}\n\nexport function getReference<T>(id: string): T {\n  assert(hasReference(id), new Error('Missing reference for id:' + id));\n  return INV_REFERENCE.get(id) as T;\n}\n\nif (typeof globalThis !== undefined) {\n  Object.defineProperty(globalThis, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false,\n  });\n} else if (typeof window !== undefined) {\n  Object.defineProperty(window, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false,\n  });\n} else if (typeof self !== undefined) {\n  Object.defineProperty(self, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false,\n  });\n} else if (typeof global !== undefined) {\n  Object.defineProperty(global, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false,\n  });\n}\n", "import UnsupportedTypeError from './UnsupportedTypeError';\nimport assert from './assert';\nimport { Feature } from './compat';\nimport type { WellKnownSymbols } from './constants';\nimport { INV_SYMBOL_REF, SerovalNodeType } from './constants';\nimport type { BaseParserContext } from './context';\nimport {\n  INFINITY_NODE,\n  NEG_INFINITY_NODE,\n  NAN_NODE,\n  NEG_ZERO_NODE,\n} from './literals';\nimport { getReferenceID } from './reference';\nimport { serializeString } from './string';\nimport type {\n  SerovalArrayBufferNode,\n  SerovalBigIntNode,\n  SerovalConstantNode,\n  SerovalDateNode,\n  SerovalIndexedValueNode,\n  SerovalNumberNode,\n  SerovalReferenceNode,\n  SerovalRegExpNode,\n  SerovalStringNode,\n  SerovalWKSymbolNode,\n} from './types';\n\nexport function createNumberNode(value: number): SerovalConstantNode | SerovalNumberNode {\n  switch (value) {\n    case Infinity:\n      return INFINITY_NODE;\n    case -Infinity:\n      return NEG_INFINITY_NODE;\n    default:\n      // eslint-disable-next-line no-self-compare\n      if (value !== value) {\n        return NAN_NODE;\n      }\n      if (Object.is(value, -0)) {\n        return NEG_ZERO_NODE;\n      }\n      return {\n        t: SerovalNodeType.Number,\n        i: undefined,\n        s: value,\n        l: undefined,\n        c: undefined,\n        m: undefined,\n        p: undefined,\n        e: undefined,\n        a: undefined,\n        f: undefined,\n        b: undefined,\n        o: undefined,\n      };\n  }\n}\n\nexport function createStringNode(value: string): SerovalStringNode {\n  return {\n    t: SerovalNodeType.String,\n    i: undefined,\n    s: serializeString(value),\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nexport function createBigIntNode(\n  ctx: BaseParserContext,\n  current: bigint,\n): SerovalBigIntNode {\n  assert(ctx.features & Feature.BigInt, new UnsupportedTypeError(current));\n  return {\n    t: SerovalNodeType.BigInt,\n    i: undefined,\n    s: '' + current,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nexport function createIndexedValueNode(id: number): SerovalIndexedValueNode {\n  return {\n    t: SerovalNodeType.IndexedValue,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nexport function createDateNode(id: number, current: Date): SerovalDateNode {\n  return {\n    t: SerovalNodeType.Date,\n    i: id,\n    s: current.toISOString(),\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    f: undefined,\n    a: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nexport function createRegExpNode(id: number, current: RegExp): SerovalRegExpNode {\n  return {\n    t: SerovalNodeType.RegExp,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: current.source,\n    m: current.flags,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nexport function createArrayBufferNode(\n  id: number,\n  current: ArrayBuffer,\n): SerovalArrayBufferNode {\n  const bytes = new Uint8Array(current);\n  const len = bytes.length;\n  const values = new Array<number>(len);\n  for (let i = 0; i < len; i++) {\n    values[i] = bytes[i];\n  }\n  return {\n    t: SerovalNodeType.ArrayBuffer,\n    i: id,\n    s: values,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nexport function createWKSymbolNode(\n  ctx: BaseParserContext,\n  id: number,\n  current: WellKnownSymbols,\n): SerovalWKSymbolNode {\n  assert(ctx.features & Feature.Symbol, new UnsupportedTypeError(current));\n  assert(current in INV_SYMBOL_REF, new Error('Only well-known symbols are supported.'));\n  return {\n    t: SerovalNodeType.WKSymbol,\n    i: id,\n    s: INV_SYMBOL_REF[current],\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nexport function createReferenceNode<T>(\n  id: number,\n  ref: T,\n): SerovalReferenceNode {\n  return {\n    t: SerovalNodeType.Reference,\n    i: id,\n    s: serializeString(getReferenceID(ref)),\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n", "import assert from '../assert';\nimport { Feature } from '../compat';\nimport type { ParserContext } from './context';\nimport { createIndexedValue } from './context';\nimport type { BigIntTypedArrayValue, TypedArrayValue } from '../../types';\nimport UnsupportedTypeError from '../UnsupportedTypeError';\nimport { hasReferenceID } from '../reference';\nimport type {\n  SerovalBigIntTypedArrayNode,\n  SerovalTypedArrayNode,\n  SerovalWKSymbolNode,\n  SerovalReferenceNode,\n  SerovalDataViewNode,\n  SerovalNode,\n  SerovalIndexedValueNode,\n} from '../types';\nimport type { WellKnownSymbols } from '../constants';\nimport { SerovalNodeType } from '../constants';\nimport {\n  createArrayBufferNode,\n  createIndexedValueNode,\n  createReferenceNode,\n  createWKSymbolNode,\n} from '../base-primitives';\n\nexport function serializeArrayBuffer(\n  ctx: ParserContext,\n  current: ArrayBuffer,\n): SerovalNode {\n  const id = createIndexedValue(ctx, current);\n  if (ctx.reference.marked.has(id)) {\n    return createIndexedValueNode(id);\n  }\n  return createArrayBufferNode(id, current);\n}\n\nexport function createTypedArrayNode(\n  ctx: ParserContext,\n  id: number,\n  current: TypedArrayValue,\n): SerovalTypedArrayNode {\n  assert(ctx.features & Feature.TypedArray, new UnsupportedTypeError(current));\n  return {\n    t: SerovalNodeType.TypedArray,\n    i: id,\n    s: undefined,\n    l: current.length,\n    c: current.constructor.name,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: serializeArrayBuffer(ctx, current.buffer),\n    b: current.byteOffset,\n    o: undefined,\n  };\n}\n\nconst BIGINT_FLAG = Feature.BigIntTypedArray | Feature.BigInt;\n\nexport function createBigIntTypedArrayNode(\n  ctx: ParserContext,\n  id: number,\n  current: BigIntTypedArrayValue,\n): SerovalBigIntTypedArrayNode {\n  assert(\n    (ctx.features & BIGINT_FLAG) === BIGINT_FLAG,\n    new UnsupportedTypeError(current),\n  );\n  return {\n    t: SerovalNodeType.BigIntTypedArray,\n    i: id,\n    s: undefined,\n    l: current.length,\n    c: current.constructor.name,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: serializeArrayBuffer(ctx, current.buffer),\n    b: current.byteOffset,\n    o: undefined,\n  };\n}\n\nexport function createDataViewNode(\n  ctx: ParserContext,\n  id: number,\n  current: DataView,\n): SerovalDataViewNode {\n  return {\n    t: SerovalNodeType.DataView,\n    i: id,\n    s: undefined,\n    l: current.byteLength,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: serializeArrayBuffer(ctx, current.buffer),\n    b: current.byteOffset,\n    o: undefined,\n  };\n}\n\nexport function createSymbolNode(\n  ctx: ParserContext,\n  current: symbol,\n): SerovalIndexedValueNode | SerovalReferenceNode | SerovalWKSymbolNode {\n  const id = createIndexedValue(ctx, current);\n  if (ctx.reference.marked.has(id)) {\n    return createIndexedValueNode(id);\n  }\n  if (hasReferenceID(current)) {\n    return createReferenceNode(id, current);\n  }\n  return createWKSymbolNode(ctx, id, current as WellKnownSymbols);\n}\n\nexport function createFunctionNode(\n  ctx: ParserContext,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  current: Function,\n): SerovalIndexedValueNode | SerovalReferenceNode {\n  assert(hasReferenceID(current), new Error('Cannot serialize function without reference ID.'));\n  const id = createIndexedValue(ctx, current);\n  if (ctx.reference.marked.has(id)) {\n    return createIndexedValueNode(id);\n  }\n  return createReferenceNode(id, current);\n}\n", "import { Feature } from './compat';\nimport type {\n  ErrorValue,\n} from '../types';\nimport { SerovalObjectFlags } from './constants';\nimport type { BaseParserContext } from './context';\n\nexport function getErrorConstructorName(error: ErrorValue): string {\n  if (error instanceof EvalError) {\n    return 'EvalError';\n  }\n  if (error instanceof RangeError) {\n    return 'RangeError';\n  }\n  if (error instanceof ReferenceError) {\n    return 'ReferenceError';\n  }\n  if (error instanceof SyntaxError) {\n    return 'SyntaxError';\n  }\n  if (error instanceof TypeError) {\n    return 'TypeError';\n  }\n  if (error instanceof URIError) {\n    return 'URIError';\n  }\n  return 'Error';\n}\n\ntype ErrorConstructors =\n  | ErrorConstructor\n  | EvalErrorConstructor\n  | RangeErrorConstructor\n  | ReferenceErrorConstructor\n  | SyntaxErrorConstructor\n  | TypeErrorConstructor\n  | URIErrorConstructor;\n\nexport function getErrorConstructor(errorName: string): ErrorConstructors {\n  switch (errorName) {\n    case 'Error': return Error;\n    case 'EvalError': return EvalError;\n    case 'RangeError': return RangeError;\n    case 'ReferenceError': return ReferenceError;\n    case 'SyntaxError': return SyntaxError;\n    case 'TypeError': return TypeError;\n    case 'URIError': return URIError;\n    default:\n      throw new Error(`Unknown Error constructor \"${errorName}\"`);\n  }\n}\n\nexport function getErrorOptions(\n  ctx: BaseParserContext,\n  error: Error,\n): Record<string, unknown> | undefined {\n  let options: Record<string, unknown> | undefined;\n  const constructor = getErrorConstructorName(error);\n  // Name has been modified\n  if (error.name !== constructor) {\n    options = { name: error.name };\n  } else if (error.constructor.name !== constructor) {\n    // Otherwise, name is overriden because\n    // the Error class is extended\n    options = { name: error.constructor.name };\n  }\n  const names = Object.getOwnPropertyNames(error);\n  for (const name of names) {\n    if (name !== 'name' && name !== 'message') {\n      if (name === 'stack') {\n        if (ctx.features & Feature.ErrorPrototypeStack) {\n          options = options || {};\n          options[name] = error[name as keyof Error];\n        }\n      } else {\n        options = options || {};\n        options[name] = error[name as keyof Error];\n      }\n    }\n  }\n  return options;\n}\n\nexport function isIterable(\n  value: unknown,\n): value is Iterable<unknown> {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return false;\n  }\n  switch (value.constructor) {\n    case Map:\n    case Set:\n    case Int8Array:\n    case Int16Array:\n    case Int32Array:\n    case Uint8Array:\n    case Uint16Array:\n    case Uint32Array:\n    case Uint8ClampedArray:\n    case Float32Array:\n    case Float64Array:\n    case BigInt64Array:\n    case BigUint64Array:\n      return false;\n    default:\n      break;\n  }\n  return Symbol.iterator in value;\n}\n\ntype TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Int16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint8ArrayConstructor\n  | Uint16ArrayConstructor\n  | Uint32ArrayConstructor\n  | Uint8ClampedArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor\n  | BigInt64ArrayConstructor\n  | BigUint64ArrayConstructor;\n\nexport function getTypedArrayConstructor(name: string): TypedArrayConstructor {\n  switch (name) {\n    case 'Int8Array': return Int8Array;\n    case 'Int16Array': return Int16Array;\n    case 'Int32Array': return Int32Array;\n    case 'Uint8Array': return Uint8Array;\n    case 'Uint16Array': return Uint16Array;\n    case 'Uint32Array': return Uint32Array;\n    case 'Uint8ClampedArray': return Uint8ClampedArray;\n    case 'Float32Array': return Float32Array;\n    case 'Float64Array': return Float64Array;\n    case 'BigInt64Array': return BigInt64Array;\n    case 'BigUint64Array': return BigUint64Array;\n    default:\n      throw new Error(`Unknown TypedArray \"${name}\"`);\n  }\n}\n\nconst IDENTIFIER_CHECK = /^[$A-Z_][0-9A-Z_$]*$/i;\n\nexport function isValidIdentifier(name: string): boolean {\n  const char = name[0];\n  return (\n    char === '$'\n    || char === '_'\n    || (char >= 'A' && char <= 'Z')\n    || (char >= 'a' && char <= 'z')\n  ) && IDENTIFIER_CHECK.test(name);\n}\n\nexport function getObjectFlag(obj: unknown): SerovalObjectFlags {\n  if (Object.isFrozen(obj)) {\n    return SerovalObjectFlags.Frozen;\n  }\n  if (Object.isSealed(obj)) {\n    return SerovalObjectFlags.Sealed;\n  }\n  if (Object.isExtensible(obj)) {\n    return SerovalObjectFlags.None;\n  }\n  return SerovalObjectFlags.NonExtensible;\n}\n", "import assert from '../assert';\nimport { Feature } from '../compat';\nimport type { ParserContext } from './context';\nimport { serializeString } from '../string';\nimport UnsupportedTypeError from '../UnsupportedTypeError';\nimport { serializeArrayBuffer } from './primitives';\nimport type {\n  SerovalBlobNode,\n  SerovalFileNode,\n} from '../types';\nimport { SerovalNodeType } from '../constants';\n\nexport async function createBlobNode(\n  ctx: ParserContext,\n  id: number,\n  current: Blob,\n): Promise<SerovalBlobNode> {\n  assert(ctx.features & Feature.WebAPI, new UnsupportedTypeError(current));\n  return {\n    t: SerovalNodeType.Blob,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: serializeString(current.type),\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    f: serializeArrayBuffer(ctx, await current.arrayBuffer()),\n    a: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nexport async function createFileNode(\n  ctx: ParserContext,\n  id: number,\n  current: File,\n): Promise<SerovalFileNode> {\n  assert(ctx.features & Feature.WebAPI, new UnsupportedTypeError(current));\n  return {\n    t: SerovalNodeType.File,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: serializeString(current.type),\n    m: serializeString(current.name),\n    p: undefined,\n    e: undefined,\n    f: serializeArrayBuffer(ctx, await current.arrayBuffer()),\n    a: undefined,\n    b: current.lastModified,\n    o: undefined,\n  };\n}\n", "import UnsupportedTypeError from './UnsupportedTypeError';\nimport assert from './assert';\nimport { Feature } from './compat';\nimport { SerovalNodeType } from './constants';\nimport type { BaseParserContext } from './context';\nimport { serializeString } from './string';\nimport type { SerovalURLNode, SerovalURLSearchParamsNode } from './types';\n\nexport function createURLNode(\n  ctx: BaseParserContext,\n  id: number,\n  current: URL,\n): SerovalURLNode {\n  assert(ctx.features & Feature.WebAPI, new UnsupportedTypeError(current));\n  return {\n    t: SerovalNodeType.URL,\n    i: id,\n    s: serializeString(current.href),\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    f: undefined,\n    a: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nexport function createURLSearchParamsNode(\n  ctx: BaseParserContext,\n  id: number,\n  current: URLSearchParams,\n): SerovalURLSearchParamsNode {\n  assert(ctx.features & Feature.WebAPI, new UnsupportedTypeError(current));\n  return {\n    t: SerovalNodeType.URLSearchParams,\n    i: id,\n    s: serializeString(current.toString()),\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    f: undefined,\n    a: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n", "export default async function promiseToResult(\n  current: Promise<unknown>,\n): Promise<[0 | 1, unknown]> {\n  try {\n    return [1, await current];\n  } catch (e) {\n    return [0, e];\n  }\n}\n", "/* eslint-disable no-await-in-loop */\n/* eslint-disable @typescript-eslint/no-use-before-define */\nimport assert from '../assert';\nimport { Feature } from '../compat';\nimport type { ParserContext } from './context';\nimport {\n  createIndexedValue,\n} from './context';\nimport { serializeString } from '../string';\nimport type {\n  BigIntTypedArrayValue,\n  TypedArrayValue,\n} from '../../types';\nimport UnsupportedTypeError from '../UnsupportedTypeError';\nimport {\n  TRUE_NODE,\n  FALSE_NODE,\n  UNDEFINED_NODE,\n  NULL_NODE,\n} from '../literals';\nimport {\n  createBigIntTypedArrayNode,\n  createTypedArrayNode,\n  createDataViewNode,\n  createSymbolNode,\n  createFunctionNode,\n} from './primitives';\nimport { hasReferenceID } from '../reference';\nimport {\n  getErrorConstructorName,\n  getErrorOptions,\n  getObjectFlag,\n  isIterable,\n} from '../shared';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalBoxedNode,\n  SerovalErrorNode,\n  SerovalFormDataNode,\n  SerovalHeadersNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPlainRecordNode,\n  SerovalPromiseNode,\n  SerovalSetNode,\n} from '../types';\nimport {\n  SerovalObjectRecordSpecialKey,\n} from '../types';\nimport {\n  createBlobNode,\n  createFileNode,\n} from './web-api';\nimport { SerovalNodeType } from '../constants';\nimport {\n  createArrayBufferNode,\n  createBigIntNode,\n  createDateNode,\n  createIndexedValueNode,\n  createNumberNode,\n  createReferenceNode,\n  createRegExpNode,\n  createStringNode,\n} from '../base-primitives';\nimport { createURLNode, createURLSearchParamsNode } from '../web-api';\nimport promiseToResult from '../promise-to-result';\n\ntype ObjectLikeNode =\n  | SerovalObjectNode\n  | SerovalNullConstructorNode\n  | SerovalPromiseNode;\n\nasync function generateNodeList(\n  ctx: ParserContext,\n  current: unknown[],\n): Promise<SerovalNode[]> {\n  const size = current.length;\n  const nodes = new Array<SerovalNode>(size);\n  const deferred = new Array<unknown>(size);\n  let item: unknown;\n  for (let i = 0; i < size; i++) {\n    if (i in current) {\n      item = current[i];\n      if (isIterable(item)) {\n        deferred[i] = item;\n      } else {\n        nodes[i] = await parseAsync(ctx, item);\n      }\n    }\n  }\n  for (let i = 0; i < size; i++) {\n    if (i in deferred) {\n      nodes[i] = await parseAsync(ctx, deferred[i]);\n    }\n  }\n  return nodes;\n}\n\nasync function generateArrayNode(\n  ctx: ParserContext,\n  id: number,\n  current: unknown[],\n): Promise<SerovalArrayNode> {\n  return {\n    t: SerovalNodeType.Array,\n    i: id,\n    s: undefined,\n    l: current.length,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: await generateNodeList(ctx, current),\n    f: undefined,\n    b: undefined,\n    o: getObjectFlag(current),\n  };\n}\n\nasync function generateMapNode(\n  ctx: ParserContext,\n  id: number,\n  current: Map<unknown, unknown>,\n): Promise<SerovalMapNode> {\n  assert(ctx.features & Feature.Map, new UnsupportedTypeError(current));\n  const len = current.size;\n  const keyNodes = new Array<SerovalNode>(len);\n  const valueNodes = new Array<SerovalNode>(len);\n  const deferredKey = new Array<unknown>(len);\n  const deferredValue = new Array<unknown>(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const [key, value] of current.entries()) {\n    // Either key or value might be an iterable\n    if (isIterable(key) || isIterable(value)) {\n      deferredKey[deferredSize] = key;\n      deferredValue[deferredSize] = value;\n      deferredSize++;\n    } else {\n      keyNodes[nodeSize] = await parseAsync(ctx, key);\n      valueNodes[nodeSize] = await parseAsync(ctx, value);\n      nodeSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodeSize + i] = await parseAsync(ctx, deferredKey[i]);\n    valueNodes[nodeSize + i] = await parseAsync(ctx, deferredValue[i]);\n  }\n  return {\n    t: SerovalNodeType.Map,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: { k: keyNodes, v: valueNodes, s: len },\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nasync function generateSetNode(\n  ctx: ParserContext,\n  id: number,\n  current: Set<unknown>,\n): Promise<SerovalSetNode> {\n  assert(ctx.features & Feature.Set, new UnsupportedTypeError(current));\n  const len = current.size;\n  const nodes = new Array<SerovalNode>(len);\n  const deferred = new Array<unknown>(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const item of current.keys()) {\n    // Iterables are lazy, so the evaluation must be deferred\n    if (isIterable(item)) {\n      deferred[deferredSize++] = item;\n    } else {\n      nodes[nodeSize++] = await parseAsync(ctx, item);\n    }\n  }\n  // Parse deferred items\n  for (let i = 0; i < deferredSize; i++) {\n    nodes[nodeSize + i] = await parseAsync(ctx, deferred[i]);\n  }\n  return {\n    t: SerovalNodeType.Set,\n    i: id,\n    s: undefined,\n    l: len,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: nodes,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nasync function generateProperties(\n  ctx: ParserContext,\n  properties: Record<string, unknown>,\n): Promise<SerovalObjectRecordNode> {\n  const keys = Object.keys(properties);\n  let size = keys.length;\n  const keyNodes = new Array<SerovalObjectRecordKey>(size);\n  const valueNodes = new Array<SerovalNode>(size);\n  const deferredKeys = new Array<SerovalObjectRecordKey>(size);\n  const deferredValues = new Array<unknown>(size);\n  let deferredSize = 0;\n  let nodesSize = 0;\n  let item: unknown;\n  let escaped: SerovalObjectRecordKey;\n  for (const key of keys) {\n    item = properties[key];\n    escaped = serializeString(key);\n    if (isIterable(item)) {\n      deferredKeys[deferredSize] = escaped;\n      deferredValues[deferredSize] = item;\n      deferredSize++;\n    } else {\n      keyNodes[nodesSize] = escaped;\n      valueNodes[nodesSize] = await parseAsync(ctx, item);\n      nodesSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodesSize + i] = deferredKeys[i];\n    valueNodes[nodesSize + i] = await parseAsync(ctx, deferredValues[i]);\n  }\n  if (ctx.features & Feature.Symbol) {\n    if (Symbol.iterator in properties) {\n      keyNodes[size] = SerovalObjectRecordSpecialKey.SymbolIterator;\n      const items = Array.from(properties as Iterable<unknown>);\n      valueNodes[size] = await generateArrayNode(\n        ctx,\n        createIndexedValue(ctx, items),\n        items,\n      );\n      size++;\n    }\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: size,\n  };\n}\n\nasync function generatePlainProperties(\n  ctx: ParserContext,\n  properties: Record<string, unknown>,\n): Promise<SerovalPlainRecordNode> {\n  const keys = Object.keys(properties);\n  const size = keys.length;\n  const keyNodes = new Array<string>(size);\n  const valueNodes = new Array<SerovalNode>(size);\n  const deferredKeys = new Array<string>(size);\n  const deferredValues = new Array<unknown>(size);\n  let deferredSize = 0;\n  let nodesSize = 0;\n  let item: unknown;\n  let escaped: string;\n  for (const key of keys) {\n    item = properties[key];\n    escaped = serializeString(key);\n    if (isIterable(item)) {\n      deferredKeys[deferredSize] = escaped;\n      deferredValues[deferredSize] = item;\n      deferredSize++;\n    } else {\n      keyNodes[nodesSize] = escaped;\n      valueNodes[nodesSize] = await parseAsync(ctx, item);\n      nodesSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodesSize + i] = deferredKeys[i];\n    valueNodes[nodesSize + i] = await parseAsync(ctx, deferredValues[i]);\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: size,\n  };\n}\n\nasync function generatePromiseNode(\n  ctx: ParserContext,\n  id: number,\n  current: Promise<unknown>,\n): Promise<SerovalPromiseNode> {\n  assert(ctx.features & Feature.Promise, new UnsupportedTypeError(current));\n  const [status, result] = await promiseToResult(current);\n  return {\n    t: SerovalNodeType.Promise,\n    i: id,\n    s: status,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: await parseAsync(ctx, result),\n    b: undefined,\n    o: undefined,\n  };\n}\n\nasync function generateObjectNode(\n  ctx: ParserContext,\n  id: number,\n  current: Record<string, unknown>,\n  empty: boolean,\n): Promise<ObjectLikeNode> {\n  return {\n    t: empty ? SerovalNodeType.NullConstructor : SerovalNodeType.Object,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: await generateProperties(ctx, current),\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: getObjectFlag(current),\n  };\n}\n\nasync function generateAggregateErrorNode(\n  ctx: ParserContext,\n  id: number,\n  current: AggregateError,\n): Promise<SerovalAggregateErrorNode> {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options\n    ? await generateProperties(ctx, options)\n    : undefined;\n  return {\n    t: SerovalNodeType.AggregateError,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: serializeString(current.message),\n    p: optionsNode,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nasync function generateErrorNode(\n  ctx: ParserContext,\n  id: number,\n  current: Error,\n): Promise<SerovalErrorNode> {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options\n    ? await generateProperties(ctx, options)\n    : undefined;\n  return {\n    t: SerovalNodeType.Error,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: getErrorConstructorName(current),\n    m: serializeString(current.message),\n    p: optionsNode,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nasync function generateHeadersNode(\n  ctx: ParserContext,\n  id: number,\n  current: Headers,\n): Promise<SerovalHeadersNode> {\n  assert(ctx.features & Feature.WebAPI, new UnsupportedTypeError(current));\n  const items: Record<string, string> = {};\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: SerovalNodeType.Headers,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: await generatePlainProperties(ctx, items),\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nasync function generateFormDataNode(\n  ctx: ParserContext,\n  id: number,\n  current: FormData,\n): Promise<SerovalFormDataNode> {\n  assert(ctx.features & Feature.WebAPI, new UnsupportedTypeError(current));\n  const items: Record<string, FormDataEntryValue> = {};\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: SerovalNodeType.FormData,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: await generatePlainProperties(ctx, items),\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nasync function generateBoxedNode(\n  ctx: ParserContext,\n  id: number,\n  current: object,\n): Promise<SerovalBoxedNode> {\n  return {\n    t: SerovalNodeType.Boxed,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: await parseAsync(ctx, current.valueOf()),\n    b: undefined,\n    o: undefined,\n  };\n}\n\nasync function parseObject(\n  ctx: ParserContext,\n  current: object | null,\n): Promise<SerovalNode> {\n  if (!current) {\n    return NULL_NODE;\n  }\n  // Non-primitive values needs a reference ID\n  // mostly because the values themselves are stateful\n  const id = createIndexedValue(ctx, current);\n  if (ctx.reference.marked.has(id)) {\n    return createIndexedValueNode(id);\n  }\n  if (hasReferenceID(current)) {\n    return createReferenceNode(id, current);\n  }\n  if (Array.isArray(current)) {\n    return generateArrayNode(ctx, id, current);\n  }\n  switch (current.constructor) {\n    case Number:\n    case Boolean:\n    case String:\n    case BigInt:\n    case Function:\n    case Symbol:\n      return generateBoxedNode(ctx, id, current);\n    case Date:\n      return createDateNode(id, current as unknown as Date);\n    case RegExp:\n      return createRegExpNode(id, current as unknown as RegExp);\n    case Promise:\n      return generatePromiseNode(ctx, id, current as unknown as Promise<unknown>);\n    case ArrayBuffer:\n      return createArrayBufferNode(id, current as unknown as ArrayBuffer);\n    case Int8Array:\n    case Int16Array:\n    case Int32Array:\n    case Uint8Array:\n    case Uint16Array:\n    case Uint32Array:\n    case Uint8ClampedArray:\n    case Float32Array:\n    case Float64Array:\n      return createTypedArrayNode(ctx, id, current as unknown as TypedArrayValue);\n    case BigInt64Array:\n    case BigUint64Array:\n      return createBigIntTypedArrayNode(ctx, id, current as unknown as BigIntTypedArrayValue);\n    case DataView:\n      return createDataViewNode(ctx, id, current as unknown as DataView);\n    case Map:\n      return generateMapNode(\n        ctx,\n        id,\n        current as unknown as Map<unknown, unknown>,\n      );\n    case Set:\n      return generateSetNode(\n        ctx,\n        id,\n        current as unknown as Set<unknown>,\n      );\n    case Object:\n      return generateObjectNode(\n        ctx,\n        id,\n        current as Record<string, unknown>,\n        false,\n      );\n    case undefined:\n      return generateObjectNode(\n        ctx,\n        id,\n        current as Record<string, unknown>,\n        true,\n      );\n    case AggregateError:\n      if (ctx.features & Feature.AggregateError) {\n        return generateAggregateErrorNode(ctx, id, current as unknown as AggregateError);\n      }\n      return generateErrorNode(ctx, id, current as unknown as AggregateError);\n    case Error:\n    case EvalError:\n    case RangeError:\n    case ReferenceError:\n    case SyntaxError:\n    case TypeError:\n    case URIError:\n      return generateErrorNode(ctx, id, current as unknown as Error);\n    case URL:\n      return createURLNode(ctx, id, current as unknown as URL);\n    case URLSearchParams:\n      return createURLSearchParamsNode(ctx, id, current as unknown as URLSearchParams);\n    case Blob:\n      return createBlobNode(ctx, id, current as unknown as Blob);\n    case File:\n      return createFileNode(ctx, id, current as unknown as File);\n    case Headers:\n      return generateHeadersNode(ctx, id, current as unknown as Headers);\n    case FormData:\n      return generateFormDataNode(ctx, id, current as unknown as FormData);\n    default:\n      break;\n  }\n  if (current instanceof AggregateError) {\n    if (ctx.features & Feature.AggregateError) {\n      return generateAggregateErrorNode(ctx, id, current);\n    }\n    return generateErrorNode(ctx, id, current);\n  }\n  if (current instanceof Error) {\n    return generateErrorNode(ctx, id, current);\n  }\n  if (current instanceof Promise) {\n    return generatePromiseNode(ctx, id, current);\n  }\n  // Generator functions don't have a global constructor\n  if (Symbol.iterator in current) {\n    return generateObjectNode(ctx, id, current, !!current.constructor);\n  }\n  throw new UnsupportedTypeError(current);\n}\n\nexport default async function parseAsync<T>(\n  ctx: ParserContext,\n  current: T,\n): Promise<SerovalNode> {\n  switch (typeof current) {\n    case 'boolean':\n      return current ? TRUE_NODE : FALSE_NODE;\n    case 'undefined':\n      return UNDEFINED_NODE;\n    case 'string':\n      return createStringNode(current);\n    case 'number':\n      return createNumberNode(current);\n    case 'bigint':\n      return createBigIntNode(ctx, current);\n    case 'object':\n      return parseObject(ctx, current);\n    case 'symbol':\n      return createSymbolNode(ctx, current);\n    case 'function':\n      return createFunctionNode(ctx, current);\n    default:\n      throw new UnsupportedTypeError(current);\n  }\n}\n", "/* eslint-disable prefer-spread */\n/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type {\n  DeserializerContext,\n} from './context';\nimport { deserializeString } from '../string';\nimport type { BigIntTypedArrayValue, TypedArrayValue } from '../../types';\nimport { getReference } from '../reference';\nimport { getErrorConstructor, getTypedArrayConstructor } from '../shared';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayBufferNode,\n  SerovalArrayNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalBlobNode,\n  SerovalBoxedNode,\n  SerovalDataViewNode,\n  SerovalDateNode,\n  SerovalErrorNode,\n  SerovalFileNode,\n  SerovalFormDataNode,\n  SerovalHeadersNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPromiseNode,\n  SerovalReferenceNode,\n  SerovalRegExpNode,\n  SerovalSetNode,\n  SerovalTypedArrayNode,\n  SerovalURLNode,\n  SerovalURLSearchParamsNode,\n} from '../types';\nimport {\n  SerovalObjectRecordSpecialKey,\n} from '../types';\nimport {\n  SYMBOL_REF,\n  SerovalNodeType,\n  SerovalObjectFlags,\n  deserializeConstant,\n} from '../constants';\n\nfunction applyObjectFlag(obj: unknown, flag: SerovalObjectFlags): unknown {\n  switch (flag) {\n    case SerovalObjectFlags.Frozen:\n      return Object.freeze(obj);\n    case SerovalObjectFlags.NonExtensible:\n      return Object.preventExtensions(obj);\n    case SerovalObjectFlags.Sealed:\n      return Object.seal(obj);\n    default:\n      return obj;\n  }\n}\n\nfunction assignIndexedValue<T>(\n  ctx: DeserializerContext,\n  index: number,\n  value: T,\n): T {\n  if (ctx.refs.has(index)) {\n    ctx.values.set(index, value);\n  }\n  return value;\n}\n\nfunction deserializeArray(\n  ctx: DeserializerContext,\n  node: SerovalArrayNode,\n): unknown[] {\n  const len = node.l;\n  const result: unknown[] = assignIndexedValue(\n    ctx,\n    node.i,\n    new Array<unknown>(len),\n  );\n  let item: SerovalNode | undefined;\n  for (let i = 0; i < len; i++) {\n    item = node.a[i];\n    if (item) {\n      result[i] = deserializeTree(ctx, item);\n    }\n  }\n  applyObjectFlag(result, node.o);\n  return result;\n}\n\nfunction deserializeProperties(\n  ctx: DeserializerContext,\n  node: SerovalObjectRecordNode,\n  result: Record<string | symbol, unknown>,\n): Record<string | symbol, unknown> {\n  const len = node.s;\n  if (len) {\n    let key: SerovalObjectRecordKey;\n    let value: unknown;\n    const keys = node.k;\n    const vals = node.v;\n    for (let i = 0; i < len; i++) {\n      key = keys[i];\n      value = deserializeTree(ctx, vals[i]);\n      switch (key) {\n        case SerovalObjectRecordSpecialKey.SymbolIterator: {\n          const current = value as unknown[];\n          result[Symbol.iterator] = (): IterableIterator<unknown> => current.values();\n        }\n          break;\n        default:\n          result[deserializeString(key)] = value;\n          break;\n      }\n    }\n  }\n  return result;\n}\n\nfunction deserializeObject(\n  ctx: DeserializerContext,\n  node: SerovalObjectNode | SerovalNullConstructorNode,\n): Record<string, unknown> {\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    (node.t === SerovalNodeType.Object\n      ? {}\n      : Object.create(null)) as Record<string, unknown>,\n  );\n  deserializeProperties(ctx, node.p, result);\n  applyObjectFlag(result, node.o);\n  return result;\n}\n\nfunction deserializeSet(\n  ctx: DeserializerContext,\n  node: SerovalSetNode,\n): Set<unknown> {\n  const result = assignIndexedValue(ctx, node.i, new Set<unknown>());\n  const items = node.a;\n  for (let i = 0, len = node.l; i < len; i++) {\n    result.add(deserializeTree(ctx, items[i]));\n  }\n  return result;\n}\n\nfunction deserializeMap(\n  ctx: DeserializerContext,\n  node: SerovalMapNode,\n): Map<unknown, unknown> {\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new Map<unknown, unknown>(),\n  );\n  const keys = node.e.k;\n  const vals = node.e.v;\n  for (let i = 0, len = node.e.s; i < len; i++) {\n    result.set(\n      deserializeTree(ctx, keys[i]),\n      deserializeTree(ctx, vals[i]),\n    );\n  }\n  return result;\n}\n\ntype AssignableValue = AggregateError | Error | Iterable<unknown>\ntype AssignableNode = SerovalAggregateErrorNode | SerovalErrorNode;\n\nfunction deserializeDictionary<T extends AssignableValue>(\n  ctx: DeserializerContext,\n  node: AssignableNode,\n  result: T,\n): T {\n  if (node.p) {\n    const fields = deserializeProperties(ctx, node.p, {});\n    Object.assign(result, fields);\n  }\n  return result;\n}\n\nfunction deserializeAggregateError(\n  ctx: DeserializerContext,\n  node: SerovalAggregateErrorNode,\n): AggregateError {\n  // Serialize the required arguments\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new AggregateError([], deserializeString(node.m)),\n  );\n  // `AggregateError` might've been extended\n  // either through class or custom properties\n  // Make sure to assign extra properties\n  return deserializeDictionary(ctx, node, result);\n}\n\nfunction deserializeError(\n  ctx: DeserializerContext,\n  node: SerovalErrorNode,\n): Error {\n  const ErrorConstructor = getErrorConstructor(node.c);\n  const result = assignIndexedValue(ctx, node.i, new ErrorConstructor(deserializeString(node.m)));\n  return deserializeDictionary(ctx, node, result);\n}\n\ninterface Deferred {\n  resolve(value: unknown): void;\n  reject(value: unknown): void;\n  promise: Promise<unknown>;\n}\n\nfunction createDeferred(): Deferred {\n  let resolve: Deferred['resolve'];\n  let reject: Deferred['reject'];\n  return {\n    resolve(v): void {\n      resolve(v);\n    },\n    reject(v): void {\n      reject(v);\n    },\n    promise: new Promise((res, rej) => {\n      resolve = res as Deferred['resolve'];\n      reject = rej as Deferred['reject'];\n    }),\n  };\n}\n\nasync function deserializePromise(\n  ctx: DeserializerContext,\n  node: SerovalPromiseNode,\n): Promise<unknown> {\n  const deferred = createDeferred();\n  const result = assignIndexedValue(ctx, node.i, deferred.promise);\n  const deserialized = deserializeTree(ctx, node.f);\n  if (node.s) {\n    deferred.resolve(deserialized);\n  } else {\n    deferred.reject(deserialized);\n  }\n  return result;\n}\n\nfunction deserializeArrayBuffer(\n  ctx: DeserializerContext,\n  node: SerovalArrayBufferNode,\n): ArrayBuffer {\n  const bytes = new Uint8Array(node.s);\n  const result = assignIndexedValue(ctx, node.i, bytes.buffer);\n  return result;\n}\n\nfunction deserializeTypedArray(\n  ctx: DeserializerContext,\n  node: SerovalTypedArrayNode | SerovalBigIntTypedArrayNode,\n): TypedArrayValue | BigIntTypedArrayValue {\n  const TypedArray = getTypedArrayConstructor(node.c);\n  const source = deserializeTree(ctx, node.f) as ArrayBuffer;\n  const result = assignIndexedValue(ctx, node.i, new TypedArray(\n    source,\n    node.b,\n    node.l,\n  ));\n  return result;\n}\n\nfunction deserializeDate(\n  ctx: DeserializerContext,\n  node: SerovalDateNode,\n): Date {\n  return assignIndexedValue(ctx, node.i, new Date(node.s));\n}\n\nfunction deserializeRegExp(\n  ctx: DeserializerContext,\n  node: SerovalRegExpNode,\n): RegExp {\n  return assignIndexedValue(ctx, node.i, new RegExp(node.c, node.m));\n}\n\nfunction deserializeURL(\n  ctx: DeserializerContext,\n  node: SerovalURLNode,\n): URL {\n  return assignIndexedValue(ctx, node.i, new URL(deserializeString(node.s)));\n}\n\nfunction deserializeURLSearchParams(\n  ctx: DeserializerContext,\n  node: SerovalURLSearchParamsNode,\n): URLSearchParams {\n  return assignIndexedValue(ctx, node.i, new URLSearchParams(deserializeString(node.s)));\n}\n\nfunction deserializeReference(\n  ctx: DeserializerContext,\n  node: SerovalReferenceNode,\n): unknown {\n  return assignIndexedValue(ctx, node.i, getReference(deserializeString(node.s)));\n}\n\nfunction deserializeDataView(\n  ctx: DeserializerContext,\n  node: SerovalDataViewNode,\n): DataView {\n  const source = deserializeTree(ctx, node.f) as ArrayBuffer;\n  const result = assignIndexedValue(ctx, node.i, new DataView(\n    source,\n    node.b,\n    node.l,\n  ));\n  return result;\n}\n\nfunction deserializeBlob(\n  ctx: DeserializerContext,\n  node: SerovalBlobNode,\n): Blob {\n  const source = deserializeTree(ctx, node.f) as ArrayBuffer;\n  const result = assignIndexedValue(ctx, node.i, new Blob(\n    [source],\n    { type: deserializeString(node.c) },\n  ));\n  return result;\n}\n\nfunction deserializeFile(\n  ctx: DeserializerContext,\n  node: SerovalFileNode,\n): File {\n  const source = deserializeTree(ctx, node.f) as ArrayBuffer;\n  const result = assignIndexedValue(ctx, node.i, new File(\n    [source],\n    deserializeString(node.m),\n    { type: deserializeString(node.c), lastModified: node.b },\n  ));\n  return result;\n}\n\nfunction deserializeHeaders(\n  ctx: DeserializerContext,\n  node: SerovalHeadersNode,\n): Headers {\n  const result = assignIndexedValue(ctx, node.i, new Headers());\n  const keys = node.e.k;\n  const vals = node.e.v;\n  for (let i = 0, len = node.e.s; i < len; i++) {\n    result.set(\n      deserializeString(keys[i]),\n      deserializeTree(ctx, vals[i]) as string,\n    );\n  }\n  return result;\n}\n\nfunction deserializeFormData(\n  ctx: DeserializerContext,\n  node: SerovalFormDataNode,\n): FormData {\n  const result = assignIndexedValue(ctx, node.i, new FormData());\n  const keys = node.e.k;\n  const vals = node.e.v;\n  for (let i = 0, len = node.e.s; i < len; i++) {\n    result.set(\n      deserializeString(keys[i]),\n      deserializeTree(ctx, vals[i]) as FormDataEntryValue,\n    );\n  }\n  return result;\n}\n\nfunction deserializeBoxed(\n  ctx: DeserializerContext,\n  node: SerovalBoxedNode,\n): unknown {\n  return assignIndexedValue(\n    ctx,\n    node.i,\n    Object(deserializeTree(ctx, node.f)),\n  );\n}\n\nexport default function deserializeTree(\n  ctx: DeserializerContext,\n  node: SerovalNode,\n): unknown {\n  switch (node.t) {\n    case SerovalNodeType.Constant:\n      return deserializeConstant(node);\n    case SerovalNodeType.Number:\n      return node.s;\n    case SerovalNodeType.String:\n      return deserializeString(node.s);\n    case SerovalNodeType.BigInt:\n      return BigInt(node.s);\n    case SerovalNodeType.IndexedValue:\n      return ctx.values.get(node.i);\n    case SerovalNodeType.Array:\n      return deserializeArray(ctx, node);\n    case SerovalNodeType.Object:\n    case SerovalNodeType.NullConstructor:\n      return deserializeObject(ctx, node);\n    case SerovalNodeType.Date:\n      return deserializeDate(ctx, node);\n    case SerovalNodeType.RegExp:\n      return deserializeRegExp(ctx, node);\n    case SerovalNodeType.Set:\n      return deserializeSet(ctx, node);\n    case SerovalNodeType.Map:\n      return deserializeMap(ctx, node);\n    case SerovalNodeType.ArrayBuffer:\n      return deserializeArrayBuffer(ctx, node);\n    case SerovalNodeType.BigIntTypedArray:\n    case SerovalNodeType.TypedArray:\n      return deserializeTypedArray(ctx, node);\n    case SerovalNodeType.DataView:\n      return deserializeDataView(ctx, node);\n    case SerovalNodeType.AggregateError:\n      return deserializeAggregateError(ctx, node);\n    case SerovalNodeType.Error:\n      return deserializeError(ctx, node);\n    case SerovalNodeType.Promise:\n      return deserializePromise(ctx, node);\n    case SerovalNodeType.WKSymbol:\n      return SYMBOL_REF[node.s];\n    case SerovalNodeType.URL:\n      return deserializeURL(ctx, node);\n    case SerovalNodeType.URLSearchParams:\n      return deserializeURLSearchParams(ctx, node);\n    case SerovalNodeType.Reference:\n      return deserializeReference(ctx, node);\n    case SerovalNodeType.Blob:\n      return deserializeBlob(ctx, node);\n    case SerovalNodeType.File:\n      return deserializeFile(ctx, node);\n    case SerovalNodeType.Headers:\n      return deserializeHeaders(ctx, node);\n    case SerovalNodeType.FormData:\n      return deserializeFormData(ctx, node);\n    case SerovalNodeType.Boxed:\n      return deserializeBoxed(ctx, node);\n    default:\n      throw new Error('invariant');\n  }\n}\n", "import { SerovalObjectFlags } from './constants';\n\ninterface IndexAssignment {\n  t: 'index';\n  s: string;\n  k: undefined;\n  v: string;\n}\n\ninterface SetAssignment {\n  t: 'set';\n  s: string;\n  k: string;\n  v: string;\n}\n\ninterface AddAssignment {\n  t: 'add';\n  s: string;\n  k: undefined;\n  v: string;\n}\n\ninterface AppendAssignment {\n  t: 'append';\n  s: string;\n  k: string;\n  v: string;\n}\n\n// Array of assignments to be done (used for recursion)\nexport type Assignment =\n  | IndexAssignment\n  | AddAssignment\n  | SetAssignment\n  | AppendAssignment;\n\nexport interface FlaggedObject {\n  type: SerovalObjectFlags;\n  value: string;\n}\n\nfunction getAssignmentExpression(assignment: Assignment): string {\n  switch (assignment.t) {\n    case 'index':\n      return assignment.s + '=' + assignment.v;\n    case 'set':\n      return assignment.s + '.set(' + assignment.k + ',' + assignment.v + ')';\n    case 'add':\n      return assignment.s + '.add(' + assignment.v + ')';\n    case 'append':\n      return assignment.s + '.append(' + assignment.k + ',' + assignment.v + ')';\n    default:\n      return '';\n  }\n}\n\nconst OBJECT_FLAG_CONSTRUCTOR: Record<SerovalObjectFlags, string | undefined> = {\n  [SerovalObjectFlags.Frozen]: 'Object.freeze',\n  [SerovalObjectFlags.Sealed]: 'Object.seal',\n  [SerovalObjectFlags.NonExtensible]: 'Object.preventExtensions',\n  [SerovalObjectFlags.None]: undefined,\n};\n\nfunction mergeAssignments(assignments: Assignment[]): Assignment[] {\n  const newAssignments: Assignment[] = [];\n  let current = assignments[0];\n  let prev = current;\n  let item: Assignment;\n  for (let i = 1, len = assignments.length; i < len; i++) {\n    item = assignments[i];\n    if (item.t === prev.t) {\n      switch (item.t) {\n        case 'index':\n          if (item.v === prev.v) {\n            // Merge if the right-hand value is the same\n            // saves at least 2 chars\n            current = {\n              t: 'index',\n              s: item.s,\n              k: undefined,\n              v: getAssignmentExpression(current),\n            };\n          } else {\n            // Different assignment, push current\n            newAssignments.push(current);\n            current = item;\n          }\n          break;\n        case 'set':\n          if (item.s === prev.s) {\n            // Maps has chaining methods, merge if source is the same\n            current = {\n              t: 'set',\n              s: getAssignmentExpression(current),\n              k: item.k,\n              v: item.v,\n            };\n          } else {\n            // Different assignment, push current\n            newAssignments.push(current);\n            current = item;\n          }\n          break;\n        case 'add':\n          if (item.s === prev.s) {\n            // Sets has chaining methods too\n            current = {\n              t: 'add',\n              s: getAssignmentExpression(current),\n              k: undefined,\n              v: item.v,\n            };\n          } else {\n            // Different assignment, push current\n            newAssignments.push(current);\n            current = item;\n          }\n          break;\n        case 'append':\n          // Different assignment, push current\n          newAssignments.push(current);\n          current = item;\n          break;\n        default:\n          break;\n      }\n    } else {\n      newAssignments.push(current);\n      current = item;\n    }\n    prev = item;\n  }\n\n  newAssignments.push(current);\n\n  return newAssignments;\n}\n\nexport function resolveAssignments(assignments: Assignment[]): string | undefined {\n  if (assignments.length) {\n    let result = '';\n    const merged = mergeAssignments(assignments);\n    for (let i = 0, len = merged.length; i < len; i++) {\n      result += getAssignmentExpression(merged[i]) + ',';\n    }\n    return result;\n  }\n  return undefined;\n}\n\nexport function resolveFlags(flags: FlaggedObject[]): string | undefined {\n  let result = '';\n  for (let i = 0, len = flags.length; i < len; i++) {\n    const flag = flags[i];\n    result += OBJECT_FLAG_CONSTRUCTOR[flag.type] + '(' + flag.value + '),';\n  }\n  return result;\n}\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { Feature } from '../compat';\nimport type {\n  SerializerContext,\n} from './context';\nimport {\n  getRefParam,\n  markRef,\n} from './context';\nimport { isValidIdentifier } from '../shared';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalErrorNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalPromiseNode,\n  SerovalIndexedValueNode,\n  SerovalSetNode,\n  SerovalTypedArrayNode,\n  SerovalArrayBufferNode,\n  SerovalDataViewNode,\n  SerovalBlobNode,\n  SerovalFileNode,\n  SerovalHeadersNode,\n  SerovalRegExpNode,\n  SerovalDateNode,\n  SerovalURLNode,\n  SerovalURLSearchParamsNode,\n  SerovalReferenceNode,\n  SerovalFormDataNode,\n  SerovalObjectRecordNode,\n  SerovalObjectRecordKey,\n  SerovalBoxedNode,\n  SerovalWKSymbolNode,\n} from '../types';\nimport {\n  SerovalObjectRecordSpecialKey,\n} from '../types';\nimport {\n  SerovalObjectFlags,\n  SerovalNodeType,\n  SYMBOL_STRING,\n  serializeConstant,\n} from '../constants';\nimport type { Assignment } from '../assignments';\nimport { resolveAssignments, resolveFlags } from '../assignments';\nimport { REFERENCES_KEY } from '../keys';\n\nfunction pushObjectFlag(ctx: SerializerContext, flag: SerovalObjectFlags, id: number): void {\n  if (flag !== SerovalObjectFlags.None) {\n    markRef(ctx, id);\n    ctx.flags.push({\n      type: flag,\n      value: getRefParam(ctx, id),\n    });\n  }\n}\n\nexport function resolvePatches(ctx: SerializerContext): string | undefined {\n  const assignments = resolveAssignments(ctx.assignments);\n  const flags = resolveFlags(ctx.flags);\n  if (assignments) {\n    if (flags) {\n      return assignments + flags;\n    }\n    return assignments;\n  }\n  return flags;\n}\n\n/**\n * Generates the inlined assignment for the reference\n * This is different from the assignments array as this one\n * signifies creation rather than mutation\n */\n\nfunction createAssignment(\n  ctx: SerializerContext,\n  source: string,\n  value: string,\n): void {\n  ctx.assignments.push({\n    t: 'index',\n    s: source,\n    k: undefined,\n    v: value,\n  });\n}\n\nfunction createAddAssignment(\n  ctx: SerializerContext,\n  ref: number,\n  value: string,\n): void {\n  ctx.assignments.push({\n    t: 'add',\n    s: getRefParam(ctx, ref),\n    k: undefined,\n    v: value,\n  });\n}\n\nfunction createSetAssignment(\n  ctx: SerializerContext,\n  ref: number,\n  key: string,\n  value: string,\n): void {\n  ctx.assignments.push({\n    t: 'set',\n    s: getRefParam(ctx, ref),\n    k: key,\n    v: value,\n  });\n}\n\nfunction createAppendAssignment(\n  ctx: SerializerContext,\n  ref: number,\n  key: string,\n  value: string,\n): void {\n  ctx.assignments.push({\n    t: 'append',\n    s: getRefParam(ctx, ref),\n    k: key,\n    v: value,\n  });\n}\n\nfunction createArrayAssign(\n  ctx: SerializerContext,\n  ref: number,\n  index: number | string,\n  value: string,\n): void {\n  createAssignment(ctx, getRefParam(ctx, ref) + '[' + index + ']', value);\n}\n\nfunction createObjectAssign(\n  ctx: SerializerContext,\n  ref: number,\n  key: string,\n  value: string,\n): void {\n  markRef(ctx, ref);\n  createAssignment(ctx, getRefParam(ctx, ref) + '.' + key, value);\n}\n\nfunction assignIndexedValue(\n  ctx: SerializerContext,\n  index: number,\n  value: string,\n): string {\n  if (ctx.reference.marked.has(index)) {\n    return getRefParam(ctx, index) + '=' + value;\n  }\n  return value;\n}\n\nfunction isIndexedValueInStack(\n  ctx: SerializerContext,\n  node: SerovalNode,\n): node is SerovalIndexedValueNode {\n  return node.t === SerovalNodeType.IndexedValue && ctx.stack.includes(node.i);\n}\n\nfunction serializeArray(\n  ctx: SerializerContext,\n  node: SerovalArrayNode,\n): string {\n  const id = node.i;\n  ctx.stack.push(id);\n  // This is different than Map and Set\n  // because we also need to serialize\n  // the holes of the Array\n  let values = '';\n  let item: SerovalNode | undefined;\n  let isHoley = false;\n  const list = node.a;\n  for (let i = 0, len = node.l; i < len; i++) {\n    if (i !== 0) {\n      // Add an empty item\n      values += ',';\n    }\n    item = list[i];\n    // Check if index is a hole\n    if (item) {\n      // Check if item is a parent\n      if (isIndexedValueInStack(ctx, item)) {\n        markRef(ctx, id);\n        createArrayAssign(ctx, id, i, getRefParam(ctx, item.i));\n        isHoley = true;\n      } else {\n        values += serializeTree(ctx, item);\n        isHoley = false;\n      }\n    } else {\n      isHoley = true;\n    }\n  }\n  ctx.stack.pop();\n  pushObjectFlag(ctx, node.o, node.i);\n  return assignIndexedValue(ctx, id, '[' + values + (isHoley ? ',]' : ']'));\n}\n\nfunction getIterableAccess(ctx: SerializerContext): string {\n  return ctx.features & Feature.ArrayPrototypeValues\n    ? '.values()'\n    : '[Symbol.iterator]()';\n}\n\nfunction serializeIterable(\n  ctx: SerializerContext,\n  node: SerovalNode,\n): string {\n  const parent = ctx.stack;\n  ctx.stack = [];\n  let serialized = serializeTree(ctx, node) + getIterableAccess(ctx);\n  ctx.stack = parent;\n  if (ctx.features & Feature.ArrowFunction) {\n    serialized = '[Symbol.iterator]:()=>' + serialized;\n  } else if (ctx.features & Feature.MethodShorthand) {\n    serialized = '[Symbol.iterator](){return ' + serialized + '}';\n  } else {\n    serialized = '[Symbol.iterator]:function(){return ' + serialized + '}';\n  }\n  return serialized;\n}\n\nfunction serializeProperties(\n  ctx: SerializerContext,\n  sourceID: number,\n  node: SerovalObjectRecordNode,\n): string {\n  const len = node.s;\n  if (len === 0) {\n    return '{}';\n  }\n  let result = '';\n  ctx.stack.push(sourceID);\n  let key: SerovalObjectRecordKey;\n  let val: SerovalNode;\n  let check: number;\n  let isIdentifier: boolean;\n  let refParam: string;\n  let hasPrev = false;\n  const keys = node.k;\n  const values = node.v;\n  for (let i = 0; i < len; i++) {\n    key = keys[i];\n    val = values[i];\n    switch (key) {\n      case SerovalObjectRecordSpecialKey.SymbolIterator:\n        result += (hasPrev ? ',' : '') + serializeIterable(ctx, val);\n        hasPrev = true;\n        break;\n      default:\n        check = Number(key);\n        // Test if key is a valid number or JS identifier\n        // so that we don't have to serialize the key and wrap with brackets\n        isIdentifier = check >= 0 || isValidIdentifier(key);\n        if (isIndexedValueInStack(ctx, val)) {\n          refParam = getRefParam(ctx, val.i);\n          markRef(ctx, sourceID);\n          if (isIdentifier && Number.isNaN(check)) {\n            createObjectAssign(ctx, sourceID, key, refParam);\n          } else {\n            createArrayAssign(ctx, sourceID, isIdentifier ? key : ('\"' + key + '\"'), refParam);\n          }\n        } else {\n          result += (hasPrev ? ',' : '')\n            + (isIdentifier ? key : ('\"' + key + '\"'))\n            + ':' + serializeTree(ctx, val);\n          hasPrev = true;\n        }\n        break;\n    }\n  }\n  ctx.stack.pop();\n  return '{' + result + '}';\n}\n\nfunction serializeWithObjectAssign(\n  ctx: SerializerContext,\n  value: SerovalObjectRecordNode,\n  id: number,\n  serialized: string,\n): string {\n  const fields = serializeProperties(ctx, id, value);\n  if (fields !== '{}') {\n    return 'Object.assign(' + serialized + ',' + fields + ')';\n  }\n  return serialized;\n}\n\nfunction serializeAssignments(\n  ctx: SerializerContext,\n  sourceID: number,\n  node: SerovalObjectRecordNode,\n): string | undefined {\n  ctx.stack.push(sourceID);\n  const mainAssignments: Assignment[] = [];\n  let key: SerovalObjectRecordKey;\n  let value: SerovalNode;\n  let parentAssignment: Assignment[];\n  const keys = node.k;\n  const values = node.v;\n  for (let i = 0, len = node.s; i < len; i++) {\n    key = keys[i];\n    value = values[i];\n    switch (key) {\n      case SerovalObjectRecordSpecialKey.SymbolIterator: {\n        const parent = ctx.stack;\n        ctx.stack = [];\n        const serialized = serializeTree(ctx, value) + getIterableAccess(ctx);\n        ctx.stack = parent;\n        parentAssignment = ctx.assignments;\n        ctx.assignments = mainAssignments;\n        createArrayAssign(\n          ctx,\n          sourceID,\n          'Symbol.iterator',\n          ctx.features & Feature.ArrowFunction\n            ? '()=>' + serialized\n            : 'function(){return ' + serialized + '}',\n        );\n        ctx.assignments = parentAssignment;\n      }\n        break;\n      default: {\n        const serialized = serializeTree(ctx, value);\n        const check = Number(key);\n        const isIdentifier = check >= 0 || isValidIdentifier(key);\n        if (isIndexedValueInStack(ctx, value)) {\n          // Test if key is a valid number or JS identifier\n          // so that we don't have to serialize the key and wrap with brackets\n          if (isIdentifier && Number.isNaN(check)) {\n            createObjectAssign(ctx, sourceID, key, serialized);\n          } else {\n            createArrayAssign(ctx, sourceID, isIdentifier ? key : ('\"' + key + '\"'), serialized);\n          }\n        } else {\n          // Test if key is a valid number or JS identifier\n          // so that we don't have to serialize the key and wrap with brackets\n          parentAssignment = ctx.assignments;\n          ctx.assignments = mainAssignments;\n          if (isIdentifier && Number.isNaN(check)) {\n            createObjectAssign(ctx, sourceID, key, serialized);\n          } else {\n            createArrayAssign(ctx, sourceID, isIdentifier ? key : ('\"' + key + '\"'), serialized);\n          }\n          ctx.assignments = parentAssignment;\n        }\n      }\n    }\n  }\n  ctx.stack.pop();\n  return resolveAssignments(mainAssignments);\n}\n\nfunction serializeDictionary(\n  ctx: SerializerContext,\n  i: number,\n  p: SerovalObjectRecordNode | undefined,\n  init: string,\n): string {\n  if (p) {\n    if (ctx.features & Feature.ObjectAssign) {\n      init = serializeWithObjectAssign(ctx, p, i, init);\n    } else {\n      markRef(ctx, i);\n      const assignments = serializeAssignments(ctx, i, p);\n      if (assignments) {\n        return '(' + assignIndexedValue(ctx, i, init) + ',' + assignments + getRefParam(ctx, i) + ')';\n      }\n    }\n  }\n  return assignIndexedValue(ctx, i, init);\n}\n\nconst NULL_CONSTRUCTOR = 'Object.create(null)';\n\nfunction serializeNullConstructor(\n  ctx: SerializerContext,\n  node: SerovalNullConstructorNode,\n): string {\n  pushObjectFlag(ctx, node.o, node.i);\n  return serializeDictionary(ctx, node.i, node.p, NULL_CONSTRUCTOR);\n}\n\nfunction serializeObject(\n  ctx: SerializerContext,\n  node: SerovalObjectNode,\n): string {\n  pushObjectFlag(ctx, node.o, node.i);\n  return assignIndexedValue(ctx, node.i, serializeProperties(ctx, node.i, node.p));\n}\n\nfunction serializeSet(\n  ctx: SerializerContext,\n  node: SerovalSetNode,\n): string {\n  let serialized = 'new Set';\n  const size = node.l;\n  const id = node.i;\n  if (size) {\n    let result = '';\n    let item: SerovalNode;\n    let hasPrev = false;\n    const items = node.a;\n    ctx.stack.push(id);\n    for (let i = 0; i < size; i++) {\n      item = items[i];\n      if (isIndexedValueInStack(ctx, item)) {\n        markRef(ctx, id);\n        createAddAssignment(ctx, id, getRefParam(ctx, item.i));\n      } else {\n        // Push directly\n        result += (hasPrev ? ',' : '') + serializeTree(ctx, item);\n        hasPrev = true;\n      }\n    }\n    ctx.stack.pop();\n    if (result) {\n      serialized += '([' + result + '])';\n    }\n  }\n  return assignIndexedValue(ctx, id, serialized);\n}\n\nfunction serializeMap(\n  ctx: SerializerContext,\n  node: SerovalMapNode,\n): string {\n  let serialized = 'new Map';\n  const size = node.e.s;\n  const id = node.i;\n  if (size) {\n    let result = '';\n    let key: SerovalNode;\n    let val: SerovalNode;\n    let keyRef: string;\n    let valueRef: string;\n    let parent: number[];\n    let hasPrev = false;\n    const keys = node.e.k;\n    const vals = node.e.v;\n    ctx.stack.push(id);\n    for (let i = 0; i < size; i++) {\n      // Check if key is a parent\n      key = keys[i];\n      val = vals[i];\n      if (isIndexedValueInStack(ctx, key)) {\n        // Create reference for the map instance\n        keyRef = getRefParam(ctx, id);\n        markRef(ctx, id);\n        // Check if value is a parent\n        if (isIndexedValueInStack(ctx, val)) {\n          valueRef = getRefParam(ctx, val.i);\n          // Register an assignment since\n          // both key and value are a parent of this\n          // Map instance\n          createSetAssignment(ctx, id, keyRef, valueRef);\n        } else {\n          // Reset the stack\n          // This is required because the serialized\n          // value is no longer part of the expression\n          // tree and has been moved to the deferred\n          // assignment\n          parent = ctx.stack;\n          ctx.stack = [];\n          createSetAssignment(ctx, id, keyRef, serializeTree(ctx, val));\n          ctx.stack = parent;\n        }\n      } else if (isIndexedValueInStack(ctx, val)) {\n        // Create ref for the Map instance\n        valueRef = getRefParam(ctx, val.i);\n        markRef(ctx, id);\n        // Reset stack for the key serialization\n        parent = ctx.stack;\n        ctx.stack = [];\n        createSetAssignment(ctx, id, serializeTree(ctx, key), valueRef);\n        ctx.stack = parent;\n      } else {\n        result += (hasPrev ? ',[' : '[') + serializeTree(ctx, key) + ',' + serializeTree(ctx, val) + ']';\n        hasPrev = true;\n      }\n    }\n    ctx.stack.pop();\n    // Check if there are any values\n    // so that the empty Map constructor\n    // can be used instead\n    if (result) {\n      serialized += '([' + result + '])';\n    }\n  }\n  return assignIndexedValue(ctx, id, serialized);\n}\n\nfunction serializeAggregateError(\n  ctx: SerializerContext,\n  node: SerovalAggregateErrorNode,\n): string {\n  // Serialize the required arguments\n  const id = node.i;\n  ctx.stack.push(id);\n  const serialized = 'new AggregateError([],\"' + node.m + '\")';\n  ctx.stack.pop();\n  // `AggregateError` might've been extended\n  // either through class or custom properties\n  // Make sure to assign extra properties\n  return serializeDictionary(ctx, id, node.p, serialized);\n}\n\nfunction serializeError(\n  ctx: SerializerContext,\n  node: SerovalErrorNode,\n): string {\n  return serializeDictionary(ctx, node.i, node.p, 'new ' + node.c + '(\"' + node.m + '\")');\n}\n\nconst PROMISE_RESOLVE = 'Promise.resolve';\nconst PROMISE_REJECT = 'Promise.reject';\n\nfunction serializePromise(\n  ctx: SerializerContext,\n  node: SerovalPromiseNode,\n): string {\n  let serialized: string;\n  // Check if resolved value is a parent expression\n  const fulfilled = node.f;\n  const id = node.i;\n  const constructor = node.s ? PROMISE_RESOLVE : PROMISE_REJECT;\n  if (isIndexedValueInStack(ctx, fulfilled)) {\n    // A Promise trick, reference the value\n    // inside the `then` expression so that\n    // the Promise evaluates after the parent\n    // has initialized\n    const ref = getRefParam(ctx, fulfilled.i);\n    if (ctx.features & Feature.ArrowFunction) {\n      if (node.s) {\n        serialized = constructor + '().then(()=>' + ref + ')';\n      } else {\n        serialized = constructor + '().catch(()=>{throw ' + ref + '})';\n      }\n    } else if (node.s) {\n      serialized = constructor + '().then(function(){return ' + ref + '})';\n    } else {\n      serialized = constructor + '().catch(function(){throw ' + ref + '})';\n    }\n  } else {\n    ctx.stack.push(id);\n    const result = serializeTree(ctx, fulfilled);\n    ctx.stack.pop();\n    // just inline the value/reference here\n    serialized = constructor + '(' + result + ')';\n  }\n  return assignIndexedValue(ctx, id, serialized);\n}\n\nfunction serializeArrayBuffer(\n  ctx: SerializerContext,\n  node: SerovalArrayBufferNode,\n): string {\n  let result = 'new Uint8Array(';\n  const buffer = node.s;\n  const len = buffer.length;\n  if (len) {\n    result += '[';\n    for (let i = 0; i < len; i++) {\n      result += ((i > 0) ? ',' : '') + buffer[i];\n    }\n    result += ']';\n  }\n  return assignIndexedValue(ctx, node.i, result + ').buffer');\n}\n\nfunction serializeTypedArray(\n  ctx: SerializerContext,\n  node: SerovalTypedArrayNode | SerovalBigIntTypedArrayNode,\n): string {\n  return assignIndexedValue(\n    ctx,\n    node.i,\n    'new ' + node.c + '(' + serializeTree(ctx, node.f) + ',' + node.b + ',' + node.l + ')',\n  );\n}\n\nfunction serializeDate(\n  ctx: SerializerContext,\n  node: SerovalDateNode,\n): string {\n  return assignIndexedValue(ctx, node.i, 'new Date(\"' + node.s + '\")');\n}\n\nfunction serializeRegExp(\n  ctx: SerializerContext,\n  node: SerovalRegExpNode,\n): string {\n  return assignIndexedValue(ctx, node.i, '/' + node.c + '/' + node.m);\n}\n\nfunction serializeURL(\n  ctx: SerializerContext,\n  node: SerovalURLNode,\n): string {\n  return assignIndexedValue(ctx, node.i, 'new URL(\"' + node.s + '\")');\n}\n\nfunction serializeURLSearchParams(\n  ctx: SerializerContext,\n  node: SerovalURLSearchParamsNode,\n): string {\n  return assignIndexedValue(\n    ctx,\n    node.i,\n    node.s ? 'new URLSearchParams(\"' + node.s + '\")' : 'new URLSearchParams',\n  );\n}\n\nfunction serializeReference(\n  ctx: SerializerContext,\n  node: SerovalReferenceNode,\n): string {\n  return assignIndexedValue(ctx, node.i, REFERENCES_KEY + '.get(\"' + node.s + '\")');\n}\n\nfunction serializeDataView(\n  ctx: SerializerContext,\n  node: SerovalDataViewNode,\n): string {\n  return assignIndexedValue(\n    ctx,\n    node.i,\n    'new DataView(' + serializeTree(ctx, node.f) + ',' + node.b + ',' + node.l + ')',\n  );\n}\n\nfunction serializeBlob(\n  ctx: SerializerContext,\n  node: SerovalBlobNode,\n): string {\n  return assignIndexedValue(\n    ctx,\n    node.i,\n    'new Blob([' + serializeTree(ctx, node.f) + '],{type:\"' + node.c + '\"})',\n  );\n}\n\nfunction serializeFile(\n  ctx: SerializerContext,\n  node: SerovalFileNode,\n): string {\n  return assignIndexedValue(\n    ctx,\n    node.i,\n    'new File([' + serializeTree(ctx, node.f) + '],\"' + node.m + '\",{type:\"' + node.c + '\",lastModified:' + node.b + '})',\n  );\n}\n\nfunction serializeHeaders(\n  ctx: SerializerContext,\n  node: SerovalHeadersNode,\n): string {\n  return assignIndexedValue(\n    ctx,\n    node.i,\n    'new Headers(' + serializeProperties(ctx, node.i, node.e) + ')',\n  );\n}\n\nfunction serializeFormDataEntries(\n  ctx: SerializerContext,\n  node: SerovalFormDataNode,\n): string | undefined {\n  let value: string;\n  let key: string;\n  const keys = node.e.k;\n  const vals = node.e.v;\n  const id = node.i;\n  const mainAssignments: Assignment[] = [];\n  let parentAssignment: Assignment[];\n  ctx.stack.push(id);\n  for (let i = 0, len = node.e.s; i < len; i++) {\n    key = keys[i];\n    value = serializeTree(ctx, vals[i]);\n    parentAssignment = ctx.assignments;\n    ctx.assignments = mainAssignments;\n    createAppendAssignment(ctx, id, '\"' + key + '\"', value);\n    ctx.assignments = parentAssignment;\n  }\n  ctx.stack.pop();\n  return resolveAssignments(mainAssignments);\n}\n\nfunction serializeFormData(\n  ctx: SerializerContext,\n  node: SerovalFormDataNode,\n): string {\n  const size = node.e.s;\n  const id = node.i;\n  if (size) {\n    markRef(ctx, id);\n  }\n  const result = assignIndexedValue(ctx, id, 'new FormData()');\n  if (size) {\n    const entries = serializeFormDataEntries(ctx, node);\n    return '(' + result + ',' + (entries == null ? '' : entries) + getRefParam(ctx, id) + ')';\n  }\n  return result;\n}\n\nfunction serializeBoxed(\n  ctx: SerializerContext,\n  node: SerovalBoxedNode,\n): string {\n  return assignIndexedValue(ctx, node.i, 'Object(' + serializeTree(ctx, node.f) + ')');\n}\n\nfunction serializeWKSymbol(\n  ctx: SerializerContext,\n  node: SerovalWKSymbolNode,\n): string {\n  return assignIndexedValue(ctx, node.i, SYMBOL_STRING[node.s]);\n}\n\nexport default function serializeTree(\n  ctx: SerializerContext,\n  node: SerovalNode,\n): string {\n  switch (node.t) {\n    case SerovalNodeType.Number:\n      return '' + node.s;\n    case SerovalNodeType.String:\n      return '\"' + node.s + '\"';\n    case SerovalNodeType.Constant:\n      return serializeConstant(node);\n    case SerovalNodeType.BigInt:\n      return node.s + 'n';\n    case SerovalNodeType.IndexedValue:\n      return getRefParam(ctx, node.i);\n    case SerovalNodeType.Array:\n      return serializeArray(ctx, node);\n    case SerovalNodeType.Object:\n      return serializeObject(ctx, node);\n    case SerovalNodeType.NullConstructor:\n      return serializeNullConstructor(ctx, node);\n    case SerovalNodeType.Date:\n      return serializeDate(ctx, node);\n    case SerovalNodeType.RegExp:\n      return serializeRegExp(ctx, node);\n    case SerovalNodeType.Set:\n      return serializeSet(ctx, node);\n    case SerovalNodeType.Map:\n      return serializeMap(ctx, node);\n    case SerovalNodeType.ArrayBuffer:\n      return serializeArrayBuffer(ctx, node);\n    case SerovalNodeType.BigIntTypedArray:\n    case SerovalNodeType.TypedArray:\n      return serializeTypedArray(ctx, node);\n    case SerovalNodeType.DataView:\n      return serializeDataView(ctx, node);\n    case SerovalNodeType.AggregateError:\n      return serializeAggregateError(ctx, node);\n    case SerovalNodeType.Error:\n      return serializeError(ctx, node);\n    case SerovalNodeType.Promise:\n      return serializePromise(ctx, node);\n    case SerovalNodeType.WKSymbol:\n      return serializeWKSymbol(ctx, node);\n    case SerovalNodeType.URL:\n      return serializeURL(ctx, node);\n    case SerovalNodeType.URLSearchParams:\n      return serializeURLSearchParams(ctx, node);\n    case SerovalNodeType.Reference:\n      return serializeReference(ctx, node);\n    case SerovalNodeType.Blob:\n      return serializeBlob(ctx, node);\n    case SerovalNodeType.File:\n      return serializeFile(ctx, node);\n    case SerovalNodeType.Headers:\n      return serializeHeaders(ctx, node);\n    case SerovalNodeType.FormData:\n      return serializeFormData(ctx, node);\n    case SerovalNodeType.Boxed:\n      return serializeBoxed(ctx, node);\n    default:\n      throw new Error('invariant');\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport assert from '../assert';\nimport { Feature } from '../compat';\nimport type { ParserContext } from './context';\nimport { createIndexedValue } from './context';\nimport { serializeString } from '../string';\nimport type { BigIntTypedArrayValue, TypedArrayValue } from '../../types';\nimport UnsupportedTypeError from '../UnsupportedTypeError';\nimport {\n  TRUE_NODE,\n  FALSE_NODE,\n  UNDEFINED_NODE,\n  NULL_NODE,\n} from '../literals';\nimport {\n  createBigIntTypedArrayNode,\n  createTypedArrayNode,\n  createDataViewNode,\n  createSymbolNode,\n  createFunctionNode,\n} from './primitives';\nimport {\n  hasReferenceID,\n} from '../reference';\nimport {\n  getErrorConstructorName,\n  getErrorOptions,\n  getObjectFlag,\n  isIterable,\n} from '../shared';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalBoxedNode,\n  SerovalErrorNode,\n  SerovalFormDataNode,\n  SerovalHeadersNode,\n  SerovalMapNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPlainRecordNode,\n  SerovalSetNode,\n  SerovalSyncNode,\n} from '../types';\nimport {\n  SerovalObjectRecordSpecialKey,\n} from '../types';\nimport { SerovalNodeType } from '../constants';\nimport {\n  createArrayBufferNode,\n  createBigIntNode,\n  createDateNode,\n  createIndexedValueNode,\n  createNumberNode,\n  createReferenceNode,\n  createRegExpNode,\n  createStringNode,\n} from '../base-primitives';\nimport { createURLNode, createURLSearchParamsNode } from '../web-api';\n\ntype ObjectLikeNode = SerovalObjectNode | SerovalNullConstructorNode;\n\nfunction generateNodeList(ctx: ParserContext, current: unknown[]): SerovalSyncNode[] {\n  const size = current.length;\n  const nodes = new Array<SerovalSyncNode>(size);\n  const deferred = new Array<unknown>(size);\n  let item: unknown;\n  for (let i = 0; i < size; i++) {\n    if (i in current) {\n      item = current[i];\n      if (isIterable(item)) {\n        deferred[i] = item;\n      } else {\n        nodes[i] = parseSync(ctx, item);\n      }\n    }\n  }\n  for (let i = 0; i < size; i++) {\n    if (i in deferred) {\n      nodes[i] = parseSync(ctx, deferred[i]);\n    }\n  }\n  return nodes;\n}\n\nfunction generateArrayNode(\n  ctx: ParserContext,\n  id: number,\n  current: unknown[],\n): SerovalArrayNode {\n  return {\n    t: SerovalNodeType.Array,\n    i: id,\n    s: undefined,\n    l: current.length,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: generateNodeList(ctx, current),\n    f: undefined,\n    b: undefined,\n    o: getObjectFlag(current),\n  };\n}\n\nfunction generateMapNode(\n  ctx: ParserContext,\n  id: number,\n  current: Map<unknown, unknown>,\n): SerovalMapNode {\n  assert(ctx.features & Feature.Map, new UnsupportedTypeError(current));\n  const len = current.size;\n  const keyNodes = new Array<SerovalSyncNode>(len);\n  const valueNodes = new Array<SerovalSyncNode>(len);\n  const deferredKey = new Array<unknown>(len);\n  const deferredValue = new Array<unknown>(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const [key, value] of current.entries()) {\n    // Either key or value might be an iterable\n    if (isIterable(key) || isIterable(value)) {\n      deferredKey[deferredSize] = key;\n      deferredValue[deferredSize] = value;\n      deferredSize++;\n    } else {\n      keyNodes[nodeSize] = parseSync(ctx, key);\n      valueNodes[nodeSize] = parseSync(ctx, value);\n      nodeSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodeSize + i] = parseSync(ctx, deferredKey[i]);\n    valueNodes[nodeSize + i] = parseSync(ctx, deferredValue[i]);\n  }\n  return {\n    t: SerovalNodeType.Map,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: { k: keyNodes, v: valueNodes, s: len },\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateSetNode(\n  ctx: ParserContext,\n  id: number,\n  current: Set<unknown>,\n): SerovalSetNode {\n  assert(ctx.features & Feature.Set, new UnsupportedTypeError(current));\n  const len = current.size;\n  const nodes = new Array<SerovalSyncNode>(len);\n  const deferred = new Array<unknown>(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const item of current.keys()) {\n    // Iterables are lazy, so the evaluation must be deferred\n    if (isIterable(item)) {\n      deferred[deferredSize++] = item;\n    } else {\n      nodes[nodeSize++] = parseSync(ctx, item);\n    }\n  }\n  // Parse deferred items\n  for (let i = 0; i < deferredSize; i++) {\n    nodes[nodeSize + i] = parseSync(ctx, deferred[i]);\n  }\n  return {\n    t: SerovalNodeType.Set,\n    i: id,\n    s: undefined,\n    l: len,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: nodes,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateProperties(\n  ctx: ParserContext,\n  properties: Record<string, unknown>,\n): SerovalObjectRecordNode {\n  const keys = Object.keys(properties);\n  let size = keys.length;\n  const keyNodes = new Array<SerovalObjectRecordKey>(size);\n  const valueNodes = new Array<SerovalSyncNode>(size);\n  const deferredKeys = new Array<SerovalObjectRecordKey>(size);\n  const deferredValues = new Array<unknown>(size);\n  let deferredSize = 0;\n  let nodesSize = 0;\n  let item: unknown;\n  let escaped: SerovalObjectRecordKey;\n  for (const key of keys) {\n    item = properties[key];\n    escaped = serializeString(key);\n    if (isIterable(item)) {\n      deferredKeys[deferredSize] = escaped;\n      deferredValues[deferredSize] = item;\n      deferredSize++;\n    } else {\n      keyNodes[nodesSize] = escaped;\n      valueNodes[nodesSize] = parseSync(ctx, item);\n      nodesSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodesSize + i] = deferredKeys[i];\n    valueNodes[nodesSize + i] = parseSync(ctx, deferredValues[i]);\n  }\n  if (ctx.features & Feature.Symbol) {\n    if (Symbol.iterator in properties) {\n      keyNodes[size] = SerovalObjectRecordSpecialKey.SymbolIterator;\n      const items = Array.from(properties as Iterable<unknown>);\n      const id = createIndexedValue(ctx, items);\n      valueNodes[size] = generateArrayNode(ctx, id, items);\n      size++;\n    }\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: size,\n  };\n}\n\nfunction generatePlainProperties(\n  ctx: ParserContext,\n  properties: Record<string, unknown>,\n): SerovalPlainRecordNode {\n  const keys = Object.keys(properties);\n  const size = keys.length;\n  const keyNodes = new Array<string>(size);\n  const valueNodes = new Array<SerovalSyncNode>(size);\n  const deferredKeys = new Array<string>(size);\n  const deferredValues = new Array<unknown>(size);\n  let deferredSize = 0;\n  let nodesSize = 0;\n  let item: unknown;\n  let escaped: string;\n  for (const key of keys) {\n    item = properties[key];\n    escaped = serializeString(key);\n    if (isIterable(item)) {\n      deferredKeys[deferredSize] = escaped;\n      deferredValues[deferredSize] = item;\n      deferredSize++;\n    } else {\n      keyNodes[nodesSize] = escaped;\n      valueNodes[nodesSize] = parseSync(ctx, item);\n      nodesSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodesSize + i] = deferredKeys[i];\n    valueNodes[nodesSize + i] = parseSync(ctx, deferredValues[i]);\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: size,\n  };\n}\n\nfunction generateObjectNode(\n  ctx: ParserContext,\n  id: number,\n  current: Record<string, unknown>,\n  empty: boolean,\n): ObjectLikeNode {\n  return {\n    t: empty ? SerovalNodeType.NullConstructor : SerovalNodeType.Object,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: generateProperties(ctx, current),\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: getObjectFlag(current),\n  };\n}\n\nfunction generateAggregateErrorNode(\n  ctx: ParserContext,\n  id: number,\n  current: AggregateError,\n): SerovalAggregateErrorNode {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options\n    ? generateProperties(ctx, options)\n    : undefined;\n  return {\n    t: SerovalNodeType.AggregateError,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: serializeString(current.message),\n    p: optionsNode,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateErrorNode(\n  ctx: ParserContext,\n  id: number,\n  current: Error,\n): SerovalErrorNode {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options\n    ? generateProperties(ctx, options)\n    : undefined;\n  return {\n    t: SerovalNodeType.Error,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: getErrorConstructorName(current),\n    m: serializeString(current.message),\n    p: optionsNode,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateHeadersNode(\n  ctx: ParserContext,\n  id: number,\n  current: Headers,\n): SerovalHeadersNode {\n  assert(ctx.features & Feature.WebAPI, new UnsupportedTypeError(current));\n  const items: Record<string, string> = {};\n  // TS Headers not an Iterable\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: SerovalNodeType.Headers,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: generatePlainProperties(ctx, items),\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateFormDataNode(\n  ctx: ParserContext,\n  id: number,\n  current: FormData,\n): SerovalFormDataNode {\n  assert(ctx.features & Feature.WebAPI, new UnsupportedTypeError(current));\n  const items: Record<string, FormDataEntryValue> = {};\n  // TS FormData isn't an Iterable sadly\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: SerovalNodeType.FormData,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: generatePlainProperties(ctx, items),\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateBoxedNode(\n  ctx: ParserContext,\n  id: number,\n  current: object,\n): SerovalBoxedNode {\n  return {\n    t: SerovalNodeType.Boxed,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: parseSync(ctx, current.valueOf()),\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction parseObject(\n  ctx: ParserContext,\n  current: object | null,\n): SerovalSyncNode {\n  if (!current) {\n    return NULL_NODE;\n  }\n  // Non-primitive values needs a reference ID\n  // mostly because the values themselves are stateful\n  const id = createIndexedValue(ctx, current);\n  if (ctx.reference.marked.has(id)) {\n    return createIndexedValueNode(id);\n  }\n  if (hasReferenceID(current)) {\n    return createReferenceNode(id, current);\n  }\n  // Well well well\n  if (Array.isArray(current)) {\n    return generateArrayNode(ctx, id, current);\n  }\n  // Fast path\n  switch (current.constructor) {\n    case Number:\n    case Boolean:\n    case String:\n    case BigInt:\n    case Function:\n    case Symbol:\n      return generateBoxedNode(ctx, id, current);\n    case Date:\n      return createDateNode(id, current as unknown as Date);\n    case RegExp:\n      return createRegExpNode(id, current as unknown as RegExp);\n    case ArrayBuffer:\n      return createArrayBufferNode(id, current as unknown as ArrayBuffer);\n    case Int8Array:\n    case Int16Array:\n    case Int32Array:\n    case Uint8Array:\n    case Uint16Array:\n    case Uint32Array:\n    case Uint8ClampedArray:\n    case Float32Array:\n    case Float64Array:\n      return createTypedArrayNode(ctx, id, current as unknown as TypedArrayValue);\n    case BigInt64Array:\n    case BigUint64Array:\n      return createBigIntTypedArrayNode(ctx, id, current as unknown as BigIntTypedArrayValue);\n    case DataView:\n      return createDataViewNode(ctx, id, current as unknown as DataView);\n    case Map:\n      return generateMapNode(ctx, id, current as unknown as Map<unknown, unknown>);\n    case Set:\n      return generateSetNode(ctx, id, current as unknown as Set<unknown>);\n    case Object:\n      return generateObjectNode(\n        ctx,\n        id,\n        current as unknown as Record<string, unknown>,\n        false,\n      );\n    case undefined:\n      return generateObjectNode(\n        ctx,\n        id,\n        current as unknown as Record<string, unknown>,\n        true,\n      );\n    case AggregateError:\n      // Compile-down AggregateError to Error if disabled\n      if (ctx.features & Feature.AggregateError) {\n        return generateAggregateErrorNode(ctx, id, current as unknown as AggregateError);\n      }\n      return generateErrorNode(ctx, id, current as unknown as AggregateError);\n    case Error:\n    case EvalError:\n    case RangeError:\n    case ReferenceError:\n    case SyntaxError:\n    case TypeError:\n    case URIError:\n      return generateErrorNode(ctx, id, current as unknown as Error);\n    case URL:\n      return createURLNode(ctx, id, current as unknown as URL);\n    case URLSearchParams:\n      return createURLSearchParamsNode(ctx, id, current as unknown as URLSearchParams);\n    case Headers:\n      return generateHeadersNode(ctx, id, current as unknown as Headers);\n    case FormData:\n      return generateFormDataNode(ctx, id, current as unknown as FormData);\n    default:\n      break;\n  }\n  // Slow path. We only need to handle Errors and Iterators\n  // since they have very broad implementations.\n  if (current instanceof AggregateError) {\n    if (ctx.features & Feature.AggregateError) {\n      return generateAggregateErrorNode(ctx, id, current);\n    }\n    return generateErrorNode(ctx, id, current);\n  }\n  if (current instanceof Error) {\n    return generateErrorNode(ctx, id, current);\n  }\n  // Generator functions don't have a global constructor\n  // despite existing\n  if (Symbol.iterator in current) {\n    return generateObjectNode(ctx, id, current, !!current.constructor);\n  }\n  throw new UnsupportedTypeError(current);\n}\n\nexport default function parseSync<T>(\n  ctx: ParserContext,\n  current: T,\n): SerovalSyncNode {\n  switch (typeof current) {\n    case 'boolean':\n      return current ? TRUE_NODE : FALSE_NODE;\n    case 'undefined':\n      return UNDEFINED_NODE;\n    case 'string':\n      return createStringNode(current);\n    case 'number':\n      return createNumberNode(current);\n    case 'bigint':\n      return createBigIntNode(ctx, current);\n    case 'object':\n      return parseObject(ctx, current);\n    case 'symbol':\n      return createSymbolNode(ctx, current);\n    case 'function':\n      return createFunctionNode(ctx, current);\n    default:\n      throw new UnsupportedTypeError(current);\n  }\n}\n", "import { Feature } from '../compat';\nimport { SerovalNodeType } from '../constants';\nimport type { SerovalNode } from '../types';\nimport parseAsync from './async';\nimport type {\n  ParserOptions,\n  SerializerContext,\n} from './context';\nimport {\n  createDeserializerContext,\n  createParserContext,\n  createSerializerContext,\n  getRefParam,\n} from './context';\nimport deserializeTree from './deserialize';\nimport serializeTree, { resolvePatches } from './serialize';\nimport parseSync from './sync';\n\nfunction finalize(\n  ctx: SerializerContext,\n  rootID: number | undefined,\n  isObject: boolean,\n  result: string,\n): string {\n  // Shared references detected\n  if (rootID != null && ctx.vars.length) {\n    const patches = resolvePatches(ctx);\n    let body = result;\n    if (patches) {\n      // Get (or create) a ref from the source\n      const index = getRefParam(ctx, rootID);\n      body = result + ',' + patches + index;\n      if (!result.startsWith(index + '=')) {\n        body = index + '=' + body;\n      }\n    }\n    let params = ctx.vars.length > 1\n      ? ctx.vars.join(',')\n      : ctx.vars[0];\n    // Source is probably already assigned\n    if (ctx.features & Feature.ArrowFunction) {\n      params = ctx.vars.length > 1 || ctx.vars.length === 0\n        ? '(' + params + ')'\n        : params;\n      return '(' + params + '=>(' + body + '))()';\n    }\n    return '(function(' + params + '){return ' + body + '})()';\n  }\n  if (isObject) {\n    return '(' + result + ')';\n  }\n  return result;\n}\n\nexport function serialize<T>(\n  source: T,\n  options?: Partial<ParserOptions>,\n): string {\n  const ctx = createParserContext(options);\n  const tree = parseSync(ctx, source);\n  const serial = createSerializerContext({\n    markedRefs: ctx.reference.marked,\n    features: ctx.features,\n  });\n  const result = serializeTree(serial, tree);\n  return finalize(\n    serial,\n    tree.i,\n    tree.t === SerovalNodeType.Object,\n    result,\n  );\n}\n\nexport async function serializeAsync<T>(\n  source: T,\n  options?: Partial<ParserOptions>,\n): Promise<string> {\n  const ctx = createParserContext(options);\n  const tree = await parseAsync(ctx, source);\n  const serial = createSerializerContext({\n    markedRefs: ctx.reference.marked,\n    features: ctx.features,\n  });\n  const result = serializeTree(serial, tree);\n  return finalize(\n    serial,\n    tree.i,\n    tree.t === SerovalNodeType.Object,\n    result,\n  );\n}\n\nexport function deserialize<T>(source: string): T {\n  // eslint-disable-next-line no-eval\n  return (0, eval)(source) as T;\n}\n\nexport interface SerovalJSON {\n  t: SerovalNode;\n  f: number;\n  m: number[];\n}\n\nexport function toJSON<T>(\n  source: T,\n  options?: Partial<ParserOptions>,\n): SerovalJSON {\n  const ctx = createParserContext(options);\n  return {\n    t: parseSync(ctx, source),\n    f: ctx.features,\n    m: Array.from(ctx.reference.marked),\n  };\n}\n\nexport async function toJSONAsync<T>(\n  source: T,\n  options?: Partial<ParserOptions>,\n): Promise<SerovalJSON> {\n  const ctx = createParserContext(options);\n  return {\n    t: await parseAsync(ctx, source),\n    f: ctx.features,\n    m: Array.from(ctx.reference.marked),\n  };\n}\n\nexport function compileJSON(source: SerovalJSON): string {\n  const serial = createSerializerContext({\n    features: source.f,\n    markedRefs: source.m,\n  });\n  const result = serializeTree(serial, source.t);\n  return finalize(serial, source.t.i, source.t.i === SerovalNodeType.Object, result);\n}\n\nexport function fromJSON<T>(source: SerovalJSON): T {\n  const serial = createDeserializerContext({\n    markedRefs: source.m,\n  });\n  return deserializeTree(serial, source.t) as T;\n}\n", "import type { Assignment, FlaggedObject } from '../assignments';\nimport { ALL_ENABLED } from '../compat';\nimport type { BaseParserContext } from '../context';\nimport type { SerovalNode } from '../types';\n\nexport interface CrossParserContextOptions {\n  scopeId?: string;\n  refs?: Map<unknown, number>;\n  disabledFeatures?: number;\n}\n\nexport interface CrossParserContext {\n  scopeId?: string;\n  refs: Map<unknown, number>;\n  features: number;\n}\n\nexport function createCrossParserContext(\n  options: CrossParserContextOptions = {},\n): CrossParserContext {\n  return {\n    scopeId: options.scopeId,\n    refs: options.refs || new Map<unknown, number>(),\n    features: ALL_ENABLED ^ (options.disabledFeatures || 0),\n  };\n}\n\nexport function createCrossIndexedValue<T>(\n  ctx: CrossParserContext,\n  current: T,\n): number {\n  const ref = ctx.refs.get(current);\n  if (ref == null) {\n    const id = ctx.refs.size;\n    ctx.refs.set(current, id);\n    return id;\n  }\n  return ref;\n}\n\nexport interface StreamingCrossParserContextOptions extends CrossParserContextOptions {\n  onParse: (node: SerovalNode, initial: boolean) => void;\n  onDone?: () => void;\n}\n\nexport interface StreamingCrossParserContext extends CrossParserContext {\n  alive: boolean;\n  pending: number;\n  onParse(node: SerovalNode, initial: boolean): void;\n  onDone(): void;\n}\n\nexport function createStreamingCrossParserContext(\n  options: StreamingCrossParserContextOptions,\n): StreamingCrossParserContext {\n  return {\n    alive: true,\n    pending: 0,\n    refs: options.refs || new Map<unknown, number>(),\n    features: ALL_ENABLED ^ (options.disabledFeatures || 0),\n    onParse: options.onParse,\n    onDone(): void {\n      if (options.onDone) {\n        options.onDone();\n      }\n    },\n    scopeId: options.scopeId,\n  };\n}\n\nexport function pushPendingState(ctx: StreamingCrossParserContext): void {\n  ctx.pending++;\n}\n\nexport function popPendingState(ctx: StreamingCrossParserContext): void {\n  if (--ctx.pending <= 0) {\n    ctx.onDone();\n  }\n}\n\nexport interface CrossSerializerContext extends BaseParserContext {\n  stack: number[];\n  // Array of assignments to be done (used for recursion)\n  assignments: Assignment[];\n  // Object flags\n  flags: FlaggedObject[];\n}\n\nexport interface CrossSerializerOptions {\n  features: number;\n}\n\nexport function createCrossSerializerContext(\n  options: CrossSerializerOptions,\n): CrossSerializerContext {\n  return {\n    stack: [],\n    assignments: [],\n    features: options.features,\n    flags: [],\n  };\n}\n", "import assert from '../assert';\nimport { Feature } from '../compat';\nimport type { CrossParserContext } from './context';\nimport type { BigIntTypedArrayValue, TypedArrayValue } from '../../types';\nimport UnsupportedTypeError from '../UnsupportedTypeError';\nimport { hasReferenceID } from '../reference';\nimport type {\n  SerovalBigIntTypedArrayNode,\n  SerovalTypedArrayNode,\n  SerovalDataViewNode,\n  SerovalNode,\n  SerovalIndexedValueNode,\n  SerovalReferenceNode,\n  SerovalWKSymbolNode,\n} from '../types';\nimport type { WellKnownSymbols } from '../constants';\nimport { SerovalNodeType } from '../constants';\nimport {\n  createIndexedValueNode,\n  createArrayBufferNode,\n  createWKSymbolNode,\n  createReferenceNode,\n} from '../base-primitives';\n\nexport function serializeArrayBuffer(\n  ctx: CrossParserContext,\n  current: ArrayBuffer,\n): SerovalNode {\n  const id = ctx.refs.get(current);\n  if (id != null) {\n    return createIndexedValueNode(id);\n  }\n  const newID = ctx.refs.size;\n  ctx.refs.set(current, newID);\n  return createArrayBufferNode(newID, current);\n}\n\nexport function createTypedArrayNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: TypedArrayValue,\n): SerovalTypedArrayNode {\n  assert(ctx.features & Feature.TypedArray, new UnsupportedTypeError(current));\n  return {\n    t: SerovalNodeType.TypedArray,\n    i: id,\n    s: undefined,\n    l: current.length,\n    c: current.constructor.name,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: serializeArrayBuffer(ctx, current.buffer),\n    b: current.byteOffset,\n    o: undefined,\n  };\n}\n\nconst BIGINT_FLAG = Feature.BigIntTypedArray | Feature.BigInt;\n\nexport function createBigIntTypedArrayNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: BigIntTypedArrayValue,\n): SerovalBigIntTypedArrayNode {\n  assert(\n    (ctx.features & BIGINT_FLAG) === BIGINT_FLAG,\n    new UnsupportedTypeError(current),\n  );\n  return {\n    t: SerovalNodeType.BigIntTypedArray,\n    i: id,\n    s: undefined,\n    l: current.length,\n    c: current.constructor.name,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: serializeArrayBuffer(ctx, current.buffer),\n    b: current.byteOffset,\n    o: undefined,\n  };\n}\n\nexport function createDataViewNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: DataView,\n): SerovalDataViewNode {\n  return {\n    t: SerovalNodeType.DataView,\n    i: id,\n    s: undefined,\n    l: current.byteLength,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: serializeArrayBuffer(ctx, current.buffer),\n    b: current.byteOffset,\n    o: undefined,\n  };\n}\n\nexport function createSymbolNode(\n  ctx: CrossParserContext,\n  current: symbol,\n): SerovalIndexedValueNode | SerovalReferenceNode | SerovalWKSymbolNode {\n  const id = ctx.refs.get(current);\n  if (id != null) {\n    return createIndexedValueNode(id);\n  }\n  const newID = ctx.refs.size;\n  ctx.refs.set(current, newID);\n  if (hasReferenceID(current)) {\n    return createReferenceNode(newID, current);\n  }\n  return createWKSymbolNode(ctx, newID, current as WellKnownSymbols);\n}\n\nexport function createFunctionNode(\n  ctx: CrossParserContext,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  current: Function,\n): SerovalIndexedValueNode | SerovalReferenceNode {\n  assert(hasReferenceID(current), new Error('Cannot serialize function without reference ID.'));\n  const id = ctx.refs.get(current);\n  if (id != null) {\n    return createIndexedValueNode(id);\n  }\n  const newID = ctx.refs.size;\n  ctx.refs.set(current, newID);\n  return createReferenceNode(newID, current);\n}\n", "import assert from '../assert';\nimport { Feature } from '../compat';\nimport type { CrossParserContext } from './context';\nimport { serializeString } from '../string';\nimport UnsupportedTypeError from '../UnsupportedTypeError';\nimport { serializeArrayBuffer } from './primitives';\nimport type {\n  SerovalBlobNode,\n  SerovalFileNode,\n} from '../types';\nimport { SerovalNodeType } from '../constants';\n\nexport async function createBlobNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: Blob,\n): Promise<SerovalBlobNode> {\n  assert(ctx.features & Feature.WebAPI, new UnsupportedTypeError(current));\n  return {\n    t: SerovalNodeType.Blob,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: serializeString(current.type),\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    f: serializeArrayBuffer(ctx, await current.arrayBuffer()),\n    a: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nexport async function createFileNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: File,\n): Promise<SerovalFileNode> {\n  assert(ctx.features & Feature.WebAPI, new UnsupportedTypeError(current));\n  return {\n    t: SerovalNodeType.File,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: serializeString(current.type),\n    m: serializeString(current.name),\n    p: undefined,\n    e: undefined,\n    f: serializeArrayBuffer(ctx, await current.arrayBuffer()),\n    a: undefined,\n    b: current.lastModified,\n    o: undefined,\n  };\n}\n", "/* eslint-disable no-await-in-loop */\n/* eslint-disable @typescript-eslint/no-use-before-define */\nimport assert from '../assert';\nimport { Feature } from '../compat';\nimport type { CrossParserContext } from './context';\nimport {\n  createCrossIndexedValue,\n} from './context';\nimport { serializeString } from '../string';\nimport type {\n  BigIntTypedArrayValue,\n  TypedArrayValue,\n} from '../../types';\nimport UnsupportedTypeError from '../UnsupportedTypeError';\nimport {\n  TRUE_NODE,\n  FALSE_NODE,\n  UNDEFINED_NODE,\n  NULL_NODE,\n} from '../literals';\nimport {\n  createBigIntTypedArrayNode,\n  createTypedArrayNode,\n  createDataViewNode,\n  createSymbolNode,\n  createFunctionNode,\n} from './primitives';\nimport { hasReferenceID } from '../reference';\nimport {\n  getErrorConstructorName,\n  getErrorOptions,\n  getObjectFlag,\n  isIterable,\n} from '../shared';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalBoxedNode,\n  SerovalErrorNode,\n  SerovalFormDataNode,\n  SerovalHeadersNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPlainRecordNode,\n  SerovalPromiseNode,\n  SerovalSetNode,\n} from '../types';\nimport {\n  SerovalObjectRecordSpecialKey,\n} from '../types';\nimport {\n  createBlobNode,\n  createFileNode,\n} from './web-api';\nimport { SerovalNodeType } from '../constants';\nimport {\n  createArrayBufferNode,\n  createBigIntNode,\n  createDateNode,\n  createIndexedValueNode,\n  createNumberNode,\n  createReferenceNode,\n  createRegExpNode,\n  createStringNode,\n} from '../base-primitives';\nimport { createURLNode, createURLSearchParamsNode } from '../web-api';\nimport promiseToResult from '../promise-to-result';\n\ntype ObjectLikeNode =\n  | SerovalObjectNode\n  | SerovalNullConstructorNode\n  | SerovalPromiseNode;\n\nasync function generateNodeList(\n  ctx: CrossParserContext,\n  current: unknown[],\n): Promise<SerovalNode[]> {\n  const size = current.length;\n  const nodes = new Array<SerovalNode>(size);\n  const deferred = new Array<unknown>(size);\n  let item: unknown;\n  for (let i = 0; i < size; i++) {\n    if (i in current) {\n      item = current[i];\n      if (isIterable(item)) {\n        deferred[i] = item;\n      } else {\n        nodes[i] = await crossParseAsync(ctx, item);\n      }\n    }\n  }\n  for (let i = 0; i < size; i++) {\n    if (i in deferred) {\n      nodes[i] = await crossParseAsync(ctx, deferred[i]);\n    }\n  }\n  return nodes;\n}\n\nasync function generateArrayNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: unknown[],\n): Promise<SerovalArrayNode> {\n  return {\n    t: SerovalNodeType.Array,\n    i: id,\n    s: undefined,\n    l: current.length,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: await generateNodeList(ctx, current),\n    f: undefined,\n    b: undefined,\n    o: getObjectFlag(current),\n  };\n}\n\nasync function generateMapNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: Map<unknown, unknown>,\n): Promise<SerovalMapNode> {\n  assert(ctx.features & Feature.Map, new UnsupportedTypeError(current));\n  const len = current.size;\n  const keyNodes = new Array<SerovalNode>(len);\n  const valueNodes = new Array<SerovalNode>(len);\n  const deferredKey = new Array<unknown>(len);\n  const deferredValue = new Array<unknown>(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const [key, value] of current.entries()) {\n    // Either key or value might be an iterable\n    if (isIterable(key) || isIterable(value)) {\n      deferredKey[deferredSize] = key;\n      deferredValue[deferredSize] = value;\n      deferredSize++;\n    } else {\n      keyNodes[nodeSize] = await crossParseAsync(ctx, key);\n      valueNodes[nodeSize] = await crossParseAsync(ctx, value);\n      nodeSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodeSize + i] = await crossParseAsync(ctx, deferredKey[i]);\n    valueNodes[nodeSize + i] = await crossParseAsync(ctx, deferredValue[i]);\n  }\n  return {\n    t: SerovalNodeType.Map,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: { k: keyNodes, v: valueNodes, s: len },\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nasync function generateSetNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: Set<unknown>,\n): Promise<SerovalSetNode> {\n  assert(ctx.features & Feature.Set, new UnsupportedTypeError(current));\n  const len = current.size;\n  const nodes = new Array<SerovalNode>(len);\n  const deferred = new Array<unknown>(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const item of current.keys()) {\n    // Iterables are lazy, so the evaluation must be deferred\n    if (isIterable(item)) {\n      deferred[deferredSize++] = item;\n    } else {\n      nodes[nodeSize++] = await crossParseAsync(ctx, item);\n    }\n  }\n  // Parse deferred items\n  for (let i = 0; i < deferredSize; i++) {\n    nodes[nodeSize + i] = await crossParseAsync(ctx, deferred[i]);\n  }\n  return {\n    t: SerovalNodeType.Set,\n    i: id,\n    s: undefined,\n    l: len,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: nodes,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nasync function generateProperties(\n  ctx: CrossParserContext,\n  properties: Record<string, unknown>,\n): Promise<SerovalObjectRecordNode> {\n  const keys = Object.keys(properties);\n  let size = keys.length;\n  const keyNodes = new Array<SerovalObjectRecordKey>(size);\n  const valueNodes = new Array<SerovalNode>(size);\n  const deferredKeys = new Array<SerovalObjectRecordKey>(size);\n  const deferredValues = new Array<unknown>(size);\n  let deferredSize = 0;\n  let nodesSize = 0;\n  let item: unknown;\n  let escaped: SerovalObjectRecordKey;\n  for (const key of keys) {\n    item = properties[key];\n    escaped = serializeString(key);\n    if (isIterable(item)) {\n      deferredKeys[deferredSize] = escaped;\n      deferredValues[deferredSize] = item;\n      deferredSize++;\n    } else {\n      keyNodes[nodesSize] = escaped;\n      valueNodes[nodesSize] = await crossParseAsync(ctx, item);\n      nodesSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodesSize + i] = deferredKeys[i];\n    valueNodes[nodesSize + i] = await crossParseAsync(ctx, deferredValues[i]);\n  }\n  if (ctx.features & Feature.Symbol) {\n    if (Symbol.iterator in properties) {\n      keyNodes[size] = SerovalObjectRecordSpecialKey.SymbolIterator;\n      const items = Array.from(properties as Iterable<unknown>);\n      valueNodes[size] = await generateArrayNode(\n        ctx,\n        createCrossIndexedValue(ctx, items),\n        items,\n      );\n      size++;\n    }\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: size,\n  };\n}\n\nasync function generatePlainProperties(\n  ctx: CrossParserContext,\n  properties: Record<string, unknown>,\n): Promise<SerovalPlainRecordNode> {\n  const keys = Object.keys(properties);\n  const size = keys.length;\n  const keyNodes = new Array<string>(size);\n  const valueNodes = new Array<SerovalNode>(size);\n  const deferredKeys = new Array<string>(size);\n  const deferredValues = new Array<unknown>(size);\n  let deferredSize = 0;\n  let nodesSize = 0;\n  let item: unknown;\n  let escaped: string;\n  for (const key of keys) {\n    item = properties[key];\n    escaped = serializeString(key);\n    if (isIterable(item)) {\n      deferredKeys[deferredSize] = escaped;\n      deferredValues[deferredSize] = item;\n      deferredSize++;\n    } else {\n      keyNodes[nodesSize] = escaped;\n      valueNodes[nodesSize] = await crossParseAsync(ctx, item);\n      nodesSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodesSize + i] = deferredKeys[i];\n    valueNodes[nodesSize + i] = await crossParseAsync(ctx, deferredValues[i]);\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: size,\n  };\n}\n\nasync function generatePromiseNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: Promise<unknown>,\n): Promise<SerovalPromiseNode> {\n  assert(ctx.features & Feature.Promise, new UnsupportedTypeError(current));\n  const [status, result] = await promiseToResult(current);\n  return {\n    t: SerovalNodeType.Promise,\n    i: id,\n    s: status,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: await crossParseAsync(ctx, result),\n    b: undefined,\n    o: undefined,\n  };\n}\n\nasync function generateObjectNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: Record<string, unknown>,\n  empty: boolean,\n): Promise<ObjectLikeNode> {\n  return {\n    t: empty ? SerovalNodeType.NullConstructor : SerovalNodeType.Object,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: await generateProperties(ctx, current),\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: getObjectFlag(current),\n  };\n}\n\nasync function generateAggregateErrorNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: AggregateError,\n): Promise<SerovalAggregateErrorNode> {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options\n    ? await generateProperties(ctx, options)\n    : undefined;\n  return {\n    t: SerovalNodeType.AggregateError,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: serializeString(current.message),\n    p: optionsNode,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nasync function generateErrorNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: Error,\n): Promise<SerovalErrorNode> {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options\n    ? await generateProperties(ctx, options)\n    : undefined;\n  return {\n    t: SerovalNodeType.Error,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: getErrorConstructorName(current),\n    m: serializeString(current.message),\n    p: optionsNode,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nasync function generateHeadersNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: Headers,\n): Promise<SerovalHeadersNode> {\n  assert(ctx.features & Feature.WebAPI, new UnsupportedTypeError(current));\n  const items: Record<string, string> = {};\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: SerovalNodeType.Headers,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: await generatePlainProperties(ctx, items),\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nasync function generateFormDataNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: FormData,\n): Promise<SerovalFormDataNode> {\n  assert(ctx.features & Feature.WebAPI, new UnsupportedTypeError(current));\n  const items: Record<string, FormDataEntryValue> = {};\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: SerovalNodeType.FormData,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: await generatePlainProperties(ctx, items),\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nasync function generateBoxedNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: object,\n): Promise<SerovalBoxedNode> {\n  return {\n    t: SerovalNodeType.Boxed,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: await crossParseAsync(ctx, current.valueOf()),\n    b: undefined,\n    o: undefined,\n  };\n}\n\nasync function parseObject(\n  ctx: CrossParserContext,\n  current: object | null,\n): Promise<SerovalNode> {\n  if (!current) {\n    return NULL_NODE;\n  }\n  // Non-primitive values needs a reference ID\n  // mostly because the values themselves are stateful\n  const registeredID = ctx.refs.get(current);\n  if (registeredID != null) {\n    return createIndexedValueNode(registeredID);\n  }\n  const id = ctx.refs.size;\n  ctx.refs.set(current, id);\n  if (hasReferenceID(current)) {\n    return createReferenceNode(id, current);\n  }\n  if (Array.isArray(current)) {\n    return generateArrayNode(ctx, id, current);\n  }\n  switch (current.constructor) {\n    case Number:\n    case Boolean:\n    case String:\n    case BigInt:\n    case Function:\n    case Symbol:\n      return generateBoxedNode(ctx, id, current);\n    case Date:\n      return createDateNode(id, current as unknown as Date);\n    case RegExp:\n      return createRegExpNode(id, current as unknown as RegExp);\n    case Promise:\n      return generatePromiseNode(ctx, id, current as unknown as Promise<unknown>);\n    case ArrayBuffer:\n      return createArrayBufferNode(id, current as unknown as ArrayBuffer);\n    case Int8Array:\n    case Int16Array:\n    case Int32Array:\n    case Uint8Array:\n    case Uint16Array:\n    case Uint32Array:\n    case Uint8ClampedArray:\n    case Float32Array:\n    case Float64Array:\n      return createTypedArrayNode(ctx, id, current as unknown as TypedArrayValue);\n    case BigInt64Array:\n    case BigUint64Array:\n      return createBigIntTypedArrayNode(ctx, id, current as unknown as BigIntTypedArrayValue);\n    case DataView:\n      return createDataViewNode(ctx, id, current as unknown as DataView);\n    case Map:\n      return generateMapNode(\n        ctx,\n        id,\n        current as unknown as Map<unknown, unknown>,\n      );\n    case Set:\n      return generateSetNode(\n        ctx,\n        id,\n        current as unknown as Set<unknown>,\n      );\n    case Object:\n      return generateObjectNode(\n        ctx,\n        id,\n        current as Record<string, unknown>,\n        false,\n      );\n    case undefined:\n      return generateObjectNode(\n        ctx,\n        id,\n        current as Record<string, unknown>,\n        true,\n      );\n    case AggregateError:\n      if (ctx.features & Feature.AggregateError) {\n        return generateAggregateErrorNode(ctx, id, current as unknown as AggregateError);\n      }\n      return generateErrorNode(ctx, id, current as unknown as AggregateError);\n    case Error:\n    case EvalError:\n    case RangeError:\n    case ReferenceError:\n    case SyntaxError:\n    case TypeError:\n    case URIError:\n      return generateErrorNode(ctx, id, current as unknown as Error);\n    case URL:\n      return createURLNode(ctx, id, current as unknown as URL);\n    case URLSearchParams:\n      return createURLSearchParamsNode(ctx, id, current as unknown as URLSearchParams);\n    case Blob:\n      return createBlobNode(ctx, id, current as unknown as Blob);\n    case File:\n      return createFileNode(ctx, id, current as unknown as File);\n    case Headers:\n      return generateHeadersNode(ctx, id, current as unknown as Headers);\n    case FormData:\n      return generateFormDataNode(ctx, id, current as unknown as FormData);\n    default:\n      break;\n  }\n  if (current instanceof AggregateError) {\n    if (ctx.features & Feature.AggregateError) {\n      return generateAggregateErrorNode(ctx, id, current);\n    }\n    return generateErrorNode(ctx, id, current);\n  }\n  if (current instanceof Error) {\n    return generateErrorNode(ctx, id, current);\n  }\n  if (current instanceof Promise) {\n    return generatePromiseNode(ctx, id, current);\n  }\n  // Generator functions don't have a global constructor\n  if (Symbol.iterator in current) {\n    return generateObjectNode(ctx, id, current, !!current.constructor);\n  }\n  throw new UnsupportedTypeError(current);\n}\n\nexport default async function crossParseAsync<T>(\n  ctx: CrossParserContext,\n  current: T,\n): Promise<SerovalNode> {\n  switch (typeof current) {\n    case 'boolean':\n      return current ? TRUE_NODE : FALSE_NODE;\n    case 'undefined':\n      return UNDEFINED_NODE;\n    case 'string':\n      return createStringNode(current);\n    case 'number':\n      return createNumberNode(current);\n    case 'bigint':\n      return createBigIntNode(ctx, current);\n    case 'object':\n      return parseObject(ctx, current);\n    case 'symbol':\n      return createSymbolNode(ctx, current);\n    case 'function':\n      return createFunctionNode(ctx, current);\n    default:\n      throw new UnsupportedTypeError(current);\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { Feature } from '../compat';\nimport type {\n  CrossSerializerContext,\n} from './context';\nimport { isValidIdentifier } from '../shared';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalErrorNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalPromiseNode,\n  SerovalIndexedValueNode,\n  SerovalSetNode,\n  SerovalTypedArrayNode,\n  SerovalArrayBufferNode,\n  SerovalDataViewNode,\n  SerovalBlobNode,\n  SerovalFileNode,\n  SerovalHeadersNode,\n  SerovalRegExpNode,\n  SerovalDateNode,\n  SerovalURLNode,\n  SerovalURLSearchParamsNode,\n  SerovalReferenceNode,\n  SerovalFormDataNode,\n  SerovalObjectRecordNode,\n  SerovalObjectRecordKey,\n  SerovalBoxedNode,\n  SerovalWKSymbolNode,\n  SerovalPromiseConstructorNode,\n  SerovalPromiseResolveNode,\n  SerovalPromiseRejectNode,\n  SerovalReadableStreamCloseNode,\n  SerovalReadableStreamEnqueueNode,\n  SerovalReadableStreamErrorNode,\n  SerovalReadableStreamConstructorNode,\n} from '../types';\nimport {\n  SerovalObjectRecordSpecialKey,\n} from '../types';\nimport {\n  SerovalObjectFlags,\n  SerovalNodeType,\n  SYMBOL_STRING,\n  serializeConstant,\n} from '../constants';\nimport type { Assignment } from '../assignments';\nimport { resolveAssignments, resolveFlags } from '../assignments';\nimport {\n  GLOBAL_CONTEXT_PROMISE_REJECT,\n  GLOBAL_CONTEXT_PROMISE_RESOLVE,\n  GLOBAL_CONTEXT_PROMISE_CONSTRUCTOR,\n  GLOBAL_CONTEXT_REFERENCES,\n  REFERENCES_KEY,\n  GLOBAL_CONTEXT_STREAM_CONSTRUCTOR,\n  GLOBAL_CONTEXT_STREAM_EMIT,\n  GLOBAL_CONTEXT_API,\n} from '../keys';\n\nexport function getRefExpr(id: number): string {\n  return GLOBAL_CONTEXT_REFERENCES + '[' + id + ']';\n}\n\nfunction pushObjectFlag(\n  ctx: CrossSerializerContext,\n  flag: SerovalObjectFlags,\n  id: number,\n): void {\n  if (flag !== SerovalObjectFlags.None) {\n    ctx.flags.push({\n      type: flag,\n      value: getRefExpr(id),\n    });\n  }\n}\n\nexport function resolvePatches(ctx: CrossSerializerContext): string | undefined {\n  const assignments = resolveAssignments(ctx.assignments);\n  const flags = resolveFlags(ctx.flags);\n  if (assignments) {\n    if (flags) {\n      return assignments + flags;\n    }\n    return assignments;\n  }\n  return flags;\n}\n\n/**\n * Generates the inlined assignment for the reference\n * This is different from the assignments array as this one\n * signifies creation rather than mutation\n */\n\nfunction createAssignment(\n  ctx: CrossSerializerContext,\n  source: string,\n  value: string,\n): void {\n  ctx.assignments.push({\n    t: 'index',\n    s: source,\n    k: undefined,\n    v: value,\n  });\n}\n\nfunction createAddAssignment(\n  ctx: CrossSerializerContext,\n  ref: number,\n  value: string,\n): void {\n  ctx.assignments.push({\n    t: 'add',\n    s: getRefExpr(ref),\n    k: undefined,\n    v: value,\n  });\n}\n\nfunction createSetAssignment(\n  ctx: CrossSerializerContext,\n  ref: number,\n  key: string,\n  value: string,\n): void {\n  ctx.assignments.push({\n    t: 'set',\n    s: getRefExpr(ref),\n    k: key,\n    v: value,\n  });\n}\n\nfunction createAppendAssignment(\n  ctx: CrossSerializerContext,\n  ref: number,\n  key: string,\n  value: string,\n): void {\n  ctx.assignments.push({\n    t: 'append',\n    s: getRefExpr(ref),\n    k: key,\n    v: value,\n  });\n}\n\nfunction createArrayAssign(\n  ctx: CrossSerializerContext,\n  ref: number,\n  index: number | string,\n  value: string,\n): void {\n  createAssignment(ctx, getRefExpr(ref) + '[' + index + ']', value);\n}\n\nfunction createObjectAssign(\n  ctx: CrossSerializerContext,\n  ref: number,\n  key: string,\n  value: string,\n): void {\n  createAssignment(ctx, getRefExpr(ref) + '.' + key, value);\n}\n\nfunction assignIndexedValue(\n  index: number,\n  value: string,\n): string {\n  return getRefExpr(index) + '=' + value;\n}\n\nfunction isIndexedValueInStack(\n  ctx: CrossSerializerContext,\n  node: SerovalNode,\n): node is SerovalIndexedValueNode {\n  return node.t === SerovalNodeType.IndexedValue && ctx.stack.includes(node.i);\n}\n\nfunction serializeArray(\n  ctx: CrossSerializerContext,\n  node: SerovalArrayNode,\n): string {\n  const id = node.i;\n  ctx.stack.push(id);\n  // This is different than Map and Set\n  // because we also need to serialize\n  // the holes of the Array\n  let values = '';\n  let item: SerovalNode | undefined;\n  let isHoley = false;\n  const list = node.a;\n  for (let i = 0, len = node.l; i < len; i++) {\n    if (i !== 0) {\n      // Add an empty item\n      values += ',';\n    }\n    item = list[i];\n    // Check if index is a hole\n    if (item) {\n      // Check if item is a parent\n      if (isIndexedValueInStack(ctx, item)) {\n        createArrayAssign(ctx, id, i, getRefExpr(item.i));\n        isHoley = true;\n      } else {\n        values += crossSerializeTree(ctx, item);\n        isHoley = false;\n      }\n    } else {\n      isHoley = true;\n    }\n  }\n  ctx.stack.pop();\n  pushObjectFlag(ctx, node.o, node.i);\n  return assignIndexedValue(id, '[' + values + (isHoley ? ',]' : ']'));\n}\n\nfunction getIterableAccess(ctx: CrossSerializerContext): string {\n  return ctx.features & Feature.ArrayPrototypeValues\n    ? '.values()'\n    : '[Symbol.iterator]()';\n}\n\nfunction serializeIterable(\n  ctx: CrossSerializerContext,\n  node: SerovalNode,\n): string {\n  const parent = ctx.stack;\n  ctx.stack = [];\n  let serialized = crossSerializeTree(ctx, node) + getIterableAccess(ctx);\n  ctx.stack = parent;\n  if (ctx.features & Feature.ArrowFunction) {\n    serialized = '[Symbol.iterator]:()=>' + serialized;\n  } else if (ctx.features & Feature.MethodShorthand) {\n    serialized = '[Symbol.iterator](){return ' + serialized + '}';\n  } else {\n    serialized = '[Symbol.iterator]:function(){return ' + serialized + '}';\n  }\n  return serialized;\n}\n\nfunction serializeProperties(\n  ctx: CrossSerializerContext,\n  sourceID: number,\n  node: SerovalObjectRecordNode,\n): string {\n  const len = node.s;\n  if (len === 0) {\n    return '{}';\n  }\n  let result = '';\n  ctx.stack.push(sourceID);\n  let key: SerovalObjectRecordKey;\n  let val: SerovalNode;\n  let check: number;\n  let isIdentifier: boolean;\n  let refParam: string;\n  let hasPrev = false;\n  const keys = node.k;\n  const values = node.v;\n  for (let i = 0; i < len; i++) {\n    key = keys[i];\n    val = values[i];\n    switch (key) {\n      case SerovalObjectRecordSpecialKey.SymbolIterator:\n        result += (hasPrev ? ',' : '') + serializeIterable(ctx, val);\n        hasPrev = true;\n        break;\n      default:\n        check = Number(key);\n        // Test if key is a valid number or JS identifier\n        // so that we don't have to serialize the key and wrap with brackets\n        isIdentifier = check >= 0 || isValidIdentifier(key);\n        if (isIndexedValueInStack(ctx, val)) {\n          refParam = getRefExpr(val.i);\n          if (isIdentifier && Number.isNaN(check)) {\n            createObjectAssign(ctx, sourceID, key, refParam);\n          } else {\n            createArrayAssign(ctx, sourceID, isIdentifier ? key : ('\"' + key + '\"'), refParam);\n          }\n        } else {\n          result += (hasPrev ? ',' : '')\n            + (isIdentifier ? key : ('\"' + key + '\"'))\n            + ':' + crossSerializeTree(ctx, val);\n          hasPrev = true;\n        }\n        break;\n    }\n  }\n  ctx.stack.pop();\n  return '{' + result + '}';\n}\n\nfunction serializeWithObjectAssign(\n  ctx: CrossSerializerContext,\n  value: SerovalObjectRecordNode,\n  id: number,\n  serialized: string,\n): string {\n  const fields = serializeProperties(ctx, id, value);\n  if (fields !== '{}') {\n    return 'Object.assign(' + serialized + ',' + fields + ')';\n  }\n  return serialized;\n}\n\nfunction serializeAssignments(\n  ctx: CrossSerializerContext,\n  sourceID: number,\n  node: SerovalObjectRecordNode,\n): string | undefined {\n  ctx.stack.push(sourceID);\n  const mainAssignments: Assignment[] = [];\n  let key: SerovalObjectRecordKey;\n  let value: SerovalNode;\n  let parentAssignment: Assignment[];\n  const keys = node.k;\n  const values = node.v;\n  for (let i = 0, len = node.s; i < len; i++) {\n    key = keys[i];\n    value = values[i];\n    switch (key) {\n      case SerovalObjectRecordSpecialKey.SymbolIterator: {\n        const parent = ctx.stack;\n        ctx.stack = [];\n        const serialized = crossSerializeTree(ctx, value) + getIterableAccess(ctx);\n        ctx.stack = parent;\n        parentAssignment = ctx.assignments;\n        ctx.assignments = mainAssignments;\n        createArrayAssign(\n          ctx,\n          sourceID,\n          'Symbol.iterator',\n          ctx.features & Feature.ArrowFunction\n            ? '()=>' + serialized\n            : 'function(){return ' + serialized + '}',\n        );\n        ctx.assignments = parentAssignment;\n      }\n        break;\n      default: {\n        const serialized = crossSerializeTree(ctx, value);\n        const check = Number(key);\n        const isIdentifier = check >= 0 || isValidIdentifier(key);\n        if (isIndexedValueInStack(ctx, value)) {\n          // Test if key is a valid number or JS identifier\n          // so that we don't have to serialize the key and wrap with brackets\n          if (isIdentifier && Number.isNaN(check)) {\n            createObjectAssign(ctx, sourceID, key, serialized);\n          } else {\n            createArrayAssign(ctx, sourceID, isIdentifier ? key : ('\"' + key + '\"'), serialized);\n          }\n        } else {\n          // Test if key is a valid number or JS identifier\n          // so that we don't have to serialize the key and wrap with brackets\n          parentAssignment = ctx.assignments;\n          ctx.assignments = mainAssignments;\n          if (isIdentifier && Number.isNaN(check)) {\n            createObjectAssign(ctx, sourceID, key, serialized);\n          } else {\n            createArrayAssign(ctx, sourceID, isIdentifier ? key : ('\"' + key + '\"'), serialized);\n          }\n          ctx.assignments = parentAssignment;\n        }\n      }\n    }\n  }\n  ctx.stack.pop();\n  return resolveAssignments(mainAssignments);\n}\n\nfunction serializeDictionary(\n  ctx: CrossSerializerContext,\n  i: number,\n  p: SerovalObjectRecordNode | undefined,\n  init: string,\n): string {\n  if (p) {\n    if (ctx.features & Feature.ObjectAssign) {\n      init = serializeWithObjectAssign(ctx, p, i, init);\n    } else {\n      const assignments = serializeAssignments(ctx, i, p);\n      if (assignments) {\n        return '(' + assignIndexedValue(i, init) + ',' + assignments + getRefExpr(i) + ')';\n      }\n    }\n  }\n  return assignIndexedValue(i, init);\n}\n\nconst NULL_CONSTRUCTOR = 'Object.create(null)';\n\nfunction serializeNullConstructor(\n  ctx: CrossSerializerContext,\n  node: SerovalNullConstructorNode,\n): string {\n  pushObjectFlag(ctx, node.o, node.i);\n  return serializeDictionary(ctx, node.i, node.p, NULL_CONSTRUCTOR);\n}\n\nfunction serializeObject(\n  ctx: CrossSerializerContext,\n  node: SerovalObjectNode,\n): string {\n  pushObjectFlag(ctx, node.o, node.i);\n  return assignIndexedValue(node.i, serializeProperties(ctx, node.i, node.p));\n}\n\nfunction serializeSet(\n  ctx: CrossSerializerContext,\n  node: SerovalSetNode,\n): string {\n  let serialized = 'new Set';\n  const size = node.l;\n  const id = node.i;\n  if (size) {\n    let result = '';\n    let item: SerovalNode;\n    let hasPrev = false;\n    const items = node.a;\n    ctx.stack.push(id);\n    for (let i = 0; i < size; i++) {\n      item = items[i];\n      if (isIndexedValueInStack(ctx, item)) {\n        createAddAssignment(ctx, id, getRefExpr(item.i));\n      } else {\n        // Push directly\n        result += (hasPrev ? ',' : '') + crossSerializeTree(ctx, item);\n        hasPrev = true;\n      }\n    }\n    ctx.stack.pop();\n    if (result) {\n      serialized += '([' + result + '])';\n    }\n  }\n  return assignIndexedValue(id, serialized);\n}\n\nfunction serializeMap(\n  ctx: CrossSerializerContext,\n  node: SerovalMapNode,\n): string {\n  let serialized = 'new Map';\n  const size = node.e.s;\n  const id = node.i;\n  if (size) {\n    let result = '';\n    let key: SerovalNode;\n    let val: SerovalNode;\n    let keyRef: string;\n    let valueRef: string;\n    let parent: number[];\n    let hasPrev = false;\n    const keys = node.e.k;\n    const vals = node.e.v;\n    ctx.stack.push(id);\n    for (let i = 0; i < size; i++) {\n      // Check if key is a parent\n      key = keys[i];\n      val = vals[i];\n      if (isIndexedValueInStack(ctx, key)) {\n        // Create reference for the map instance\n        keyRef = getRefExpr(id);\n        // Check if value is a parent\n        if (isIndexedValueInStack(ctx, val)) {\n          valueRef = getRefExpr(val.i);\n          // Register an assignment since\n          // both key and value are a parent of this\n          // Map instance\n          createSetAssignment(ctx, id, keyRef, valueRef);\n        } else {\n          // Reset the stack\n          // This is required because the serialized\n          // value is no longer part of the expression\n          // tree and has been moved to the deferred\n          // assignment\n          parent = ctx.stack;\n          ctx.stack = [];\n          createSetAssignment(ctx, id, keyRef, crossSerializeTree(ctx, val));\n          ctx.stack = parent;\n        }\n      } else if (isIndexedValueInStack(ctx, val)) {\n        // Create ref for the Map instance\n        valueRef = getRefExpr(val.i);\n        // Reset stack for the key serialization\n        parent = ctx.stack;\n        ctx.stack = [];\n        createSetAssignment(ctx, id, crossSerializeTree(ctx, key), valueRef);\n        ctx.stack = parent;\n      } else {\n        result += (hasPrev ? ',[' : '[') + crossSerializeTree(ctx, key) + ',' + crossSerializeTree(ctx, val) + ']';\n        hasPrev = true;\n      }\n    }\n    ctx.stack.pop();\n    // Check if there are any values\n    // so that the empty Map constructor\n    // can be used instead\n    if (result) {\n      serialized += '([' + result + '])';\n    }\n  }\n  return assignIndexedValue(id, serialized);\n}\n\nfunction serializeAggregateError(\n  ctx: CrossSerializerContext,\n  node: SerovalAggregateErrorNode,\n): string {\n  // Serialize the required arguments\n  const id = node.i;\n  ctx.stack.push(id);\n  const serialized = 'new AggregateError([],\"' + node.m + '\")';\n  ctx.stack.pop();\n  // `AggregateError` might've been extended\n  // either through class or custom properties\n  // Make sure to assign extra properties\n  return serializeDictionary(ctx, id, node.p, serialized);\n}\n\nfunction serializeError(\n  ctx: CrossSerializerContext,\n  node: SerovalErrorNode,\n): string {\n  return serializeDictionary(ctx, node.i, node.p, 'new ' + node.c + '(\"' + node.m + '\")');\n}\n\nconst PROMISE_RESOLVE = 'Promise.resolve';\nconst PROMISE_REJECT = 'Promise.reject';\n\nfunction serializePromise(\n  ctx: CrossSerializerContext,\n  node: SerovalPromiseNode,\n): string {\n  let serialized: string;\n  // Check if resolved value is a parent expression\n  const fulfilled = node.f;\n  const id = node.i;\n  const constructor = node.s ? PROMISE_RESOLVE : PROMISE_REJECT;\n  if (isIndexedValueInStack(ctx, fulfilled)) {\n    // A Promise trick, reference the value\n    // inside the `then` expression so that\n    // the Promise evaluates after the parent\n    // has initialized\n    const ref = getRefExpr(fulfilled.i);\n    if (ctx.features & Feature.ArrowFunction) {\n      if (node.s) {\n        serialized = constructor + '().then(()=>' + ref + ')';\n      } else {\n        serialized = constructor + '().catch(()=>{throw ' + ref + '})';\n      }\n    } else if (node.s) {\n      serialized = constructor + '().then(function(){return ' + ref + '})';\n    } else {\n      serialized = constructor + '().catch(function(){throw ' + ref + '})';\n    }\n  } else {\n    ctx.stack.push(id);\n    const result = crossSerializeTree(ctx, fulfilled);\n    ctx.stack.pop();\n    // just inline the value/reference here\n    serialized = constructor + '(' + result + ')';\n  }\n  return assignIndexedValue(id, serialized);\n}\n\nfunction serializeArrayBuffer(\n  node: SerovalArrayBufferNode,\n): string {\n  let result = 'new Uint8Array(';\n  const buffer = node.s;\n  const len = buffer.length;\n  if (len) {\n    result += '[';\n    for (let i = 0; i < len; i++) {\n      result += ((i > 0) ? ',' : '') + buffer[i];\n    }\n    result += ']';\n  }\n  return assignIndexedValue(node.i, result + ').buffer');\n}\n\nfunction serializeTypedArray(\n  ctx: CrossSerializerContext,\n  node: SerovalTypedArrayNode | SerovalBigIntTypedArrayNode,\n): string {\n  return assignIndexedValue(\n    node.i,\n    'new ' + node.c + '(' + crossSerializeTree(ctx, node.f) + ',' + node.b + ',' + node.l + ')',\n  );\n}\n\nfunction serializeDate(\n  node: SerovalDateNode,\n): string {\n  return assignIndexedValue(node.i, 'new Date(\"' + node.s + '\")');\n}\n\nfunction serializeRegExp(\n  node: SerovalRegExpNode,\n): string {\n  return assignIndexedValue(node.i, '/' + node.c + '/' + node.m);\n}\n\nfunction serializeURL(\n  node: SerovalURLNode,\n): string {\n  return assignIndexedValue(node.i, 'new URL(\"' + node.s + '\")');\n}\n\nfunction serializeURLSearchParams(\n  node: SerovalURLSearchParamsNode,\n): string {\n  return assignIndexedValue(\n    node.i,\n    node.s ? 'new URLSearchParams(\"' + node.s + '\")' : 'new URLSearchParams',\n  );\n}\n\nfunction serializeReference(\n  node: SerovalReferenceNode,\n): string {\n  return assignIndexedValue(node.i, REFERENCES_KEY + '.get(\"' + node.s + '\")');\n}\n\nfunction serializeDataView(\n  ctx: CrossSerializerContext,\n  node: SerovalDataViewNode,\n): string {\n  return assignIndexedValue(\n    node.i,\n    'new DataView(' + crossSerializeTree(ctx, node.f) + ',' + node.b + ',' + node.l + ')',\n  );\n}\n\nfunction serializeBlob(\n  ctx: CrossSerializerContext,\n  node: SerovalBlobNode,\n): string {\n  return assignIndexedValue(\n    node.i,\n    'new Blob([' + crossSerializeTree(ctx, node.f) + '],{type:\"' + node.c + '\"})',\n  );\n}\n\nfunction serializeFile(\n  ctx: CrossSerializerContext,\n  node: SerovalFileNode,\n): string {\n  return assignIndexedValue(\n    node.i,\n    'new File([' + crossSerializeTree(ctx, node.f) + '],\"' + node.m + '\",{type:\"' + node.c + '\",lastModified:' + node.b + '})',\n  );\n}\n\nfunction serializeHeaders(\n  ctx: CrossSerializerContext,\n  node: SerovalHeadersNode,\n): string {\n  return assignIndexedValue(\n    node.i,\n    'new Headers(' + serializeProperties(ctx, node.i, node.e) + ')',\n  );\n}\n\nfunction serializeFormDataEntries(\n  ctx: CrossSerializerContext,\n  node: SerovalFormDataNode,\n): string | undefined {\n  let value: string;\n  let key: string;\n  const keys = node.e.k;\n  const vals = node.e.v;\n  const id = node.i;\n  const mainAssignments: Assignment[] = [];\n  let parentAssignment: Assignment[];\n  ctx.stack.push(id);\n  for (let i = 0, len = node.e.s; i < len; i++) {\n    key = keys[i];\n    value = crossSerializeTree(ctx, vals[i]);\n    parentAssignment = ctx.assignments;\n    ctx.assignments = mainAssignments;\n    createAppendAssignment(ctx, id, '\"' + key + '\"', value);\n    ctx.assignments = parentAssignment;\n  }\n  ctx.stack.pop();\n  return resolveAssignments(mainAssignments);\n}\n\nfunction serializeFormData(\n  ctx: CrossSerializerContext,\n  node: SerovalFormDataNode,\n): string {\n  const size = node.e.s;\n  const id = node.i;\n  const result = assignIndexedValue(id, 'new FormData()');\n  if (size) {\n    const entries = serializeFormDataEntries(ctx, node);\n    return '(' + result + ',' + (entries == null ? '' : entries) + getRefExpr(id) + ')';\n  }\n  return result;\n}\n\nfunction serializeBoxed(\n  ctx: CrossSerializerContext,\n  node: SerovalBoxedNode,\n): string {\n  return assignIndexedValue(node.i, 'Object(' + crossSerializeTree(ctx, node.f) + ')');\n}\n\nfunction serializeWKSymbol(\n  node: SerovalWKSymbolNode,\n): string {\n  return assignIndexedValue(node.i, SYMBOL_STRING[node.s]);\n}\n\nfunction serializePromiseResolve(\n  ctx: CrossSerializerContext,\n  node: SerovalPromiseResolveNode,\n): string {\n  return GLOBAL_CONTEXT_API + '.' + GLOBAL_CONTEXT_PROMISE_RESOLVE + '(' + getRefExpr(node.i) + ',' + crossSerializeTree(ctx, node.f) + ')';\n}\n\nfunction serializePromiseReject(\n  ctx: CrossSerializerContext,\n  node: SerovalPromiseRejectNode,\n): string {\n  return GLOBAL_CONTEXT_API + '.' + GLOBAL_CONTEXT_PROMISE_REJECT + '(' + getRefExpr(node.i) + ',' + crossSerializeTree(ctx, node.f) + ')';\n}\n\nfunction serializePromiseConstructor(\n  node: SerovalPromiseConstructorNode,\n): string {\n  return assignIndexedValue(node.i, GLOBAL_CONTEXT_API + '.' + GLOBAL_CONTEXT_PROMISE_CONSTRUCTOR + '()');\n}\n\nfunction serializeReadableStreamClose(\n  node: SerovalReadableStreamCloseNode,\n): string {\n  return GLOBAL_CONTEXT_API + '.' + GLOBAL_CONTEXT_STREAM_EMIT + '(' + getRefExpr(node.i) + ',2)';\n}\n\nfunction serializeReadableStreamEnqueue(\n  ctx: CrossSerializerContext,\n  node: SerovalReadableStreamEnqueueNode,\n): string {\n  return GLOBAL_CONTEXT_API + '.' + GLOBAL_CONTEXT_STREAM_EMIT + '(' + getRefExpr(node.i) + ',0,' + crossSerializeTree(ctx, node.f) + ')';\n}\n\nfunction serializeReadableStreamError(\n  ctx: CrossSerializerContext,\n  node: SerovalReadableStreamErrorNode,\n): string {\n  return GLOBAL_CONTEXT_API + '.' + GLOBAL_CONTEXT_STREAM_EMIT + '(' + getRefExpr(node.i) + ',1,' + crossSerializeTree(ctx, node.f) + ')';\n}\n\nfunction serializeReadableStreamConstructor(\n  node: SerovalReadableStreamConstructorNode,\n): string {\n  return assignIndexedValue(node.i, GLOBAL_CONTEXT_API + '.' + GLOBAL_CONTEXT_STREAM_CONSTRUCTOR + '()');\n}\n\nexport default function crossSerializeTree(\n  ctx: CrossSerializerContext,\n  node: SerovalNode,\n): string {\n  switch (node.t) {\n    case SerovalNodeType.Number:\n      return '' + node.s;\n    case SerovalNodeType.String:\n      return '\"' + node.s + '\"';\n    case SerovalNodeType.Constant:\n      return serializeConstant(node);\n    case SerovalNodeType.BigInt:\n      return node.s + 'n';\n    case SerovalNodeType.IndexedValue:\n      return getRefExpr(node.i);\n    case SerovalNodeType.Array:\n      return serializeArray(ctx, node);\n    case SerovalNodeType.Object:\n      return serializeObject(ctx, node);\n    case SerovalNodeType.NullConstructor:\n      return serializeNullConstructor(ctx, node);\n    case SerovalNodeType.Date:\n      return serializeDate(node);\n    case SerovalNodeType.RegExp:\n      return serializeRegExp(node);\n    case SerovalNodeType.Set:\n      return serializeSet(ctx, node);\n    case SerovalNodeType.Map:\n      return serializeMap(ctx, node);\n    case SerovalNodeType.ArrayBuffer:\n      return serializeArrayBuffer(node);\n    case SerovalNodeType.BigIntTypedArray:\n    case SerovalNodeType.TypedArray:\n      return serializeTypedArray(ctx, node);\n    case SerovalNodeType.DataView:\n      return serializeDataView(ctx, node);\n    case SerovalNodeType.AggregateError:\n      return serializeAggregateError(ctx, node);\n    case SerovalNodeType.Error:\n      return serializeError(ctx, node);\n    case SerovalNodeType.Promise:\n      return serializePromise(ctx, node);\n    case SerovalNodeType.WKSymbol:\n      return serializeWKSymbol(node);\n    case SerovalNodeType.URL:\n      return serializeURL(node);\n    case SerovalNodeType.URLSearchParams:\n      return serializeURLSearchParams(node);\n    case SerovalNodeType.Reference:\n      return serializeReference(node);\n    case SerovalNodeType.Blob:\n      return serializeBlob(ctx, node);\n    case SerovalNodeType.File:\n      return serializeFile(ctx, node);\n    case SerovalNodeType.Headers:\n      return serializeHeaders(ctx, node);\n    case SerovalNodeType.FormData:\n      return serializeFormData(ctx, node);\n    case SerovalNodeType.Boxed:\n      return serializeBoxed(ctx, node);\n    case SerovalNodeType.PromiseResolve:\n      return serializePromiseResolve(ctx, node);\n    case SerovalNodeType.PromiseReject:\n      return serializePromiseReject(ctx, node);\n    case SerovalNodeType.PromiseConstructor:\n      return serializePromiseConstructor(node);\n    case SerovalNodeType.ReadableStreamClose:\n      return serializeReadableStreamClose(node);\n    case SerovalNodeType.ReadableStreamConstructor:\n      return serializeReadableStreamConstructor(node);\n    case SerovalNodeType.ReadableStreamEnqueue:\n      return serializeReadableStreamEnqueue(ctx, node);\n    case SerovalNodeType.ReadableStreamError:\n      return serializeReadableStreamError(ctx, node);\n    default:\n      throw new Error('invariant');\n  }\n}\n", "/* eslint-disable no-await-in-loop */\n/* eslint-disable @typescript-eslint/no-use-before-define */\nimport assert from '../assert';\nimport { Feature } from '../compat';\nimport type { StreamingCrossParserContext } from './context';\nimport {\n  createCrossIndexedValue, popPendingState, pushPendingState,\n} from './context';\nimport { serializeString } from '../string';\nimport type {\n  BigIntTypedArrayValue,\n  TypedArrayValue,\n} from '../../types';\nimport UnsupportedTypeError from '../UnsupportedTypeError';\nimport {\n  TRUE_NODE,\n  FALSE_NODE,\n  UNDEFINED_NODE,\n  NULL_NODE,\n} from '../literals';\nimport {\n  createBigIntTypedArrayNode,\n  createTypedArrayNode,\n  createDataViewNode,\n  createSymbolNode,\n  createFunctionNode,\n} from './primitives';\nimport { hasReferenceID } from '../reference';\nimport {\n  getErrorConstructorName,\n  getErrorOptions,\n  getObjectFlag,\n  isIterable,\n} from '../shared';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalBoxedNode,\n  SerovalErrorNode,\n  SerovalFormDataNode,\n  SerovalHeadersNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPlainRecordNode,\n  SerovalPromiseNode,\n  SerovalPromiseConstructorNode,\n  SerovalSetNode,\n  SerovalReadableStreamConstructorNode,\n} from '../types';\nimport {\n  SerovalObjectRecordSpecialKey,\n} from '../types';\n// import {\n//   createBlobNode,\n//   createFileNode,\n// } from './web-api';\nimport { SerovalNodeType } from '../constants';\nimport {\n  createArrayBufferNode,\n  createBigIntNode,\n  createDateNode,\n  createIndexedValueNode,\n  createNumberNode,\n  createReferenceNode,\n  createRegExpNode,\n  createStringNode,\n} from '../base-primitives';\nimport { createURLNode, createURLSearchParamsNode } from '../web-api';\n\ntype ObjectLikeNode =\n  | SerovalObjectNode\n  | SerovalNullConstructorNode\n  | SerovalPromiseNode;\n\nfunction generateNodeList(\n  ctx: StreamingCrossParserContext,\n  current: unknown[],\n): SerovalNode[] {\n  const size = current.length;\n  const nodes = new Array<SerovalNode>(size);\n  const deferred = new Array<unknown>(size);\n  let item: unknown;\n  for (let i = 0; i < size; i++) {\n    if (i in current) {\n      item = current[i];\n      if (isIterable(item)) {\n        deferred[i] = item;\n      } else {\n        nodes[i] = crossParseStream(ctx, item);\n      }\n    }\n  }\n  for (let i = 0; i < size; i++) {\n    if (i in deferred) {\n      nodes[i] = crossParseStream(ctx, deferred[i]);\n    }\n  }\n  return nodes;\n}\n\nfunction generateArrayNode(\n  ctx: StreamingCrossParserContext,\n  id: number,\n  current: unknown[],\n): SerovalArrayNode {\n  return {\n    t: SerovalNodeType.Array,\n    i: id,\n    s: undefined,\n    l: current.length,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: generateNodeList(ctx, current),\n    f: undefined,\n    b: undefined,\n    o: getObjectFlag(current),\n  };\n}\n\nfunction generateMapNode(\n  ctx: StreamingCrossParserContext,\n  id: number,\n  current: Map<unknown, unknown>,\n): SerovalMapNode {\n  assert(ctx.features & Feature.Map, new UnsupportedTypeError(current));\n  const len = current.size;\n  const keyNodes = new Array<SerovalNode>(len);\n  const valueNodes = new Array<SerovalNode>(len);\n  const deferredKey = new Array<unknown>(len);\n  const deferredValue = new Array<unknown>(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const [key, value] of current.entries()) {\n    // Either key or value might be an iterable\n    if (isIterable(key) || isIterable(value)) {\n      deferredKey[deferredSize] = key;\n      deferredValue[deferredSize] = value;\n      deferredSize++;\n    } else {\n      keyNodes[nodeSize] = crossParseStream(ctx, key);\n      valueNodes[nodeSize] = crossParseStream(ctx, value);\n      nodeSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodeSize + i] = crossParseStream(ctx, deferredKey[i]);\n    valueNodes[nodeSize + i] = crossParseStream(ctx, deferredValue[i]);\n  }\n  return {\n    t: SerovalNodeType.Map,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: { k: keyNodes, v: valueNodes, s: len },\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateSetNode(\n  ctx: StreamingCrossParserContext,\n  id: number,\n  current: Set<unknown>,\n): SerovalSetNode {\n  assert(ctx.features & Feature.Set, new UnsupportedTypeError(current));\n  const len = current.size;\n  const nodes = new Array<SerovalNode>(len);\n  const deferred = new Array<unknown>(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const item of current.keys()) {\n    // Iterables are lazy, so the evaluation must be deferred\n    if (isIterable(item)) {\n      deferred[deferredSize++] = item;\n    } else {\n      nodes[nodeSize++] = crossParseStream(ctx, item);\n    }\n  }\n  // Parse deferred items\n  for (let i = 0; i < deferredSize; i++) {\n    nodes[nodeSize + i] = crossParseStream(ctx, deferred[i]);\n  }\n  return {\n    t: SerovalNodeType.Set,\n    i: id,\n    s: undefined,\n    l: len,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: nodes,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateProperties(\n  ctx: StreamingCrossParserContext,\n  properties: Record<string, unknown>,\n): SerovalObjectRecordNode {\n  const keys = Object.keys(properties);\n  let size = keys.length;\n  const keyNodes = new Array<SerovalObjectRecordKey>(size);\n  const valueNodes = new Array<SerovalNode>(size);\n  const deferredKeys = new Array<SerovalObjectRecordKey>(size);\n  const deferredValues = new Array<unknown>(size);\n  let deferredSize = 0;\n  let nodesSize = 0;\n  let item: unknown;\n  let escaped: SerovalObjectRecordKey;\n  for (const key of keys) {\n    item = properties[key];\n    escaped = serializeString(key);\n    if (isIterable(item)) {\n      deferredKeys[deferredSize] = escaped;\n      deferredValues[deferredSize] = item;\n      deferredSize++;\n    } else {\n      keyNodes[nodesSize] = escaped;\n      valueNodes[nodesSize] = crossParseStream(ctx, item);\n      nodesSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodesSize + i] = deferredKeys[i];\n    valueNodes[nodesSize + i] = crossParseStream(ctx, deferredValues[i]);\n  }\n  if (ctx.features & Feature.Symbol) {\n    if (Symbol.iterator in properties) {\n      keyNodes[size] = SerovalObjectRecordSpecialKey.SymbolIterator;\n      const items = Array.from(properties as Iterable<unknown>);\n      valueNodes[size] = generateArrayNode(\n        ctx,\n        createCrossIndexedValue(ctx, items),\n        items,\n      );\n      size++;\n    }\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: size,\n  };\n}\n\nfunction generatePlainProperties(\n  ctx: StreamingCrossParserContext,\n  properties: Record<string, unknown>,\n): SerovalPlainRecordNode {\n  const keys = Object.keys(properties);\n  const size = keys.length;\n  const keyNodes = new Array<string>(size);\n  const valueNodes = new Array<SerovalNode>(size);\n  const deferredKeys = new Array<string>(size);\n  const deferredValues = new Array<unknown>(size);\n  let deferredSize = 0;\n  let nodesSize = 0;\n  let item: unknown;\n  let escaped: string;\n  for (const key of keys) {\n    item = properties[key];\n    escaped = serializeString(key);\n    if (isIterable(item)) {\n      deferredKeys[deferredSize] = escaped;\n      deferredValues[deferredSize] = item;\n      deferredSize++;\n    } else {\n      keyNodes[nodesSize] = escaped;\n      valueNodes[nodesSize] = crossParseStream(ctx, item);\n      nodesSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodesSize + i] = deferredKeys[i];\n    valueNodes[nodesSize + i] = crossParseStream(ctx, deferredValues[i]);\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: size,\n  };\n}\n\nfunction generatePromiseNode(\n  ctx: StreamingCrossParserContext,\n  id: number,\n  current: Promise<unknown>,\n): SerovalPromiseConstructorNode {\n  assert(ctx.features & Feature.Promise, new UnsupportedTypeError(current));\n  current.then(\n    (data) => {\n      if (ctx.alive) {\n        ctx.onParse({\n          t: SerovalNodeType.PromiseResolve,\n          i: id,\n          s: undefined,\n          l: undefined,\n          c: undefined,\n          m: undefined,\n          p: undefined,\n          e: undefined,\n          a: undefined,\n          f: crossParseStream(ctx, data),\n          b: undefined,\n          o: undefined,\n        }, false);\n        popPendingState(ctx);\n      }\n    },\n    (data) => {\n      if (ctx.alive) {\n        ctx.onParse({\n          t: SerovalNodeType.PromiseReject,\n          i: id,\n          s: undefined,\n          l: undefined,\n          c: undefined,\n          m: undefined,\n          p: undefined,\n          e: undefined,\n          a: undefined,\n          f: crossParseStream(ctx, data),\n          b: undefined,\n          o: undefined,\n        }, false);\n        popPendingState(ctx);\n      }\n    },\n  );\n  pushPendingState(ctx);\n  return {\n    t: SerovalNodeType.PromiseConstructor,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateObjectNode(\n  ctx: StreamingCrossParserContext,\n  id: number,\n  current: Record<string, unknown>,\n  empty: boolean,\n): ObjectLikeNode {\n  return {\n    t: empty ? SerovalNodeType.NullConstructor : SerovalNodeType.Object,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: generateProperties(ctx, current),\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: getObjectFlag(current),\n  };\n}\n\nfunction generateAggregateErrorNode(\n  ctx: StreamingCrossParserContext,\n  id: number,\n  current: AggregateError,\n): SerovalAggregateErrorNode {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options\n    ? generateProperties(ctx, options)\n    : undefined;\n  return {\n    t: SerovalNodeType.AggregateError,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: serializeString(current.message),\n    p: optionsNode,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateErrorNode(\n  ctx: StreamingCrossParserContext,\n  id: number,\n  current: Error,\n): SerovalErrorNode {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options\n    ? generateProperties(ctx, options)\n    : undefined;\n  return {\n    t: SerovalNodeType.Error,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: getErrorConstructorName(current),\n    m: serializeString(current.message),\n    p: optionsNode,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateHeadersNode(\n  ctx: StreamingCrossParserContext,\n  id: number,\n  current: Headers,\n): SerovalHeadersNode {\n  assert(ctx.features & Feature.WebAPI, new UnsupportedTypeError(current));\n  const items: Record<string, string> = {};\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: SerovalNodeType.Headers,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: generatePlainProperties(ctx, items),\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateFormDataNode(\n  ctx: StreamingCrossParserContext,\n  id: number,\n  current: FormData,\n): SerovalFormDataNode {\n  assert(ctx.features & Feature.WebAPI, new UnsupportedTypeError(current));\n  const items: Record<string, FormDataEntryValue> = {};\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: SerovalNodeType.FormData,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: generatePlainProperties(ctx, items),\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateBoxedNode(\n  ctx: StreamingCrossParserContext,\n  id: number,\n  current: object,\n): SerovalBoxedNode {\n  return {\n    t: SerovalNodeType.Boxed,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: crossParseStream(ctx, current.valueOf()),\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateReadableStreamNode(\n  ctx: StreamingCrossParserContext,\n  id: number,\n  current: ReadableStream<unknown>,\n): SerovalReadableStreamConstructorNode {\n  assert(ctx.features & Feature.WebAPI, new UnsupportedTypeError(current));\n  const reader = current.getReader();\n  pushPendingState(ctx);\n\n  function push(): void {\n    reader.read().then(\n      (data) => {\n        if (ctx.alive) {\n          if (data.done) {\n            ctx.onParse({\n              t: SerovalNodeType.ReadableStreamClose,\n              i: id,\n              s: undefined,\n              l: undefined,\n              c: undefined,\n              m: undefined,\n              p: undefined,\n              e: undefined,\n              a: undefined,\n              f: undefined,\n              b: undefined,\n              o: undefined,\n            }, false);\n            popPendingState(ctx);\n          } else {\n            ctx.onParse({\n              t: SerovalNodeType.ReadableStreamEnqueue,\n              i: id,\n              s: undefined,\n              l: undefined,\n              c: undefined,\n              m: undefined,\n              p: undefined,\n              e: undefined,\n              a: undefined,\n              f: crossParseStream(ctx, data.value),\n              b: undefined,\n              o: undefined,\n            }, false);\n            push();\n          }\n        }\n      },\n      (value) => {\n        if (ctx.alive) {\n          ctx.onParse({\n            t: SerovalNodeType.ReadableStreamError,\n            i: id,\n            s: undefined,\n            l: undefined,\n            c: undefined,\n            m: undefined,\n            p: undefined,\n            e: undefined,\n            a: undefined,\n            f: crossParseStream(ctx, value),\n            b: undefined,\n            o: undefined,\n          }, false);\n          popPendingState(ctx);\n        }\n      },\n    );\n  }\n\n  push();\n\n  return {\n    t: SerovalNodeType.ReadableStreamConstructor,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction parseObject(\n  ctx: StreamingCrossParserContext,\n  current: object | null,\n): SerovalNode {\n  if (!current) {\n    return NULL_NODE;\n  }\n  // Non-primitive values needs a reference ID\n  // mostly because the values themselves are stateful\n  const registeredID = ctx.refs.get(current);\n  if (registeredID != null) {\n    return createIndexedValueNode(registeredID);\n  }\n  const id = ctx.refs.size;\n  ctx.refs.set(current, id);\n  if (hasReferenceID(current)) {\n    return createReferenceNode(id, current);\n  }\n  if (Array.isArray(current)) {\n    return generateArrayNode(ctx, id, current);\n  }\n  switch (current.constructor) {\n    case Number:\n    case Boolean:\n    case String:\n    case BigInt:\n    case Function:\n    case Symbol:\n      return generateBoxedNode(ctx, id, current);\n    case Date:\n      return createDateNode(id, current as unknown as Date);\n    case RegExp:\n      return createRegExpNode(id, current as unknown as RegExp);\n    case Promise:\n      return generatePromiseNode(ctx, id, current as unknown as Promise<unknown>);\n    case ArrayBuffer:\n      return createArrayBufferNode(id, current as unknown as ArrayBuffer);\n    case Int8Array:\n    case Int16Array:\n    case Int32Array:\n    case Uint8Array:\n    case Uint16Array:\n    case Uint32Array:\n    case Uint8ClampedArray:\n    case Float32Array:\n    case Float64Array:\n      return createTypedArrayNode(ctx, id, current as unknown as TypedArrayValue);\n    case BigInt64Array:\n    case BigUint64Array:\n      return createBigIntTypedArrayNode(ctx, id, current as unknown as BigIntTypedArrayValue);\n    case DataView:\n      return createDataViewNode(ctx, id, current as unknown as DataView);\n    case Map:\n      return generateMapNode(\n        ctx,\n        id,\n        current as unknown as Map<unknown, unknown>,\n      );\n    case Set:\n      return generateSetNode(\n        ctx,\n        id,\n        current as unknown as Set<unknown>,\n      );\n    case Object:\n      return generateObjectNode(\n        ctx,\n        id,\n        current as Record<string, unknown>,\n        false,\n      );\n    case undefined:\n      return generateObjectNode(\n        ctx,\n        id,\n        current as Record<string, unknown>,\n        true,\n      );\n    case AggregateError:\n      if (ctx.features & Feature.AggregateError) {\n        return generateAggregateErrorNode(ctx, id, current as unknown as AggregateError);\n      }\n      return generateErrorNode(ctx, id, current as unknown as AggregateError);\n    case Error:\n    case EvalError:\n    case RangeError:\n    case ReferenceError:\n    case SyntaxError:\n    case TypeError:\n    case URIError:\n      return generateErrorNode(ctx, id, current as unknown as Error);\n    case URL:\n      return createURLNode(ctx, id, current as unknown as URL);\n    case URLSearchParams:\n      return createURLSearchParamsNode(ctx, id, current as unknown as URLSearchParams);\n    // case Blob:\n    //   return createBlobNode(ctx, id, current as unknown as Blob);\n    // case File:\n    //   return createFileNode(ctx, id, current as unknown as File);\n    case Headers:\n      return generateHeadersNode(ctx, id, current as unknown as Headers);\n    case FormData:\n      return generateFormDataNode(ctx, id, current as unknown as FormData);\n    case ReadableStream:\n      return generateReadableStreamNode(ctx, id, current as unknown as ReadableStream);\n    default:\n      break;\n  }\n  if (current instanceof AggregateError) {\n    if (ctx.features & Feature.AggregateError) {\n      return generateAggregateErrorNode(ctx, id, current);\n    }\n    return generateErrorNode(ctx, id, current);\n  }\n  if (current instanceof Error) {\n    return generateErrorNode(ctx, id, current);\n  }\n  if (current instanceof Promise) {\n    return generatePromiseNode(ctx, id, current);\n  }\n  // Generator functions don't have a global constructor\n  if (Symbol.iterator in current) {\n    return generateObjectNode(ctx, id, current, !!current.constructor);\n  }\n  throw new UnsupportedTypeError(current);\n}\n\nexport default function crossParseStream<T>(\n  ctx: StreamingCrossParserContext,\n  current: T,\n): SerovalNode {\n  switch (typeof current) {\n    case 'boolean':\n      return current ? TRUE_NODE : FALSE_NODE;\n    case 'undefined':\n      return UNDEFINED_NODE;\n    case 'string':\n      return createStringNode(current);\n    case 'number':\n      return createNumberNode(current);\n    case 'bigint':\n      return createBigIntNode(ctx, current);\n    case 'object':\n      return parseObject(ctx, current);\n    case 'symbol':\n      return createSymbolNode(ctx, current);\n    case 'function':\n      return createFunctionNode(ctx, current);\n    default:\n      throw new UnsupportedTypeError(current);\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport assert from '../assert';\nimport { Feature } from '../compat';\nimport { createCrossIndexedValue, type CrossParserContext } from './context';\nimport { serializeString } from '../string';\nimport type { BigIntTypedArrayValue, TypedArrayValue } from '../../types';\nimport UnsupportedTypeError from '../UnsupportedTypeError';\nimport {\n  TRUE_NODE,\n  FALSE_NODE,\n  UNDEFINED_NODE,\n  NULL_NODE,\n} from '../literals';\nimport {\n  createBigIntTypedArrayNode,\n  createTypedArrayNode,\n  createDataViewNode,\n  createSymbolNode,\n  createFunctionNode,\n} from './primitives';\nimport {\n  hasReferenceID,\n} from '../reference';\nimport {\n  getErrorConstructorName,\n  getErrorOptions,\n  getObjectFlag,\n  isIterable,\n} from '../shared';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalBoxedNode,\n  SerovalErrorNode,\n  SerovalFormDataNode,\n  SerovalHeadersNode,\n  SerovalMapNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPlainRecordNode,\n  SerovalSetNode,\n  SerovalSyncNode,\n} from '../types';\nimport {\n  SerovalObjectRecordSpecialKey,\n} from '../types';\nimport { SerovalNodeType } from '../constants';\nimport {\n  createArrayBufferNode,\n  createBigIntNode,\n  createDateNode,\n  createIndexedValueNode,\n  createNumberNode,\n  createReferenceNode,\n  createRegExpNode,\n  createStringNode,\n} from '../base-primitives';\nimport { createURLNode, createURLSearchParamsNode } from '../web-api';\n\ntype ObjectLikeNode = SerovalObjectNode | SerovalNullConstructorNode;\n\nfunction generateNodeList(ctx: CrossParserContext, current: unknown[]): SerovalSyncNode[] {\n  const size = current.length;\n  const nodes = new Array<SerovalSyncNode>(size);\n  const deferred = new Array<unknown>(size);\n  let item: unknown;\n  for (let i = 0; i < size; i++) {\n    if (i in current) {\n      item = current[i];\n      if (isIterable(item)) {\n        deferred[i] = item;\n      } else {\n        nodes[i] = crossParseSync(ctx, item);\n      }\n    }\n  }\n  for (let i = 0; i < size; i++) {\n    if (i in deferred) {\n      nodes[i] = crossParseSync(ctx, deferred[i]);\n    }\n  }\n  return nodes;\n}\n\nfunction generateArrayNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: unknown[],\n): SerovalArrayNode {\n  return {\n    t: SerovalNodeType.Array,\n    i: id,\n    s: undefined,\n    l: current.length,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: generateNodeList(ctx, current),\n    f: undefined,\n    b: undefined,\n    o: getObjectFlag(current),\n  };\n}\n\nfunction generateMapNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: Map<unknown, unknown>,\n): SerovalMapNode {\n  assert(ctx.features & Feature.Map, new UnsupportedTypeError(current));\n  const len = current.size;\n  const keyNodes = new Array<SerovalSyncNode>(len);\n  const valueNodes = new Array<SerovalSyncNode>(len);\n  const deferredKey = new Array<unknown>(len);\n  const deferredValue = new Array<unknown>(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const [key, value] of current.entries()) {\n    // Either key or value might be an iterable\n    if (isIterable(key) || isIterable(value)) {\n      deferredKey[deferredSize] = key;\n      deferredValue[deferredSize] = value;\n      deferredSize++;\n    } else {\n      keyNodes[nodeSize] = crossParseSync(ctx, key);\n      valueNodes[nodeSize] = crossParseSync(ctx, value);\n      nodeSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodeSize + i] = crossParseSync(ctx, deferredKey[i]);\n    valueNodes[nodeSize + i] = crossParseSync(ctx, deferredValue[i]);\n  }\n  return {\n    t: SerovalNodeType.Map,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: { k: keyNodes, v: valueNodes, s: len },\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateSetNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: Set<unknown>,\n): SerovalSetNode {\n  assert(ctx.features & Feature.Set, new UnsupportedTypeError(current));\n  const len = current.size;\n  const nodes = new Array<SerovalSyncNode>(len);\n  const deferred = new Array<unknown>(len);\n  let deferredSize = 0;\n  let nodeSize = 0;\n  for (const item of current.keys()) {\n    // Iterables are lazy, so the evaluation must be deferred\n    if (isIterable(item)) {\n      deferred[deferredSize++] = item;\n    } else {\n      nodes[nodeSize++] = crossParseSync(ctx, item);\n    }\n  }\n  // Parse deferred items\n  for (let i = 0; i < deferredSize; i++) {\n    nodes[nodeSize + i] = crossParseSync(ctx, deferred[i]);\n  }\n  return {\n    t: SerovalNodeType.Set,\n    i: id,\n    s: undefined,\n    l: len,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: nodes,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateProperties(\n  ctx: CrossParserContext,\n  properties: Record<string, unknown>,\n): SerovalObjectRecordNode {\n  const keys = Object.keys(properties);\n  let size = keys.length;\n  const keyNodes = new Array<SerovalObjectRecordKey>(size);\n  const valueNodes = new Array<SerovalSyncNode>(size);\n  const deferredKeys = new Array<SerovalObjectRecordKey>(size);\n  const deferredValues = new Array<unknown>(size);\n  let deferredSize = 0;\n  let nodesSize = 0;\n  let item: unknown;\n  let escaped: SerovalObjectRecordKey;\n  for (const key of keys) {\n    item = properties[key];\n    escaped = serializeString(key);\n    if (isIterable(item)) {\n      deferredKeys[deferredSize] = escaped;\n      deferredValues[deferredSize] = item;\n      deferredSize++;\n    } else {\n      keyNodes[nodesSize] = escaped;\n      valueNodes[nodesSize] = crossParseSync(ctx, item);\n      nodesSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodesSize + i] = deferredKeys[i];\n    valueNodes[nodesSize + i] = crossParseSync(ctx, deferredValues[i]);\n  }\n  if (ctx.features & Feature.Symbol) {\n    if (Symbol.iterator in properties) {\n      keyNodes[size] = SerovalObjectRecordSpecialKey.SymbolIterator;\n      const items = Array.from(properties as Iterable<unknown>);\n      valueNodes[size] = generateArrayNode(ctx, createCrossIndexedValue(ctx, items), items);\n      size++;\n    }\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: size,\n  };\n}\n\nfunction generatePlainProperties(\n  ctx: CrossParserContext,\n  properties: Record<string, unknown>,\n): SerovalPlainRecordNode {\n  const keys = Object.keys(properties);\n  const size = keys.length;\n  const keyNodes = new Array<string>(size);\n  const valueNodes = new Array<SerovalSyncNode>(size);\n  const deferredKeys = new Array<string>(size);\n  const deferredValues = new Array<unknown>(size);\n  let deferredSize = 0;\n  let nodesSize = 0;\n  let item: unknown;\n  let escaped: string;\n  for (const key of keys) {\n    item = properties[key];\n    escaped = serializeString(key);\n    if (isIterable(item)) {\n      deferredKeys[deferredSize] = escaped;\n      deferredValues[deferredSize] = item;\n      deferredSize++;\n    } else {\n      keyNodes[nodesSize] = escaped;\n      valueNodes[nodesSize] = crossParseSync(ctx, item);\n      nodesSize++;\n    }\n  }\n  for (let i = 0; i < deferredSize; i++) {\n    keyNodes[nodesSize + i] = deferredKeys[i];\n    valueNodes[nodesSize + i] = crossParseSync(ctx, deferredValues[i]);\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: size,\n  };\n}\n\nfunction generateObjectNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: Record<string, unknown>,\n  empty: boolean,\n): ObjectLikeNode {\n  return {\n    t: empty ? SerovalNodeType.NullConstructor : SerovalNodeType.Object,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: generateProperties(ctx, current),\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: getObjectFlag(current),\n  };\n}\n\nfunction generateAggregateErrorNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: AggregateError,\n): SerovalAggregateErrorNode {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options\n    ? generateProperties(ctx, options)\n    : undefined;\n  return {\n    t: SerovalNodeType.AggregateError,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: serializeString(current.message),\n    p: optionsNode,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateErrorNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: Error,\n): SerovalErrorNode {\n  const options = getErrorOptions(ctx, current);\n  const optionsNode = options\n    ? generateProperties(ctx, options)\n    : undefined;\n  return {\n    t: SerovalNodeType.Error,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: getErrorConstructorName(current),\n    m: serializeString(current.message),\n    p: optionsNode,\n    e: undefined,\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateHeadersNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: Headers,\n): SerovalHeadersNode {\n  assert(ctx.features & Feature.WebAPI, new UnsupportedTypeError(current));\n  const items: Record<string, string> = {};\n  // TS Headers not an Iterable\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: SerovalNodeType.Headers,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: generatePlainProperties(ctx, items),\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateFormDataNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: FormData,\n): SerovalFormDataNode {\n  assert(ctx.features & Feature.WebAPI, new UnsupportedTypeError(current));\n  const items: Record<string, FormDataEntryValue> = {};\n  // TS FormData isn't an Iterable sadly\n  current.forEach((value, key) => {\n    items[key] = value;\n  });\n  return {\n    t: SerovalNodeType.FormData,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: generatePlainProperties(ctx, items),\n    a: undefined,\n    f: undefined,\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction generateBoxedNode(\n  ctx: CrossParserContext,\n  id: number,\n  current: object,\n): SerovalBoxedNode {\n  return {\n    t: SerovalNodeType.Boxed,\n    i: id,\n    s: undefined,\n    l: undefined,\n    c: undefined,\n    m: undefined,\n    p: undefined,\n    e: undefined,\n    a: undefined,\n    f: crossParseSync(ctx, current.valueOf()),\n    b: undefined,\n    o: undefined,\n  };\n}\n\nfunction parseObject(\n  ctx: CrossParserContext,\n  current: object | null,\n): SerovalSyncNode {\n  if (!current) {\n    return NULL_NODE;\n  }\n  // Non-primitive values needs a reference ID\n  // mostly because the values themselves are stateful\n  const registeredID = ctx.refs.get(current);\n  if (registeredID != null) {\n    return createIndexedValueNode(registeredID);\n  }\n  const id = ctx.refs.size;\n  ctx.refs.set(current, id);\n  if (hasReferenceID(current)) {\n    return createReferenceNode(id, current);\n  }\n  // Well well well\n  if (Array.isArray(current)) {\n    return generateArrayNode(ctx, id, current);\n  }\n  // Fast path\n  switch (current.constructor) {\n    case Number:\n    case Boolean:\n    case String:\n    case BigInt:\n    case Function:\n    case Symbol:\n      return generateBoxedNode(ctx, id, current);\n    case Date:\n      return createDateNode(id, current as unknown as Date);\n    case RegExp:\n      return createRegExpNode(id, current as unknown as RegExp);\n    case ArrayBuffer:\n      return createArrayBufferNode(id, current as unknown as ArrayBuffer);\n    case Int8Array:\n    case Int16Array:\n    case Int32Array:\n    case Uint8Array:\n    case Uint16Array:\n    case Uint32Array:\n    case Uint8ClampedArray:\n    case Float32Array:\n    case Float64Array:\n      return createTypedArrayNode(ctx, id, current as unknown as TypedArrayValue);\n    case BigInt64Array:\n    case BigUint64Array:\n      return createBigIntTypedArrayNode(ctx, id, current as unknown as BigIntTypedArrayValue);\n    case DataView:\n      return createDataViewNode(ctx, id, current as unknown as DataView);\n    case Map:\n      return generateMapNode(ctx, id, current as unknown as Map<unknown, unknown>);\n    case Set:\n      return generateSetNode(ctx, id, current as unknown as Set<unknown>);\n    case Object:\n      return generateObjectNode(\n        ctx,\n        id,\n        current as unknown as Record<string, unknown>,\n        false,\n      );\n    case undefined:\n      return generateObjectNode(\n        ctx,\n        id,\n        current as unknown as Record<string, unknown>,\n        true,\n      );\n    case AggregateError:\n      // Compile-down AggregateError to Error if disabled\n      if (ctx.features & Feature.AggregateError) {\n        return generateAggregateErrorNode(ctx, id, current as unknown as AggregateError);\n      }\n      return generateErrorNode(ctx, id, current as unknown as AggregateError);\n    case Error:\n    case EvalError:\n    case RangeError:\n    case ReferenceError:\n    case SyntaxError:\n    case TypeError:\n    case URIError:\n      return generateErrorNode(ctx, id, current as unknown as Error);\n    case URL:\n      return createURLNode(ctx, id, current as unknown as URL);\n    case URLSearchParams:\n      return createURLSearchParamsNode(ctx, id, current as unknown as URLSearchParams);\n    case Headers:\n      return generateHeadersNode(ctx, id, current as unknown as Headers);\n    case FormData:\n      return generateFormDataNode(ctx, id, current as unknown as FormData);\n    default:\n      break;\n  }\n  // Slow path. We only need to handle Errors and Iterators\n  // since they have very broad implementations.\n  if (current instanceof AggregateError) {\n    if (ctx.features & Feature.AggregateError) {\n      return generateAggregateErrorNode(ctx, id, current);\n    }\n    return generateErrorNode(ctx, id, current);\n  }\n  if (current instanceof Error) {\n    return generateErrorNode(ctx, id, current);\n  }\n  // Generator functions don't have a global constructor\n  // despite existing\n  if (Symbol.iterator in current) {\n    return generateObjectNode(ctx, id, current, !!current.constructor);\n  }\n  throw new UnsupportedTypeError(current);\n}\n\nexport default function crossParseSync<T>(\n  ctx: CrossParserContext,\n  current: T,\n): SerovalSyncNode {\n  switch (typeof current) {\n    case 'boolean':\n      return current ? TRUE_NODE : FALSE_NODE;\n    case 'undefined':\n      return UNDEFINED_NODE;\n    case 'string':\n      return createStringNode(current);\n    case 'number':\n      return createNumberNode(current);\n    case 'bigint':\n      return createBigIntNode(ctx, current);\n    case 'object':\n      return parseObject(ctx, current);\n    case 'symbol':\n      return createSymbolNode(ctx, current);\n    case 'function':\n      return createFunctionNode(ctx, current);\n    default:\n      throw new UnsupportedTypeError(current);\n  }\n}\n", "import { Feature } from '../compat';\nimport { GLOBAL_CONTEXT_REFERENCES } from '../keys';\nimport { serializeString } from '../string';\n// import type { SerovalNode } from '../types';\nimport parseAsync from './async';\nimport type {\n  CrossParserContextOptions,\n  CrossSerializerContext,\n} from './context';\nimport {\n  createCrossParserContext,\n  createCrossSerializerContext,\n  createStreamingCrossParserContext,\n} from './context';\nimport crossSerializeTree, { getRefExpr, resolvePatches } from './serialize';\nimport crossParseStream from './stream';\nimport parseSync from './sync';\n\nfunction finalize(\n  ctx: CrossSerializerContext,\n  scopeId: string | undefined,\n  id: number | undefined,\n  result: string,\n): string {\n  if (id == null) {\n    return result;\n  }\n  const patches = resolvePatches(ctx);\n  const ref = getRefExpr(id);\n  const params = scopeId == null ? '' : GLOBAL_CONTEXT_REFERENCES;\n  const mainBody = patches ? result + ',' + patches : result;\n  if (params === '') {\n    return patches ? '(' + mainBody + ref + ')' : mainBody;\n  }\n  const args = scopeId == null ? '()' : '(' + GLOBAL_CONTEXT_REFERENCES + '[\"' + serializeString(scopeId) + '\"])';\n  const body = mainBody + (patches ? ref : '');\n  if (ctx.features & Feature.ArrowFunction) {\n    return '(' + params + '=>(' + body + '))' + args;\n  }\n  return '(function(' + params + '){return ' + body + '})' + args;\n}\n\nexport function crossSerialize<T>(\n  source: T,\n  options?: CrossParserContextOptions,\n): string {\n  const ctx = createCrossParserContext(options);\n  const tree = parseSync(ctx, source);\n  const serial = createCrossSerializerContext({\n    features: ctx.features,\n  });\n  const result = crossSerializeTree(serial, tree);\n  return finalize(\n    serial,\n    ctx.scopeId,\n    tree.i,\n    result,\n  );\n}\n\nexport async function crossSerializeAsync<T>(\n  source: T,\n  options?: CrossParserContextOptions,\n): Promise<string> {\n  const ctx = createCrossParserContext(options);\n  const tree = await parseAsync(ctx, source);\n  const serial = createCrossSerializerContext({\n    features: ctx.features,\n  });\n  const result = crossSerializeTree(serial, tree);\n  return finalize(\n    serial,\n    ctx.scopeId,\n    tree.i,\n    result,\n  );\n}\n\n// export interface SerovalCrossJSON {\n//   t: SerovalNode;\n//   f: number;\n// }\n\n// export function toCrossJSON<T>(\n//   source: T,\n//   options?: CrossParserContextOptions,\n// ): SerovalCrossJSON {\n//   const ctx = createCrossParserContext(options);\n//   return {\n//     t: parseSync(ctx, source),\n//     f: ctx.features,\n//   };\n// }\n\n// export async function toCrossJSONAsync<T>(\n//   source: T,\n//   options?: CrossParserContextOptions,\n// ): Promise<SerovalCrossJSON> {\n//   const ctx = createCrossParserContext(options);\n//   return {\n//     t: await parseAsync(ctx, source),\n//     f: ctx.features,\n//   };\n// }\n\n// export function compileCrossJSON(source: SerovalCrossJSON): string {\n//   const serial = createCrossSerializerContext({\n//     features: source.f,\n//   });\n//   const result = crossSerializeTree(serial, source.t);\n//   return finalize(\n//     serial,\n//     source.t.i,\n//     result,\n//   );\n// }\n\n// export function fromJSON<T>(source: SerovalJSON): T {\n//   const serial = createDeserializerContext({\n//     markedRefs: source.m,\n//   });\n//   return deserializeTree(serial, source.t) as T;\n// }\n\nexport interface CrossSerializeStreamOptions extends CrossParserContextOptions {\n  onSerialize: (data: string, initial: boolean) => void;\n  onDone?: () => void;\n}\n\nexport function crossSerializeStream<T>(\n  source: T,\n  options: CrossSerializeStreamOptions,\n): () => void {\n  const ctx = createStreamingCrossParserContext({\n    scopeId: options.scopeId,\n    refs: options.refs,\n    disabledFeatures: options.disabledFeatures,\n    onParse(node, initial) {\n      const serial = createCrossSerializerContext({\n        features: ctx.features,\n      });\n\n      options.onSerialize(\n        finalize(\n          serial,\n          ctx.scopeId,\n          node.i,\n          crossSerializeTree(serial, node),\n        ),\n        initial,\n      );\n    },\n    onDone: options.onDone,\n  });\n\n  ctx.onParse(crossParseStream(ctx, source), true);\n\n  if (ctx.pending <= 0) {\n    ctx.onDone();\n    ctx.alive = false;\n  }\n\n  return () => {\n    if (ctx.alive) {\n      ctx.alive = false;\n      ctx.onDone();\n    }\n  };\n}\n", "import { crossSerializeStream } from './cross';\nimport { serializeString } from './string';\n\nexport interface SerializerOptions {\n  globalIdentifier: string;\n  scopeId?: string;\n  disabledFeatures?: number;\n  onData: (result: string) => void;\n  onDone?: () => void;\n}\n\nexport default class Serializer {\n  private alive = true;\n\n  private flushed = false;\n\n  private done = false;\n\n  private pending = 0;\n\n  private cleanups: (() => void)[] = [];\n\n  private refs = new Map<unknown, number>();\n\n  constructor(\n    private options: SerializerOptions,\n  ) {\n  }\n\n  write(key: string, value: unknown): void {\n    if (this.alive && !this.flushed) {\n      this.pending++;\n      this.cleanups.push(crossSerializeStream(value, {\n        scopeId: this.options.scopeId,\n        refs: this.refs,\n        disabledFeatures: this.options.disabledFeatures,\n        onSerialize: (data, initial) => {\n          if (this.alive) {\n            this.options.onData(\n              initial\n                ? this.options.globalIdentifier + '[\"' + serializeString(key) + '\"]=' + data\n                : data,\n            );\n          }\n        },\n        onDone: () => {\n          if (this.alive) {\n            this.pending--;\n            if (this.pending <= 0 && this.flushed && !this.done && this.options.onDone) {\n              this.options.onDone();\n              this.done = true;\n            }\n          }\n        },\n      }));\n    }\n  }\n\n  flush(): void {\n    if (this.alive) {\n      this.flushed = true;\n      if (this.pending <= 0 && !this.done && this.options.onDone) {\n        this.options.onDone();\n        this.done = true;\n      }\n    }\n  }\n\n  close(): void {\n    if (this.alive) {\n      for (let i = 0, len = this.cleanups.length; i < len; i++) {\n        this.cleanups[i]();\n      }\n      if (!this.done && this.options.onDone) {\n        this.options.onDone();\n        this.done = true;\n      }\n      this.alive = false;\n    }\n  }\n}\n", "import { serialize } from './core/tree';\n\nexport type {\n  AsyncServerValue,\n  ServerValue,\n  PrimitiveValue,\n  CommonServerValue,\n  SemiPrimitiveValue,\n  ErrorValue,\n} from './types';\nexport { Feature } from './core/compat';\nexport { createReference } from './core/reference';\n\nexport * from './core/tree';\nexport * from './core/cross';\n\nexport { GLOBAL_CONTEXT_API_SCRIPT, getCrossReferenceHeader } from './core/keys';\n\nexport { default as Serializer } from './core/Serializer';\n\nexport default serialize;\n"],
  "mappings": "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",
  "names": ["Feature", "assignIndexedValue", "serializeArrayBuffer", "generateNodeList", "generateArrayNode", "generateMapNode", "generateSetNode", "generateProperties", "generatePlainProperties", "generateObjectNode", "generateAggregateErrorNode", "generateErrorNode", "generateHeadersNode", "generateFormDataNode", "generateBoxedNode", "parseObject", "serializeArrayBuffer", "createTypedArrayNode", "BIGINT_FLAG", "createBigIntTypedArrayNode", "createDataViewNode", "createSymbolNode", "createFunctionNode", "createBlobNode", "serializeArrayBuffer", "createFileNode", "generateNodeList", "generateArrayNode", "generateMapNode", "generateSetNode", "generateProperties", "generatePlainProperties", "generatePromiseNode", "generateObjectNode", "generateAggregateErrorNode", "generateErrorNode", "generateHeadersNode", "generateFormDataNode", "generateBoxedNode", "parseObject", "createTypedArrayNode", "createBigIntTypedArrayNode", "createDataViewNode", "createBlobNode", "createFileNode", "createSymbolNode", "createFunctionNode", "pushObjectFlag", "resolvePatches", "createAssignment", "createAddAssignment", "createSetAssignment", "createAppendAssignment", "createArrayAssign", "createObjectAssign", "assignIndexedValue", "isIndexedValueInStack", "serializeArray", "getIterableAccess", "serializeIterable", "serializeProperties", "serializeWithObjectAssign", "serializeAssignments", "serializeDictionary", "NULL_CONSTRUCTOR", "serializeNullConstructor", "serializeObject", "serializeSet", "serializeMap", "serializeAggregateError", "serializeError", "PROMISE_RESOLVE", "PROMISE_REJECT", "serializePromise", "serializeArrayBuffer", "serializeTypedArray", "serializeDate", "serializeRegExp", "serializeURL", "serializeURLSearchParams", "serializeReference", "serializeDataView", "serializeBlob", "serializeFile", "serializeHeaders", "serializeFormDataEntries", "serializeFormData", "serializeBoxed", "serializeWKSymbol", "generateNodeList", "generateArrayNode", "generateMapNode", "generateSetNode", "generateProperties", "generatePlainProperties", "generatePromiseNode", "generateObjectNode", "generateAggregateErrorNode", "generateErrorNode", "generateHeadersNode", "generateFormDataNode", "generateBoxedNode", "parseObject", "createTypedArrayNode", "createBigIntTypedArrayNode", "createDataViewNode", "createSymbolNode", "createFunctionNode", "generateNodeList", "generateArrayNode", "generateMapNode", "generateSetNode", "generateProperties", "generatePlainProperties", "generateObjectNode", "generateAggregateErrorNode", "generateErrorNode", "generateHeadersNode", "generateFormDataNode", "generateBoxedNode", "parseObject", "createTypedArrayNode", "createBigIntTypedArrayNode", "createDataViewNode", "createSymbolNode", "createFunctionNode", "finalize", "resolvePatches"]
}
