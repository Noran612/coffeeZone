"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Feature: () => Feature,
  GLOBAL_CONTEXT_API_SCRIPT: () => GLOBAL_CONTEXT_API_SCRIPT,
  Serializer: () => Serializer,
  compileJSON: () => compileJSON,
  createReference: () => createReference,
  crossSerialize: () => crossSerialize,
  crossSerializeAsync: () => crossSerializeAsync,
  crossSerializeStream: () => crossSerializeStream,
  default: () => src_default,
  deserialize: () => deserialize,
  fromJSON: () => fromJSON,
  getCrossReferenceHeader: () => getCrossReferenceHeader,
  serialize: () => serialize,
  serializeAsync: () => serializeAsync,
  toJSON: () => toJSON,
  toJSONAsync: () => toJSONAsync
});
module.exports = __toCommonJS(src_exports);

// src/core/compat.ts
var Feature = /* @__PURE__ */ ((Feature2) => {
  Feature2[Feature2["AggregateError"] = 1] = "AggregateError";
  Feature2[Feature2["ArrayPrototypeValues"] = 2] = "ArrayPrototypeValues";
  Feature2[Feature2["ArrowFunction"] = 4] = "ArrowFunction";
  Feature2[Feature2["BigInt"] = 8] = "BigInt";
  Feature2[Feature2["ErrorPrototypeStack"] = 16] = "ErrorPrototypeStack";
  Feature2[Feature2["Map"] = 32] = "Map";
  Feature2[Feature2["MethodShorthand"] = 64] = "MethodShorthand";
  Feature2[Feature2["ObjectAssign"] = 128] = "ObjectAssign";
  Feature2[Feature2["Promise"] = 256] = "Promise";
  Feature2[Feature2["Set"] = 512] = "Set";
  Feature2[Feature2["Symbol"] = 1024] = "Symbol";
  Feature2[Feature2["TypedArray"] = 2048] = "TypedArray";
  Feature2[Feature2["BigIntTypedArray"] = 4096] = "BigIntTypedArray";
  Feature2[Feature2["WebAPI"] = 8192] = "WebAPI";
  return Feature2;
})(Feature || {});
var ALL_ENABLED = 16383;

// src/core/constants.ts
var SYMBOL_STRING = {
  [0 /* AsyncIterator */]: "Symbol.asyncIterator",
  [1 /* HasInstance */]: "Symbol.hasInstance",
  [2 /* IsConcatSpreadable */]: "Symbol.isConcatSpreadable",
  [3 /* Iterator */]: "Symbol.iterator",
  [4 /* Match */]: "Symbol.match",
  [5 /* MatchAll */]: "Symbol.matchAll",
  [6 /* Replace */]: "Symbol.replace",
  [7 /* Search */]: "Symbol.search",
  [8 /* Species */]: "Symbol.species",
  [9 /* Split */]: "Symbol.split",
  [10 /* ToPrimitive */]: "Symbol.toPrimitive",
  [11 /* ToStringTag */]: "Symbol.toStringTag",
  [12 /* Unscopables */]: "Symbol.unscopables"
};
var INV_SYMBOL_REF = {
  [Symbol.asyncIterator]: 0 /* AsyncIterator */,
  [Symbol.hasInstance]: 1 /* HasInstance */,
  [Symbol.isConcatSpreadable]: 2 /* IsConcatSpreadable */,
  [Symbol.iterator]: 3 /* Iterator */,
  [Symbol.match]: 4 /* Match */,
  [Symbol.matchAll]: 5 /* MatchAll */,
  [Symbol.replace]: 6 /* Replace */,
  [Symbol.search]: 7 /* Search */,
  [Symbol.species]: 8 /* Species */,
  [Symbol.split]: 9 /* Split */,
  [Symbol.toPrimitive]: 10 /* ToPrimitive */,
  [Symbol.toStringTag]: 11 /* ToStringTag */,
  [Symbol.unscopables]: 12 /* Unscopables */
};
var SYMBOL_REF = {
  [0 /* AsyncIterator */]: Symbol.asyncIterator,
  [1 /* HasInstance */]: Symbol.hasInstance,
  [2 /* IsConcatSpreadable */]: Symbol.isConcatSpreadable,
  [3 /* Iterator */]: Symbol.iterator,
  [4 /* Match */]: Symbol.match,
  [5 /* MatchAll */]: Symbol.matchAll,
  [6 /* Replace */]: Symbol.replace,
  [7 /* Search */]: Symbol.search,
  [8 /* Species */]: Symbol.species,
  [9 /* Split */]: Symbol.split,
  [10 /* ToPrimitive */]: Symbol.toPrimitive,
  [11 /* ToStringTag */]: Symbol.toStringTag,
  [12 /* Unscopables */]: Symbol.unscopables
};
function serializeConstant(node) {
  switch (node.s) {
    case 2 /* True */:
      return "!0";
    case 3 /* False */:
      return "!1";
    case 1 /* Undefined */:
      return "void 0";
    case 0 /* Null */:
      return "null";
    case 4 /* NegativeZero */:
      return "-0";
    case 5 /* Infinity */:
      return "1/0";
    case 6 /* NegativeInfinity */:
      return "-1/0";
    case 7 /* NaN */:
      return "NaN";
    default:
      throw new Error("invariant");
  }
}
function deserializeConstant(node) {
  switch (node.s) {
    case 2 /* True */:
      return true;
    case 3 /* False */:
      return false;
    case 1 /* Undefined */:
      return void 0;
    case 0 /* Null */:
      return null;
    case 4 /* NegativeZero */:
      return -0;
    case 5 /* Infinity */:
      return Infinity;
    case 6 /* NegativeInfinity */:
      return -Infinity;
    case 7 /* NaN */:
      return NaN;
    default:
      throw new Error("invariant");
  }
}

// src/core/assert.ts
function assert(cond, error) {
  if (!cond) {
    throw error;
  }
}

// src/core/get-identifier.ts
var REF_START_CHARS = "hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_";
var REF_START_CHARS_LEN = REF_START_CHARS.length;
var REF_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_";
var REF_CHARS_LEN = REF_CHARS.length;
function getIdentifier(index) {
  let mod = index % REF_START_CHARS_LEN;
  let ref = REF_START_CHARS[mod];
  index = (index - mod) / REF_START_CHARS_LEN;
  while (index > 0) {
    mod = index % REF_CHARS_LEN;
    ref += REF_CHARS[mod];
    index = (index - mod) / REF_CHARS_LEN;
  }
  return ref;
}

// src/core/tree/context.ts
function createParserContext(options = {}) {
  return {
    reference: {
      ids: /* @__PURE__ */ new Map(),
      marked: /* @__PURE__ */ new Set()
    },
    features: ALL_ENABLED ^ (options.disabledFeatures || 0)
  };
}
function createSerializerContext(options) {
  return {
    stack: [],
    vars: [],
    assignments: [],
    reference: {
      valid: [],
      size: 0,
      marked: new Set(options.markedRefs)
    },
    features: options.features,
    flags: []
  };
}
function markRef(ctx, current) {
  ctx.reference.marked.add(current);
}
function getRefParam(ctx, index) {
  let actualIndex = ctx.reference.valid[index];
  if (actualIndex == null) {
    actualIndex = ctx.reference.size++;
    ctx.reference.valid[index] = actualIndex;
  }
  let identifier = ctx.vars[actualIndex];
  if (identifier == null) {
    identifier = getIdentifier(actualIndex);
    ctx.vars[actualIndex] = identifier;
  }
  return identifier;
}
function createIndexedValue(ctx, current) {
  const ref = ctx.reference.ids.get(current);
  if (ref == null) {
    const id = ctx.reference.ids.size;
    ctx.reference.ids.set(current, id);
    return id;
  }
  markRef(ctx, ref);
  return ref;
}
function createDeserializerContext(options) {
  return {
    values: /* @__PURE__ */ new Map(),
    refs: new Set(options.markedRefs)
  };
}

// src/core/string.ts
function serializeChar(str) {
  switch (str) {
    case '"':
      return '\\"';
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "\b":
      return "\\b";
    case "	":
      return "\\t";
    case "\f":
      return "\\f";
    case "<":
      return "\\x3C";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return void 0;
  }
}
function serializeString(str) {
  let result = "";
  let lastPos = 0;
  let replacement;
  for (let i = 0, len = str.length; i < len; i++) {
    replacement = serializeChar(str[i]);
    if (replacement) {
      result += str.slice(lastPos, i) + replacement;
      lastPos = i + 1;
    }
  }
  if (lastPos === 0) {
    result = str;
  } else {
    result += str.slice(lastPos);
  }
  return result;
}
function deserializeString(str) {
  return str.replace(/\\"/g, '"').replace(/\\\\/g, "\\").replace(/\\n/g, "\n").replace(/\\r/g, "\r").replace(/\\b/g, "\b").replace(/\\t/g, "	").replace(/\\f/g, "\f").replace(/\\x3C/g, "<").replace(/\\u2028/g, "\u2028").replace(/\\u2029/g, "\u2029");
}

// src/core/UnsupportedTypeError.ts
var { toString } = Object.prototype;
var UnsupportedTypeError = class extends Error {
  constructor(value) {
    super('Unsupported type "' + toString.call(value) + '"');
    this.value = value;
  }
};

// src/core/literals.ts
function createConstantNode(value) {
  return {
    t: 2 /* Constant */,
    i: void 0,
    s: value,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
var TRUE_NODE = createConstantNode(2 /* True */);
var FALSE_NODE = createConstantNode(3 /* False */);
var UNDEFINED_NODE = createConstantNode(1 /* Undefined */);
var NULL_NODE = createConstantNode(0 /* Null */);
var NEG_ZERO_NODE = createConstantNode(4 /* NegativeZero */);
var INFINITY_NODE = createConstantNode(5 /* Infinity */);
var NEG_INFINITY_NODE = createConstantNode(6 /* NegativeInfinity */);
var NAN_NODE = createConstantNode(7 /* NaN */);

// src/core/keys.ts
var REFERENCES_KEY = "__SEROVAL_REFS__";
var GLOBAL_CONTEXT_API = "_$";
var GLOBAL_CONTEXT_REFERENCES = "$R";
var LOCAL_CONTEXT_PROMISE_RESOLVE = "s";
var LOCAL_CONTEXT_PROMISE_REJECT = "f";
var GLOBAL_CONTEXT_PROMISE_CONSTRUCTOR = "P";
var GLOBAL_CONTEXT_PROMISE_RESOLVE = "Ps";
var GLOBAL_CONTEXT_PROMISE_REJECT = "Pf";
var LOCAL_CONTEXT_STREAM_CONTROLLER = "c";
var GLOBAL_CONTEXT_STREAM_CONSTRUCTOR = "S";
var GLOBAL_CONTEXT_STREAM_EMIT = "Se";
var GLOBAL_CONTEXT_API_SCRIPT = `self.${GLOBAL_CONTEXT_API}=self.${GLOBAL_CONTEXT_API}||{${GLOBAL_CONTEXT_PROMISE_CONSTRUCTOR}:function(s,f,p){return(p=new Promise(function(a,b){s=a,f=b})).${LOCAL_CONTEXT_PROMISE_RESOLVE}=s,p.${LOCAL_CONTEXT_PROMISE_REJECT}=f,p},uP:function(p){delete p.${LOCAL_CONTEXT_PROMISE_RESOLVE};delete p.${LOCAL_CONTEXT_PROMISE_REJECT}},${GLOBAL_CONTEXT_PROMISE_RESOLVE}:function(p,d){p.${LOCAL_CONTEXT_PROMISE_RESOLVE}(d),p.value=d,this.uP(p)},${GLOBAL_CONTEXT_PROMISE_REJECT}:function(p,d){p.${LOCAL_CONTEXT_PROMISE_REJECT}(d),this.uP(p)},uS:function(s){delete s.${LOCAL_CONTEXT_STREAM_CONTROLLER}},${GLOBAL_CONTEXT_STREAM_EMIT}:function(s,t,d,c){switch(c=s.${LOCAL_CONTEXT_STREAM_CONTROLLER},t){case 0:return c.enqueue(d);case 1:return(this.uS(s),c.error(d));case 2:return(this.uS(s),c.close())}},${GLOBAL_CONTEXT_STREAM_CONSTRUCTOR}:function(s,c){return(s=new ReadableStream({start:function(x){c=x}})).${LOCAL_CONTEXT_STREAM_CONTROLLER}=c,s}}`;
function getCrossReferenceHeader(id) {
  if (id == null) {
    return `self.${GLOBAL_CONTEXT_REFERENCES}=self.${GLOBAL_CONTEXT_REFERENCES}||[];`;
  }
  return `(self.${GLOBAL_CONTEXT_REFERENCES}=self.${GLOBAL_CONTEXT_REFERENCES}||{})["${serializeString(id)}"]=[]`;
}

// src/core/reference.ts
var REFERENCE = /* @__PURE__ */ new Map();
var INV_REFERENCE = /* @__PURE__ */ new Map();
function createReference(id, value) {
  REFERENCE.set(value, id);
  INV_REFERENCE.set(id, value);
  return value;
}
function hasReferenceID(value) {
  return REFERENCE.has(value);
}
function hasReference(id) {
  return INV_REFERENCE.has(id);
}
function getReferenceID(value) {
  assert(hasReferenceID(value), new Error("Missing reference id"));
  return REFERENCE.get(value);
}
function getReference(id) {
  assert(hasReference(id), new Error("Missing reference for id:" + id));
  return INV_REFERENCE.get(id);
}
if (typeof globalThis !== void 0) {
  Object.defineProperty(globalThis, REFERENCES_KEY, {
    value: INV_REFERENCE,
    configurable: true,
    writable: false,
    enumerable: false
  });
} else if (typeof window !== void 0) {
  Object.defineProperty(window, REFERENCES_KEY, {
    value: INV_REFERENCE,
    configurable: true,
    writable: false,
    enumerable: false
  });
} else if (typeof self !== void 0) {
  Object.defineProperty(self, REFERENCES_KEY, {
    value: INV_REFERENCE,
    configurable: true,
    writable: false,
    enumerable: false
  });
} else if (typeof global !== void 0) {
  Object.defineProperty(global, REFERENCES_KEY, {
    value: INV_REFERENCE,
    configurable: true,
    writable: false,
    enumerable: false
  });
}

// src/core/base-primitives.ts
function createNumberNode(value) {
  switch (value) {
    case Infinity:
      return INFINITY_NODE;
    case -Infinity:
      return NEG_INFINITY_NODE;
    default:
      if (value !== value) {
        return NAN_NODE;
      }
      if (Object.is(value, -0)) {
        return NEG_ZERO_NODE;
      }
      return {
        t: 0 /* Number */,
        i: void 0,
        s: value,
        l: void 0,
        c: void 0,
        m: void 0,
        p: void 0,
        e: void 0,
        a: void 0,
        f: void 0,
        b: void 0,
        o: void 0
      };
  }
}
function createStringNode(value) {
  return {
    t: 1 /* String */,
    i: void 0,
    s: serializeString(value),
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function createBigIntNode(ctx, current) {
  assert(ctx.features & 8 /* BigInt */, new UnsupportedTypeError(current));
  return {
    t: 3 /* BigInt */,
    i: void 0,
    s: "" + current,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function createIndexedValueNode(id) {
  return {
    t: 4 /* IndexedValue */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function createDateNode(id, current) {
  return {
    t: 5 /* Date */,
    i: id,
    s: current.toISOString(),
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    f: void 0,
    a: void 0,
    b: void 0,
    o: void 0
  };
}
function createRegExpNode(id, current) {
  return {
    t: 6 /* RegExp */,
    i: id,
    s: void 0,
    l: void 0,
    c: current.source,
    m: current.flags,
    p: void 0,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function createArrayBufferNode(id, current) {
  const bytes = new Uint8Array(current);
  const len = bytes.length;
  const values = new Array(len);
  for (let i = 0; i < len; i++) {
    values[i] = bytes[i];
  }
  return {
    t: 21 /* ArrayBuffer */,
    i: id,
    s: values,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function createWKSymbolNode(ctx, id, current) {
  assert(ctx.features & 1024 /* Symbol */, new UnsupportedTypeError(current));
  assert(current in INV_SYMBOL_REF, new Error("Only well-known symbols are supported."));
  return {
    t: 17 /* WKSymbol */,
    i: id,
    s: INV_SYMBOL_REF[current],
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function createReferenceNode(id, ref) {
  return {
    t: 20 /* Reference */,
    i: id,
    s: serializeString(getReferenceID(ref)),
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}

// src/core/tree/primitives.ts
function serializeArrayBuffer(ctx, current) {
  const id = createIndexedValue(ctx, current);
  if (ctx.reference.marked.has(id)) {
    return createIndexedValueNode(id);
  }
  return createArrayBufferNode(id, current);
}
function createTypedArrayNode(ctx, id, current) {
  assert(ctx.features & 2048 /* TypedArray */, new UnsupportedTypeError(current));
  return {
    t: 15 /* TypedArray */,
    i: id,
    s: void 0,
    l: current.length,
    c: current.constructor.name,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: serializeArrayBuffer(ctx, current.buffer),
    b: current.byteOffset,
    o: void 0
  };
}
var BIGINT_FLAG = 4096 /* BigIntTypedArray */ | 8 /* BigInt */;
function createBigIntTypedArrayNode(ctx, id, current) {
  assert(
    (ctx.features & BIGINT_FLAG) === BIGINT_FLAG,
    new UnsupportedTypeError(current)
  );
  return {
    t: 16 /* BigIntTypedArray */,
    i: id,
    s: void 0,
    l: current.length,
    c: current.constructor.name,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: serializeArrayBuffer(ctx, current.buffer),
    b: current.byteOffset,
    o: void 0
  };
}
function createDataViewNode(ctx, id, current) {
  return {
    t: 22 /* DataView */,
    i: id,
    s: void 0,
    l: current.byteLength,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: serializeArrayBuffer(ctx, current.buffer),
    b: current.byteOffset,
    o: void 0
  };
}
function createSymbolNode(ctx, current) {
  const id = createIndexedValue(ctx, current);
  if (ctx.reference.marked.has(id)) {
    return createIndexedValueNode(id);
  }
  if (hasReferenceID(current)) {
    return createReferenceNode(id, current);
  }
  return createWKSymbolNode(ctx, id, current);
}
function createFunctionNode(ctx, current) {
  assert(hasReferenceID(current), new Error("Cannot serialize function without reference ID."));
  const id = createIndexedValue(ctx, current);
  if (ctx.reference.marked.has(id)) {
    return createIndexedValueNode(id);
  }
  return createReferenceNode(id, current);
}

// src/core/shared.ts
function getErrorConstructorName(error) {
  if (error instanceof EvalError) {
    return "EvalError";
  }
  if (error instanceof RangeError) {
    return "RangeError";
  }
  if (error instanceof ReferenceError) {
    return "ReferenceError";
  }
  if (error instanceof SyntaxError) {
    return "SyntaxError";
  }
  if (error instanceof TypeError) {
    return "TypeError";
  }
  if (error instanceof URIError) {
    return "URIError";
  }
  return "Error";
}
function getErrorConstructor(errorName) {
  switch (errorName) {
    case "Error":
      return Error;
    case "EvalError":
      return EvalError;
    case "RangeError":
      return RangeError;
    case "ReferenceError":
      return ReferenceError;
    case "SyntaxError":
      return SyntaxError;
    case "TypeError":
      return TypeError;
    case "URIError":
      return URIError;
    default:
      throw new Error(`Unknown Error constructor "${errorName}"`);
  }
}
function getErrorOptions(ctx, error) {
  let options;
  const constructor = getErrorConstructorName(error);
  if (error.name !== constructor) {
    options = { name: error.name };
  } else if (error.constructor.name !== constructor) {
    options = { name: error.constructor.name };
  }
  const names = Object.getOwnPropertyNames(error);
  for (const name of names) {
    if (name !== "name" && name !== "message") {
      if (name === "stack") {
        if (ctx.features & 16 /* ErrorPrototypeStack */) {
          options = options || {};
          options[name] = error[name];
        }
      } else {
        options = options || {};
        options[name] = error[name];
      }
    }
  }
  return options;
}
function isIterable(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (Array.isArray(value)) {
    return false;
  }
  switch (value.constructor) {
    case Map:
    case Set:
    case Int8Array:
    case Int16Array:
    case Int32Array:
    case Uint8Array:
    case Uint16Array:
    case Uint32Array:
    case Uint8ClampedArray:
    case Float32Array:
    case Float64Array:
    case BigInt64Array:
    case BigUint64Array:
      return false;
    default:
      break;
  }
  return Symbol.iterator in value;
}
function getTypedArrayConstructor(name) {
  switch (name) {
    case "Int8Array":
      return Int8Array;
    case "Int16Array":
      return Int16Array;
    case "Int32Array":
      return Int32Array;
    case "Uint8Array":
      return Uint8Array;
    case "Uint16Array":
      return Uint16Array;
    case "Uint32Array":
      return Uint32Array;
    case "Uint8ClampedArray":
      return Uint8ClampedArray;
    case "Float32Array":
      return Float32Array;
    case "Float64Array":
      return Float64Array;
    case "BigInt64Array":
      return BigInt64Array;
    case "BigUint64Array":
      return BigUint64Array;
    default:
      throw new Error(`Unknown TypedArray "${name}"`);
  }
}
var IDENTIFIER_CHECK = /^[$A-Z_][0-9A-Z_$]*$/i;
function isValidIdentifier(name) {
  const char = name[0];
  return (char === "$" || char === "_" || char >= "A" && char <= "Z" || char >= "a" && char <= "z") && IDENTIFIER_CHECK.test(name);
}
function getObjectFlag(obj) {
  if (Object.isFrozen(obj)) {
    return 3 /* Frozen */;
  }
  if (Object.isSealed(obj)) {
    return 2 /* Sealed */;
  }
  if (Object.isExtensible(obj)) {
    return 0 /* None */;
  }
  return 1 /* NonExtensible */;
}

// src/core/tree/web-api.ts
async function createBlobNode(ctx, id, current) {
  assert(ctx.features & 8192 /* WebAPI */, new UnsupportedTypeError(current));
  return {
    t: 23 /* Blob */,
    i: id,
    s: void 0,
    l: void 0,
    c: serializeString(current.type),
    m: void 0,
    p: void 0,
    e: void 0,
    f: serializeArrayBuffer(ctx, await current.arrayBuffer()),
    a: void 0,
    b: void 0,
    o: void 0
  };
}
async function createFileNode(ctx, id, current) {
  assert(ctx.features & 8192 /* WebAPI */, new UnsupportedTypeError(current));
  return {
    t: 24 /* File */,
    i: id,
    s: void 0,
    l: void 0,
    c: serializeString(current.type),
    m: serializeString(current.name),
    p: void 0,
    e: void 0,
    f: serializeArrayBuffer(ctx, await current.arrayBuffer()),
    a: void 0,
    b: current.lastModified,
    o: void 0
  };
}

// src/core/web-api.ts
function createURLNode(ctx, id, current) {
  assert(ctx.features & 8192 /* WebAPI */, new UnsupportedTypeError(current));
  return {
    t: 18 /* URL */,
    i: id,
    s: serializeString(current.href),
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    f: void 0,
    a: void 0,
    b: void 0,
    o: void 0
  };
}
function createURLSearchParamsNode(ctx, id, current) {
  assert(ctx.features & 8192 /* WebAPI */, new UnsupportedTypeError(current));
  return {
    t: 19 /* URLSearchParams */,
    i: id,
    s: serializeString(current.toString()),
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    f: void 0,
    a: void 0,
    b: void 0,
    o: void 0
  };
}

// src/core/promise-to-result.ts
async function promiseToResult(current) {
  try {
    return [1, await current];
  } catch (e) {
    return [0, e];
  }
}

// src/core/tree/async.ts
async function generateNodeList(ctx, current) {
  const size = current.length;
  const nodes = new Array(size);
  const deferred = new Array(size);
  let item;
  for (let i = 0; i < size; i++) {
    if (i in current) {
      item = current[i];
      if (isIterable(item)) {
        deferred[i] = item;
      } else {
        nodes[i] = await parseAsync(ctx, item);
      }
    }
  }
  for (let i = 0; i < size; i++) {
    if (i in deferred) {
      nodes[i] = await parseAsync(ctx, deferred[i]);
    }
  }
  return nodes;
}
async function generateArrayNode(ctx, id, current) {
  return {
    t: 9 /* Array */,
    i: id,
    s: void 0,
    l: current.length,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: await generateNodeList(ctx, current),
    f: void 0,
    b: void 0,
    o: getObjectFlag(current)
  };
}
async function generateMapNode(ctx, id, current) {
  assert(ctx.features & 32 /* Map */, new UnsupportedTypeError(current));
  const len = current.size;
  const keyNodes = new Array(len);
  const valueNodes = new Array(len);
  const deferredKey = new Array(len);
  const deferredValue = new Array(len);
  let deferredSize = 0;
  let nodeSize = 0;
  for (const [key, value] of current.entries()) {
    if (isIterable(key) || isIterable(value)) {
      deferredKey[deferredSize] = key;
      deferredValue[deferredSize] = value;
      deferredSize++;
    } else {
      keyNodes[nodeSize] = await parseAsync(ctx, key);
      valueNodes[nodeSize] = await parseAsync(ctx, value);
      nodeSize++;
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    keyNodes[nodeSize + i] = await parseAsync(ctx, deferredKey[i]);
    valueNodes[nodeSize + i] = await parseAsync(ctx, deferredValue[i]);
  }
  return {
    t: 8 /* Map */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: { k: keyNodes, v: valueNodes, s: len },
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
async function generateSetNode(ctx, id, current) {
  assert(ctx.features & 512 /* Set */, new UnsupportedTypeError(current));
  const len = current.size;
  const nodes = new Array(len);
  const deferred = new Array(len);
  let deferredSize = 0;
  let nodeSize = 0;
  for (const item of current.keys()) {
    if (isIterable(item)) {
      deferred[deferredSize++] = item;
    } else {
      nodes[nodeSize++] = await parseAsync(ctx, item);
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    nodes[nodeSize + i] = await parseAsync(ctx, deferred[i]);
  }
  return {
    t: 7 /* Set */,
    i: id,
    s: void 0,
    l: len,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: nodes,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
async function generateProperties(ctx, properties) {
  const keys = Object.keys(properties);
  let size = keys.length;
  const keyNodes = new Array(size);
  const valueNodes = new Array(size);
  const deferredKeys = new Array(size);
  const deferredValues = new Array(size);
  let deferredSize = 0;
  let nodesSize = 0;
  let item;
  let escaped;
  for (const key of keys) {
    item = properties[key];
    escaped = serializeString(key);
    if (isIterable(item)) {
      deferredKeys[deferredSize] = escaped;
      deferredValues[deferredSize] = item;
      deferredSize++;
    } else {
      keyNodes[nodesSize] = escaped;
      valueNodes[nodesSize] = await parseAsync(ctx, item);
      nodesSize++;
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    keyNodes[nodesSize + i] = deferredKeys[i];
    valueNodes[nodesSize + i] = await parseAsync(ctx, deferredValues[i]);
  }
  if (ctx.features & 1024 /* Symbol */) {
    if (Symbol.iterator in properties) {
      keyNodes[size] = 0 /* SymbolIterator */;
      const items = Array.from(properties);
      valueNodes[size] = await generateArrayNode(
        ctx,
        createIndexedValue(ctx, items),
        items
      );
      size++;
    }
  }
  return {
    k: keyNodes,
    v: valueNodes,
    s: size
  };
}
async function generatePlainProperties(ctx, properties) {
  const keys = Object.keys(properties);
  const size = keys.length;
  const keyNodes = new Array(size);
  const valueNodes = new Array(size);
  const deferredKeys = new Array(size);
  const deferredValues = new Array(size);
  let deferredSize = 0;
  let nodesSize = 0;
  let item;
  let escaped;
  for (const key of keys) {
    item = properties[key];
    escaped = serializeString(key);
    if (isIterable(item)) {
      deferredKeys[deferredSize] = escaped;
      deferredValues[deferredSize] = item;
      deferredSize++;
    } else {
      keyNodes[nodesSize] = escaped;
      valueNodes[nodesSize] = await parseAsync(ctx, item);
      nodesSize++;
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    keyNodes[nodesSize + i] = deferredKeys[i];
    valueNodes[nodesSize + i] = await parseAsync(ctx, deferredValues[i]);
  }
  return {
    k: keyNodes,
    v: valueNodes,
    s: size
  };
}
async function generatePromiseNode(ctx, id, current) {
  assert(ctx.features & 256 /* Promise */, new UnsupportedTypeError(current));
  const [status, result] = await promiseToResult(current);
  return {
    t: 12 /* Promise */,
    i: id,
    s: status,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: await parseAsync(ctx, result),
    b: void 0,
    o: void 0
  };
}
async function generateObjectNode(ctx, id, current, empty) {
  return {
    t: empty ? 11 /* NullConstructor */ : 10 /* Object */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: await generateProperties(ctx, current),
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: getObjectFlag(current)
  };
}
async function generateAggregateErrorNode(ctx, id, current) {
  const options = getErrorOptions(ctx, current);
  const optionsNode = options ? await generateProperties(ctx, options) : void 0;
  return {
    t: 14 /* AggregateError */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: serializeString(current.message),
    p: optionsNode,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
async function generateErrorNode(ctx, id, current) {
  const options = getErrorOptions(ctx, current);
  const optionsNode = options ? await generateProperties(ctx, options) : void 0;
  return {
    t: 13 /* Error */,
    i: id,
    s: void 0,
    l: void 0,
    c: getErrorConstructorName(current),
    m: serializeString(current.message),
    p: optionsNode,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
async function generateHeadersNode(ctx, id, current) {
  assert(ctx.features & 8192 /* WebAPI */, new UnsupportedTypeError(current));
  const items = {};
  current.forEach((value, key) => {
    items[key] = value;
  });
  return {
    t: 25 /* Headers */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: await generatePlainProperties(ctx, items),
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
async function generateFormDataNode(ctx, id, current) {
  assert(ctx.features & 8192 /* WebAPI */, new UnsupportedTypeError(current));
  const items = {};
  current.forEach((value, key) => {
    items[key] = value;
  });
  return {
    t: 26 /* FormData */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: await generatePlainProperties(ctx, items),
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
async function generateBoxedNode(ctx, id, current) {
  return {
    t: 27 /* Boxed */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: await parseAsync(ctx, current.valueOf()),
    b: void 0,
    o: void 0
  };
}
async function parseObject(ctx, current) {
  if (!current) {
    return NULL_NODE;
  }
  const id = createIndexedValue(ctx, current);
  if (ctx.reference.marked.has(id)) {
    return createIndexedValueNode(id);
  }
  if (hasReferenceID(current)) {
    return createReferenceNode(id, current);
  }
  if (Array.isArray(current)) {
    return generateArrayNode(ctx, id, current);
  }
  switch (current.constructor) {
    case Number:
    case Boolean:
    case String:
    case BigInt:
    case Function:
    case Symbol:
      return generateBoxedNode(ctx, id, current);
    case Date:
      return createDateNode(id, current);
    case RegExp:
      return createRegExpNode(id, current);
    case Promise:
      return generatePromiseNode(ctx, id, current);
    case ArrayBuffer:
      return createArrayBufferNode(id, current);
    case Int8Array:
    case Int16Array:
    case Int32Array:
    case Uint8Array:
    case Uint16Array:
    case Uint32Array:
    case Uint8ClampedArray:
    case Float32Array:
    case Float64Array:
      return createTypedArrayNode(ctx, id, current);
    case BigInt64Array:
    case BigUint64Array:
      return createBigIntTypedArrayNode(ctx, id, current);
    case DataView:
      return createDataViewNode(ctx, id, current);
    case Map:
      return generateMapNode(
        ctx,
        id,
        current
      );
    case Set:
      return generateSetNode(
        ctx,
        id,
        current
      );
    case Object:
      return generateObjectNode(
        ctx,
        id,
        current,
        false
      );
    case void 0:
      return generateObjectNode(
        ctx,
        id,
        current,
        true
      );
    case AggregateError:
      if (ctx.features & 1 /* AggregateError */) {
        return generateAggregateErrorNode(ctx, id, current);
      }
      return generateErrorNode(ctx, id, current);
    case Error:
    case EvalError:
    case RangeError:
    case ReferenceError:
    case SyntaxError:
    case TypeError:
    case URIError:
      return generateErrorNode(ctx, id, current);
    case URL:
      return createURLNode(ctx, id, current);
    case URLSearchParams:
      return createURLSearchParamsNode(ctx, id, current);
    case Blob:
      return createBlobNode(ctx, id, current);
    case File:
      return createFileNode(ctx, id, current);
    case Headers:
      return generateHeadersNode(ctx, id, current);
    case FormData:
      return generateFormDataNode(ctx, id, current);
    default:
      break;
  }
  if (current instanceof AggregateError) {
    if (ctx.features & 1 /* AggregateError */) {
      return generateAggregateErrorNode(ctx, id, current);
    }
    return generateErrorNode(ctx, id, current);
  }
  if (current instanceof Error) {
    return generateErrorNode(ctx, id, current);
  }
  if (current instanceof Promise) {
    return generatePromiseNode(ctx, id, current);
  }
  if (Symbol.iterator in current) {
    return generateObjectNode(ctx, id, current, !!current.constructor);
  }
  throw new UnsupportedTypeError(current);
}
async function parseAsync(ctx, current) {
  switch (typeof current) {
    case "boolean":
      return current ? TRUE_NODE : FALSE_NODE;
    case "undefined":
      return UNDEFINED_NODE;
    case "string":
      return createStringNode(current);
    case "number":
      return createNumberNode(current);
    case "bigint":
      return createBigIntNode(ctx, current);
    case "object":
      return parseObject(ctx, current);
    case "symbol":
      return createSymbolNode(ctx, current);
    case "function":
      return createFunctionNode(ctx, current);
    default:
      throw new UnsupportedTypeError(current);
  }
}

// src/core/tree/deserialize.ts
function applyObjectFlag(obj, flag) {
  switch (flag) {
    case 3 /* Frozen */:
      return Object.freeze(obj);
    case 1 /* NonExtensible */:
      return Object.preventExtensions(obj);
    case 2 /* Sealed */:
      return Object.seal(obj);
    default:
      return obj;
  }
}
function assignIndexedValue(ctx, index, value) {
  if (ctx.refs.has(index)) {
    ctx.values.set(index, value);
  }
  return value;
}
function deserializeArray(ctx, node) {
  const len = node.l;
  const result = assignIndexedValue(
    ctx,
    node.i,
    new Array(len)
  );
  let item;
  for (let i = 0; i < len; i++) {
    item = node.a[i];
    if (item) {
      result[i] = deserializeTree(ctx, item);
    }
  }
  applyObjectFlag(result, node.o);
  return result;
}
function deserializeProperties(ctx, node, result) {
  const len = node.s;
  if (len) {
    let key;
    let value;
    const keys = node.k;
    const vals = node.v;
    for (let i = 0; i < len; i++) {
      key = keys[i];
      value = deserializeTree(ctx, vals[i]);
      switch (key) {
        case 0 /* SymbolIterator */:
          {
            const current = value;
            result[Symbol.iterator] = () => current.values();
          }
          break;
        default:
          result[deserializeString(key)] = value;
          break;
      }
    }
  }
  return result;
}
function deserializeObject(ctx, node) {
  const result = assignIndexedValue(
    ctx,
    node.i,
    node.t === 10 /* Object */ ? {} : /* @__PURE__ */ Object.create(null)
  );
  deserializeProperties(ctx, node.p, result);
  applyObjectFlag(result, node.o);
  return result;
}
function deserializeSet(ctx, node) {
  const result = assignIndexedValue(ctx, node.i, /* @__PURE__ */ new Set());
  const items = node.a;
  for (let i = 0, len = node.l; i < len; i++) {
    result.add(deserializeTree(ctx, items[i]));
  }
  return result;
}
function deserializeMap(ctx, node) {
  const result = assignIndexedValue(
    ctx,
    node.i,
    /* @__PURE__ */ new Map()
  );
  const keys = node.e.k;
  const vals = node.e.v;
  for (let i = 0, len = node.e.s; i < len; i++) {
    result.set(
      deserializeTree(ctx, keys[i]),
      deserializeTree(ctx, vals[i])
    );
  }
  return result;
}
function deserializeDictionary(ctx, node, result) {
  if (node.p) {
    const fields = deserializeProperties(ctx, node.p, {});
    Object.assign(result, fields);
  }
  return result;
}
function deserializeAggregateError(ctx, node) {
  const result = assignIndexedValue(
    ctx,
    node.i,
    new AggregateError([], deserializeString(node.m))
  );
  return deserializeDictionary(ctx, node, result);
}
function deserializeError(ctx, node) {
  const ErrorConstructor = getErrorConstructor(node.c);
  const result = assignIndexedValue(ctx, node.i, new ErrorConstructor(deserializeString(node.m)));
  return deserializeDictionary(ctx, node, result);
}
function createDeferred() {
  let resolve;
  let reject;
  return {
    resolve(v) {
      resolve(v);
    },
    reject(v) {
      reject(v);
    },
    promise: new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    })
  };
}
async function deserializePromise(ctx, node) {
  const deferred = createDeferred();
  const result = assignIndexedValue(ctx, node.i, deferred.promise);
  const deserialized = deserializeTree(ctx, node.f);
  if (node.s) {
    deferred.resolve(deserialized);
  } else {
    deferred.reject(deserialized);
  }
  return result;
}
function deserializeArrayBuffer(ctx, node) {
  const bytes = new Uint8Array(node.s);
  const result = assignIndexedValue(ctx, node.i, bytes.buffer);
  return result;
}
function deserializeTypedArray(ctx, node) {
  const TypedArray = getTypedArrayConstructor(node.c);
  const source = deserializeTree(ctx, node.f);
  const result = assignIndexedValue(ctx, node.i, new TypedArray(
    source,
    node.b,
    node.l
  ));
  return result;
}
function deserializeDate(ctx, node) {
  return assignIndexedValue(ctx, node.i, new Date(node.s));
}
function deserializeRegExp(ctx, node) {
  return assignIndexedValue(ctx, node.i, new RegExp(node.c, node.m));
}
function deserializeURL(ctx, node) {
  return assignIndexedValue(ctx, node.i, new URL(deserializeString(node.s)));
}
function deserializeURLSearchParams(ctx, node) {
  return assignIndexedValue(ctx, node.i, new URLSearchParams(deserializeString(node.s)));
}
function deserializeReference(ctx, node) {
  return assignIndexedValue(ctx, node.i, getReference(deserializeString(node.s)));
}
function deserializeDataView(ctx, node) {
  const source = deserializeTree(ctx, node.f);
  const result = assignIndexedValue(ctx, node.i, new DataView(
    source,
    node.b,
    node.l
  ));
  return result;
}
function deserializeBlob(ctx, node) {
  const source = deserializeTree(ctx, node.f);
  const result = assignIndexedValue(ctx, node.i, new Blob(
    [source],
    { type: deserializeString(node.c) }
  ));
  return result;
}
function deserializeFile(ctx, node) {
  const source = deserializeTree(ctx, node.f);
  const result = assignIndexedValue(ctx, node.i, new File(
    [source],
    deserializeString(node.m),
    { type: deserializeString(node.c), lastModified: node.b }
  ));
  return result;
}
function deserializeHeaders(ctx, node) {
  const result = assignIndexedValue(ctx, node.i, new Headers());
  const keys = node.e.k;
  const vals = node.e.v;
  for (let i = 0, len = node.e.s; i < len; i++) {
    result.set(
      deserializeString(keys[i]),
      deserializeTree(ctx, vals[i])
    );
  }
  return result;
}
function deserializeFormData(ctx, node) {
  const result = assignIndexedValue(ctx, node.i, new FormData());
  const keys = node.e.k;
  const vals = node.e.v;
  for (let i = 0, len = node.e.s; i < len; i++) {
    result.set(
      deserializeString(keys[i]),
      deserializeTree(ctx, vals[i])
    );
  }
  return result;
}
function deserializeBoxed(ctx, node) {
  return assignIndexedValue(
    ctx,
    node.i,
    Object(deserializeTree(ctx, node.f))
  );
}
function deserializeTree(ctx, node) {
  switch (node.t) {
    case 2 /* Constant */:
      return deserializeConstant(node);
    case 0 /* Number */:
      return node.s;
    case 1 /* String */:
      return deserializeString(node.s);
    case 3 /* BigInt */:
      return BigInt(node.s);
    case 4 /* IndexedValue */:
      return ctx.values.get(node.i);
    case 9 /* Array */:
      return deserializeArray(ctx, node);
    case 10 /* Object */:
    case 11 /* NullConstructor */:
      return deserializeObject(ctx, node);
    case 5 /* Date */:
      return deserializeDate(ctx, node);
    case 6 /* RegExp */:
      return deserializeRegExp(ctx, node);
    case 7 /* Set */:
      return deserializeSet(ctx, node);
    case 8 /* Map */:
      return deserializeMap(ctx, node);
    case 21 /* ArrayBuffer */:
      return deserializeArrayBuffer(ctx, node);
    case 16 /* BigIntTypedArray */:
    case 15 /* TypedArray */:
      return deserializeTypedArray(ctx, node);
    case 22 /* DataView */:
      return deserializeDataView(ctx, node);
    case 14 /* AggregateError */:
      return deserializeAggregateError(ctx, node);
    case 13 /* Error */:
      return deserializeError(ctx, node);
    case 12 /* Promise */:
      return deserializePromise(ctx, node);
    case 17 /* WKSymbol */:
      return SYMBOL_REF[node.s];
    case 18 /* URL */:
      return deserializeURL(ctx, node);
    case 19 /* URLSearchParams */:
      return deserializeURLSearchParams(ctx, node);
    case 20 /* Reference */:
      return deserializeReference(ctx, node);
    case 23 /* Blob */:
      return deserializeBlob(ctx, node);
    case 24 /* File */:
      return deserializeFile(ctx, node);
    case 25 /* Headers */:
      return deserializeHeaders(ctx, node);
    case 26 /* FormData */:
      return deserializeFormData(ctx, node);
    case 27 /* Boxed */:
      return deserializeBoxed(ctx, node);
    default:
      throw new Error("invariant");
  }
}

// src/core/assignments.ts
function getAssignmentExpression(assignment) {
  switch (assignment.t) {
    case "index":
      return assignment.s + "=" + assignment.v;
    case "set":
      return assignment.s + ".set(" + assignment.k + "," + assignment.v + ")";
    case "add":
      return assignment.s + ".add(" + assignment.v + ")";
    case "append":
      return assignment.s + ".append(" + assignment.k + "," + assignment.v + ")";
    default:
      return "";
  }
}
var OBJECT_FLAG_CONSTRUCTOR = {
  [3 /* Frozen */]: "Object.freeze",
  [2 /* Sealed */]: "Object.seal",
  [1 /* NonExtensible */]: "Object.preventExtensions",
  [0 /* None */]: void 0
};
function mergeAssignments(assignments) {
  const newAssignments = [];
  let current = assignments[0];
  let prev = current;
  let item;
  for (let i = 1, len = assignments.length; i < len; i++) {
    item = assignments[i];
    if (item.t === prev.t) {
      switch (item.t) {
        case "index":
          if (item.v === prev.v) {
            current = {
              t: "index",
              s: item.s,
              k: void 0,
              v: getAssignmentExpression(current)
            };
          } else {
            newAssignments.push(current);
            current = item;
          }
          break;
        case "set":
          if (item.s === prev.s) {
            current = {
              t: "set",
              s: getAssignmentExpression(current),
              k: item.k,
              v: item.v
            };
          } else {
            newAssignments.push(current);
            current = item;
          }
          break;
        case "add":
          if (item.s === prev.s) {
            current = {
              t: "add",
              s: getAssignmentExpression(current),
              k: void 0,
              v: item.v
            };
          } else {
            newAssignments.push(current);
            current = item;
          }
          break;
        case "append":
          newAssignments.push(current);
          current = item;
          break;
        default:
          break;
      }
    } else {
      newAssignments.push(current);
      current = item;
    }
    prev = item;
  }
  newAssignments.push(current);
  return newAssignments;
}
function resolveAssignments(assignments) {
  if (assignments.length) {
    let result = "";
    const merged = mergeAssignments(assignments);
    for (let i = 0, len = merged.length; i < len; i++) {
      result += getAssignmentExpression(merged[i]) + ",";
    }
    return result;
  }
  return void 0;
}
function resolveFlags(flags) {
  let result = "";
  for (let i = 0, len = flags.length; i < len; i++) {
    const flag = flags[i];
    result += OBJECT_FLAG_CONSTRUCTOR[flag.type] + "(" + flag.value + "),";
  }
  return result;
}

// src/core/tree/serialize.ts
function pushObjectFlag(ctx, flag, id) {
  if (flag !== 0 /* None */) {
    markRef(ctx, id);
    ctx.flags.push({
      type: flag,
      value: getRefParam(ctx, id)
    });
  }
}
function resolvePatches(ctx) {
  const assignments = resolveAssignments(ctx.assignments);
  const flags = resolveFlags(ctx.flags);
  if (assignments) {
    if (flags) {
      return assignments + flags;
    }
    return assignments;
  }
  return flags;
}
function createAssignment(ctx, source, value) {
  ctx.assignments.push({
    t: "index",
    s: source,
    k: void 0,
    v: value
  });
}
function createAddAssignment(ctx, ref, value) {
  ctx.assignments.push({
    t: "add",
    s: getRefParam(ctx, ref),
    k: void 0,
    v: value
  });
}
function createSetAssignment(ctx, ref, key, value) {
  ctx.assignments.push({
    t: "set",
    s: getRefParam(ctx, ref),
    k: key,
    v: value
  });
}
function createAppendAssignment(ctx, ref, key, value) {
  ctx.assignments.push({
    t: "append",
    s: getRefParam(ctx, ref),
    k: key,
    v: value
  });
}
function createArrayAssign(ctx, ref, index, value) {
  createAssignment(ctx, getRefParam(ctx, ref) + "[" + index + "]", value);
}
function createObjectAssign(ctx, ref, key, value) {
  markRef(ctx, ref);
  createAssignment(ctx, getRefParam(ctx, ref) + "." + key, value);
}
function assignIndexedValue2(ctx, index, value) {
  if (ctx.reference.marked.has(index)) {
    return getRefParam(ctx, index) + "=" + value;
  }
  return value;
}
function isIndexedValueInStack(ctx, node) {
  return node.t === 4 /* IndexedValue */ && ctx.stack.includes(node.i);
}
function serializeArray(ctx, node) {
  const id = node.i;
  ctx.stack.push(id);
  let values = "";
  let item;
  let isHoley = false;
  const list = node.a;
  for (let i = 0, len = node.l; i < len; i++) {
    if (i !== 0) {
      values += ",";
    }
    item = list[i];
    if (item) {
      if (isIndexedValueInStack(ctx, item)) {
        markRef(ctx, id);
        createArrayAssign(ctx, id, i, getRefParam(ctx, item.i));
        isHoley = true;
      } else {
        values += serializeTree(ctx, item);
        isHoley = false;
      }
    } else {
      isHoley = true;
    }
  }
  ctx.stack.pop();
  pushObjectFlag(ctx, node.o, node.i);
  return assignIndexedValue2(ctx, id, "[" + values + (isHoley ? ",]" : "]"));
}
function getIterableAccess(ctx) {
  return ctx.features & 2 /* ArrayPrototypeValues */ ? ".values()" : "[Symbol.iterator]()";
}
function serializeIterable(ctx, node) {
  const parent = ctx.stack;
  ctx.stack = [];
  let serialized = serializeTree(ctx, node) + getIterableAccess(ctx);
  ctx.stack = parent;
  if (ctx.features & 4 /* ArrowFunction */) {
    serialized = "[Symbol.iterator]:()=>" + serialized;
  } else if (ctx.features & 64 /* MethodShorthand */) {
    serialized = "[Symbol.iterator](){return " + serialized + "}";
  } else {
    serialized = "[Symbol.iterator]:function(){return " + serialized + "}";
  }
  return serialized;
}
function serializeProperties(ctx, sourceID, node) {
  const len = node.s;
  if (len === 0) {
    return "{}";
  }
  let result = "";
  ctx.stack.push(sourceID);
  let key;
  let val;
  let check;
  let isIdentifier;
  let refParam;
  let hasPrev = false;
  const keys = node.k;
  const values = node.v;
  for (let i = 0; i < len; i++) {
    key = keys[i];
    val = values[i];
    switch (key) {
      case 0 /* SymbolIterator */:
        result += (hasPrev ? "," : "") + serializeIterable(ctx, val);
        hasPrev = true;
        break;
      default:
        check = Number(key);
        isIdentifier = check >= 0 || isValidIdentifier(key);
        if (isIndexedValueInStack(ctx, val)) {
          refParam = getRefParam(ctx, val.i);
          markRef(ctx, sourceID);
          if (isIdentifier && Number.isNaN(check)) {
            createObjectAssign(ctx, sourceID, key, refParam);
          } else {
            createArrayAssign(ctx, sourceID, isIdentifier ? key : '"' + key + '"', refParam);
          }
        } else {
          result += (hasPrev ? "," : "") + (isIdentifier ? key : '"' + key + '"') + ":" + serializeTree(ctx, val);
          hasPrev = true;
        }
        break;
    }
  }
  ctx.stack.pop();
  return "{" + result + "}";
}
function serializeWithObjectAssign(ctx, value, id, serialized) {
  const fields = serializeProperties(ctx, id, value);
  if (fields !== "{}") {
    return "Object.assign(" + serialized + "," + fields + ")";
  }
  return serialized;
}
function serializeAssignments(ctx, sourceID, node) {
  ctx.stack.push(sourceID);
  const mainAssignments = [];
  let key;
  let value;
  let parentAssignment;
  const keys = node.k;
  const values = node.v;
  for (let i = 0, len = node.s; i < len; i++) {
    key = keys[i];
    value = values[i];
    switch (key) {
      case 0 /* SymbolIterator */:
        {
          const parent = ctx.stack;
          ctx.stack = [];
          const serialized = serializeTree(ctx, value) + getIterableAccess(ctx);
          ctx.stack = parent;
          parentAssignment = ctx.assignments;
          ctx.assignments = mainAssignments;
          createArrayAssign(
            ctx,
            sourceID,
            "Symbol.iterator",
            ctx.features & 4 /* ArrowFunction */ ? "()=>" + serialized : "function(){return " + serialized + "}"
          );
          ctx.assignments = parentAssignment;
        }
        break;
      default: {
        const serialized = serializeTree(ctx, value);
        const check = Number(key);
        const isIdentifier = check >= 0 || isValidIdentifier(key);
        if (isIndexedValueInStack(ctx, value)) {
          if (isIdentifier && Number.isNaN(check)) {
            createObjectAssign(ctx, sourceID, key, serialized);
          } else {
            createArrayAssign(ctx, sourceID, isIdentifier ? key : '"' + key + '"', serialized);
          }
        } else {
          parentAssignment = ctx.assignments;
          ctx.assignments = mainAssignments;
          if (isIdentifier && Number.isNaN(check)) {
            createObjectAssign(ctx, sourceID, key, serialized);
          } else {
            createArrayAssign(ctx, sourceID, isIdentifier ? key : '"' + key + '"', serialized);
          }
          ctx.assignments = parentAssignment;
        }
      }
    }
  }
  ctx.stack.pop();
  return resolveAssignments(mainAssignments);
}
function serializeDictionary(ctx, i, p, init) {
  if (p) {
    if (ctx.features & 128 /* ObjectAssign */) {
      init = serializeWithObjectAssign(ctx, p, i, init);
    } else {
      markRef(ctx, i);
      const assignments = serializeAssignments(ctx, i, p);
      if (assignments) {
        return "(" + assignIndexedValue2(ctx, i, init) + "," + assignments + getRefParam(ctx, i) + ")";
      }
    }
  }
  return assignIndexedValue2(ctx, i, init);
}
var NULL_CONSTRUCTOR = "Object.create(null)";
function serializeNullConstructor(ctx, node) {
  pushObjectFlag(ctx, node.o, node.i);
  return serializeDictionary(ctx, node.i, node.p, NULL_CONSTRUCTOR);
}
function serializeObject(ctx, node) {
  pushObjectFlag(ctx, node.o, node.i);
  return assignIndexedValue2(ctx, node.i, serializeProperties(ctx, node.i, node.p));
}
function serializeSet(ctx, node) {
  let serialized = "new Set";
  const size = node.l;
  const id = node.i;
  if (size) {
    let result = "";
    let item;
    let hasPrev = false;
    const items = node.a;
    ctx.stack.push(id);
    for (let i = 0; i < size; i++) {
      item = items[i];
      if (isIndexedValueInStack(ctx, item)) {
        markRef(ctx, id);
        createAddAssignment(ctx, id, getRefParam(ctx, item.i));
      } else {
        result += (hasPrev ? "," : "") + serializeTree(ctx, item);
        hasPrev = true;
      }
    }
    ctx.stack.pop();
    if (result) {
      serialized += "([" + result + "])";
    }
  }
  return assignIndexedValue2(ctx, id, serialized);
}
function serializeMap(ctx, node) {
  let serialized = "new Map";
  const size = node.e.s;
  const id = node.i;
  if (size) {
    let result = "";
    let key;
    let val;
    let keyRef;
    let valueRef;
    let parent;
    let hasPrev = false;
    const keys = node.e.k;
    const vals = node.e.v;
    ctx.stack.push(id);
    for (let i = 0; i < size; i++) {
      key = keys[i];
      val = vals[i];
      if (isIndexedValueInStack(ctx, key)) {
        keyRef = getRefParam(ctx, id);
        markRef(ctx, id);
        if (isIndexedValueInStack(ctx, val)) {
          valueRef = getRefParam(ctx, val.i);
          createSetAssignment(ctx, id, keyRef, valueRef);
        } else {
          parent = ctx.stack;
          ctx.stack = [];
          createSetAssignment(ctx, id, keyRef, serializeTree(ctx, val));
          ctx.stack = parent;
        }
      } else if (isIndexedValueInStack(ctx, val)) {
        valueRef = getRefParam(ctx, val.i);
        markRef(ctx, id);
        parent = ctx.stack;
        ctx.stack = [];
        createSetAssignment(ctx, id, serializeTree(ctx, key), valueRef);
        ctx.stack = parent;
      } else {
        result += (hasPrev ? ",[" : "[") + serializeTree(ctx, key) + "," + serializeTree(ctx, val) + "]";
        hasPrev = true;
      }
    }
    ctx.stack.pop();
    if (result) {
      serialized += "([" + result + "])";
    }
  }
  return assignIndexedValue2(ctx, id, serialized);
}
function serializeAggregateError(ctx, node) {
  const id = node.i;
  ctx.stack.push(id);
  const serialized = 'new AggregateError([],"' + node.m + '")';
  ctx.stack.pop();
  return serializeDictionary(ctx, id, node.p, serialized);
}
function serializeError(ctx, node) {
  return serializeDictionary(ctx, node.i, node.p, "new " + node.c + '("' + node.m + '")');
}
var PROMISE_RESOLVE = "Promise.resolve";
var PROMISE_REJECT = "Promise.reject";
function serializePromise(ctx, node) {
  let serialized;
  const fulfilled = node.f;
  const id = node.i;
  const constructor = node.s ? PROMISE_RESOLVE : PROMISE_REJECT;
  if (isIndexedValueInStack(ctx, fulfilled)) {
    const ref = getRefParam(ctx, fulfilled.i);
    if (ctx.features & 4 /* ArrowFunction */) {
      if (node.s) {
        serialized = constructor + "().then(()=>" + ref + ")";
      } else {
        serialized = constructor + "().catch(()=>{throw " + ref + "})";
      }
    } else if (node.s) {
      serialized = constructor + "().then(function(){return " + ref + "})";
    } else {
      serialized = constructor + "().catch(function(){throw " + ref + "})";
    }
  } else {
    ctx.stack.push(id);
    const result = serializeTree(ctx, fulfilled);
    ctx.stack.pop();
    serialized = constructor + "(" + result + ")";
  }
  return assignIndexedValue2(ctx, id, serialized);
}
function serializeArrayBuffer2(ctx, node) {
  let result = "new Uint8Array(";
  const buffer = node.s;
  const len = buffer.length;
  if (len) {
    result += "[";
    for (let i = 0; i < len; i++) {
      result += (i > 0 ? "," : "") + buffer[i];
    }
    result += "]";
  }
  return assignIndexedValue2(ctx, node.i, result + ").buffer");
}
function serializeTypedArray(ctx, node) {
  return assignIndexedValue2(
    ctx,
    node.i,
    "new " + node.c + "(" + serializeTree(ctx, node.f) + "," + node.b + "," + node.l + ")"
  );
}
function serializeDate(ctx, node) {
  return assignIndexedValue2(ctx, node.i, 'new Date("' + node.s + '")');
}
function serializeRegExp(ctx, node) {
  return assignIndexedValue2(ctx, node.i, "/" + node.c + "/" + node.m);
}
function serializeURL(ctx, node) {
  return assignIndexedValue2(ctx, node.i, 'new URL("' + node.s + '")');
}
function serializeURLSearchParams(ctx, node) {
  return assignIndexedValue2(
    ctx,
    node.i,
    node.s ? 'new URLSearchParams("' + node.s + '")' : "new URLSearchParams"
  );
}
function serializeReference(ctx, node) {
  return assignIndexedValue2(ctx, node.i, REFERENCES_KEY + '.get("' + node.s + '")');
}
function serializeDataView(ctx, node) {
  return assignIndexedValue2(
    ctx,
    node.i,
    "new DataView(" + serializeTree(ctx, node.f) + "," + node.b + "," + node.l + ")"
  );
}
function serializeBlob(ctx, node) {
  return assignIndexedValue2(
    ctx,
    node.i,
    "new Blob([" + serializeTree(ctx, node.f) + '],{type:"' + node.c + '"})'
  );
}
function serializeFile(ctx, node) {
  return assignIndexedValue2(
    ctx,
    node.i,
    "new File([" + serializeTree(ctx, node.f) + '],"' + node.m + '",{type:"' + node.c + '",lastModified:' + node.b + "})"
  );
}
function serializeHeaders(ctx, node) {
  return assignIndexedValue2(
    ctx,
    node.i,
    "new Headers(" + serializeProperties(ctx, node.i, node.e) + ")"
  );
}
function serializeFormDataEntries(ctx, node) {
  let value;
  let key;
  const keys = node.e.k;
  const vals = node.e.v;
  const id = node.i;
  const mainAssignments = [];
  let parentAssignment;
  ctx.stack.push(id);
  for (let i = 0, len = node.e.s; i < len; i++) {
    key = keys[i];
    value = serializeTree(ctx, vals[i]);
    parentAssignment = ctx.assignments;
    ctx.assignments = mainAssignments;
    createAppendAssignment(ctx, id, '"' + key + '"', value);
    ctx.assignments = parentAssignment;
  }
  ctx.stack.pop();
  return resolveAssignments(mainAssignments);
}
function serializeFormData(ctx, node) {
  const size = node.e.s;
  const id = node.i;
  if (size) {
    markRef(ctx, id);
  }
  const result = assignIndexedValue2(ctx, id, "new FormData()");
  if (size) {
    const entries = serializeFormDataEntries(ctx, node);
    return "(" + result + "," + (entries == null ? "" : entries) + getRefParam(ctx, id) + ")";
  }
  return result;
}
function serializeBoxed(ctx, node) {
  return assignIndexedValue2(ctx, node.i, "Object(" + serializeTree(ctx, node.f) + ")");
}
function serializeWKSymbol(ctx, node) {
  return assignIndexedValue2(ctx, node.i, SYMBOL_STRING[node.s]);
}
function serializeTree(ctx, node) {
  switch (node.t) {
    case 0 /* Number */:
      return "" + node.s;
    case 1 /* String */:
      return '"' + node.s + '"';
    case 2 /* Constant */:
      return serializeConstant(node);
    case 3 /* BigInt */:
      return node.s + "n";
    case 4 /* IndexedValue */:
      return getRefParam(ctx, node.i);
    case 9 /* Array */:
      return serializeArray(ctx, node);
    case 10 /* Object */:
      return serializeObject(ctx, node);
    case 11 /* NullConstructor */:
      return serializeNullConstructor(ctx, node);
    case 5 /* Date */:
      return serializeDate(ctx, node);
    case 6 /* RegExp */:
      return serializeRegExp(ctx, node);
    case 7 /* Set */:
      return serializeSet(ctx, node);
    case 8 /* Map */:
      return serializeMap(ctx, node);
    case 21 /* ArrayBuffer */:
      return serializeArrayBuffer2(ctx, node);
    case 16 /* BigIntTypedArray */:
    case 15 /* TypedArray */:
      return serializeTypedArray(ctx, node);
    case 22 /* DataView */:
      return serializeDataView(ctx, node);
    case 14 /* AggregateError */:
      return serializeAggregateError(ctx, node);
    case 13 /* Error */:
      return serializeError(ctx, node);
    case 12 /* Promise */:
      return serializePromise(ctx, node);
    case 17 /* WKSymbol */:
      return serializeWKSymbol(ctx, node);
    case 18 /* URL */:
      return serializeURL(ctx, node);
    case 19 /* URLSearchParams */:
      return serializeURLSearchParams(ctx, node);
    case 20 /* Reference */:
      return serializeReference(ctx, node);
    case 23 /* Blob */:
      return serializeBlob(ctx, node);
    case 24 /* File */:
      return serializeFile(ctx, node);
    case 25 /* Headers */:
      return serializeHeaders(ctx, node);
    case 26 /* FormData */:
      return serializeFormData(ctx, node);
    case 27 /* Boxed */:
      return serializeBoxed(ctx, node);
    default:
      throw new Error("invariant");
  }
}

// src/core/tree/sync.ts
function generateNodeList2(ctx, current) {
  const size = current.length;
  const nodes = new Array(size);
  const deferred = new Array(size);
  let item;
  for (let i = 0; i < size; i++) {
    if (i in current) {
      item = current[i];
      if (isIterable(item)) {
        deferred[i] = item;
      } else {
        nodes[i] = parseSync(ctx, item);
      }
    }
  }
  for (let i = 0; i < size; i++) {
    if (i in deferred) {
      nodes[i] = parseSync(ctx, deferred[i]);
    }
  }
  return nodes;
}
function generateArrayNode2(ctx, id, current) {
  return {
    t: 9 /* Array */,
    i: id,
    s: void 0,
    l: current.length,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: generateNodeList2(ctx, current),
    f: void 0,
    b: void 0,
    o: getObjectFlag(current)
  };
}
function generateMapNode2(ctx, id, current) {
  assert(ctx.features & 32 /* Map */, new UnsupportedTypeError(current));
  const len = current.size;
  const keyNodes = new Array(len);
  const valueNodes = new Array(len);
  const deferredKey = new Array(len);
  const deferredValue = new Array(len);
  let deferredSize = 0;
  let nodeSize = 0;
  for (const [key, value] of current.entries()) {
    if (isIterable(key) || isIterable(value)) {
      deferredKey[deferredSize] = key;
      deferredValue[deferredSize] = value;
      deferredSize++;
    } else {
      keyNodes[nodeSize] = parseSync(ctx, key);
      valueNodes[nodeSize] = parseSync(ctx, value);
      nodeSize++;
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    keyNodes[nodeSize + i] = parseSync(ctx, deferredKey[i]);
    valueNodes[nodeSize + i] = parseSync(ctx, deferredValue[i]);
  }
  return {
    t: 8 /* Map */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: { k: keyNodes, v: valueNodes, s: len },
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateSetNode2(ctx, id, current) {
  assert(ctx.features & 512 /* Set */, new UnsupportedTypeError(current));
  const len = current.size;
  const nodes = new Array(len);
  const deferred = new Array(len);
  let deferredSize = 0;
  let nodeSize = 0;
  for (const item of current.keys()) {
    if (isIterable(item)) {
      deferred[deferredSize++] = item;
    } else {
      nodes[nodeSize++] = parseSync(ctx, item);
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    nodes[nodeSize + i] = parseSync(ctx, deferred[i]);
  }
  return {
    t: 7 /* Set */,
    i: id,
    s: void 0,
    l: len,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: nodes,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateProperties2(ctx, properties) {
  const keys = Object.keys(properties);
  let size = keys.length;
  const keyNodes = new Array(size);
  const valueNodes = new Array(size);
  const deferredKeys = new Array(size);
  const deferredValues = new Array(size);
  let deferredSize = 0;
  let nodesSize = 0;
  let item;
  let escaped;
  for (const key of keys) {
    item = properties[key];
    escaped = serializeString(key);
    if (isIterable(item)) {
      deferredKeys[deferredSize] = escaped;
      deferredValues[deferredSize] = item;
      deferredSize++;
    } else {
      keyNodes[nodesSize] = escaped;
      valueNodes[nodesSize] = parseSync(ctx, item);
      nodesSize++;
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    keyNodes[nodesSize + i] = deferredKeys[i];
    valueNodes[nodesSize + i] = parseSync(ctx, deferredValues[i]);
  }
  if (ctx.features & 1024 /* Symbol */) {
    if (Symbol.iterator in properties) {
      keyNodes[size] = 0 /* SymbolIterator */;
      const items = Array.from(properties);
      const id = createIndexedValue(ctx, items);
      valueNodes[size] = generateArrayNode2(ctx, id, items);
      size++;
    }
  }
  return {
    k: keyNodes,
    v: valueNodes,
    s: size
  };
}
function generatePlainProperties2(ctx, properties) {
  const keys = Object.keys(properties);
  const size = keys.length;
  const keyNodes = new Array(size);
  const valueNodes = new Array(size);
  const deferredKeys = new Array(size);
  const deferredValues = new Array(size);
  let deferredSize = 0;
  let nodesSize = 0;
  let item;
  let escaped;
  for (const key of keys) {
    item = properties[key];
    escaped = serializeString(key);
    if (isIterable(item)) {
      deferredKeys[deferredSize] = escaped;
      deferredValues[deferredSize] = item;
      deferredSize++;
    } else {
      keyNodes[nodesSize] = escaped;
      valueNodes[nodesSize] = parseSync(ctx, item);
      nodesSize++;
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    keyNodes[nodesSize + i] = deferredKeys[i];
    valueNodes[nodesSize + i] = parseSync(ctx, deferredValues[i]);
  }
  return {
    k: keyNodes,
    v: valueNodes,
    s: size
  };
}
function generateObjectNode2(ctx, id, current, empty) {
  return {
    t: empty ? 11 /* NullConstructor */ : 10 /* Object */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: generateProperties2(ctx, current),
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: getObjectFlag(current)
  };
}
function generateAggregateErrorNode2(ctx, id, current) {
  const options = getErrorOptions(ctx, current);
  const optionsNode = options ? generateProperties2(ctx, options) : void 0;
  return {
    t: 14 /* AggregateError */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: serializeString(current.message),
    p: optionsNode,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateErrorNode2(ctx, id, current) {
  const options = getErrorOptions(ctx, current);
  const optionsNode = options ? generateProperties2(ctx, options) : void 0;
  return {
    t: 13 /* Error */,
    i: id,
    s: void 0,
    l: void 0,
    c: getErrorConstructorName(current),
    m: serializeString(current.message),
    p: optionsNode,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateHeadersNode2(ctx, id, current) {
  assert(ctx.features & 8192 /* WebAPI */, new UnsupportedTypeError(current));
  const items = {};
  current.forEach((value, key) => {
    items[key] = value;
  });
  return {
    t: 25 /* Headers */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: generatePlainProperties2(ctx, items),
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateFormDataNode2(ctx, id, current) {
  assert(ctx.features & 8192 /* WebAPI */, new UnsupportedTypeError(current));
  const items = {};
  current.forEach((value, key) => {
    items[key] = value;
  });
  return {
    t: 26 /* FormData */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: generatePlainProperties2(ctx, items),
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateBoxedNode2(ctx, id, current) {
  return {
    t: 27 /* Boxed */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: parseSync(ctx, current.valueOf()),
    b: void 0,
    o: void 0
  };
}
function parseObject2(ctx, current) {
  if (!current) {
    return NULL_NODE;
  }
  const id = createIndexedValue(ctx, current);
  if (ctx.reference.marked.has(id)) {
    return createIndexedValueNode(id);
  }
  if (hasReferenceID(current)) {
    return createReferenceNode(id, current);
  }
  if (Array.isArray(current)) {
    return generateArrayNode2(ctx, id, current);
  }
  switch (current.constructor) {
    case Number:
    case Boolean:
    case String:
    case BigInt:
    case Function:
    case Symbol:
      return generateBoxedNode2(ctx, id, current);
    case Date:
      return createDateNode(id, current);
    case RegExp:
      return createRegExpNode(id, current);
    case ArrayBuffer:
      return createArrayBufferNode(id, current);
    case Int8Array:
    case Int16Array:
    case Int32Array:
    case Uint8Array:
    case Uint16Array:
    case Uint32Array:
    case Uint8ClampedArray:
    case Float32Array:
    case Float64Array:
      return createTypedArrayNode(ctx, id, current);
    case BigInt64Array:
    case BigUint64Array:
      return createBigIntTypedArrayNode(ctx, id, current);
    case DataView:
      return createDataViewNode(ctx, id, current);
    case Map:
      return generateMapNode2(ctx, id, current);
    case Set:
      return generateSetNode2(ctx, id, current);
    case Object:
      return generateObjectNode2(
        ctx,
        id,
        current,
        false
      );
    case void 0:
      return generateObjectNode2(
        ctx,
        id,
        current,
        true
      );
    case AggregateError:
      if (ctx.features & 1 /* AggregateError */) {
        return generateAggregateErrorNode2(ctx, id, current);
      }
      return generateErrorNode2(ctx, id, current);
    case Error:
    case EvalError:
    case RangeError:
    case ReferenceError:
    case SyntaxError:
    case TypeError:
    case URIError:
      return generateErrorNode2(ctx, id, current);
    case URL:
      return createURLNode(ctx, id, current);
    case URLSearchParams:
      return createURLSearchParamsNode(ctx, id, current);
    case Headers:
      return generateHeadersNode2(ctx, id, current);
    case FormData:
      return generateFormDataNode2(ctx, id, current);
    default:
      break;
  }
  if (current instanceof AggregateError) {
    if (ctx.features & 1 /* AggregateError */) {
      return generateAggregateErrorNode2(ctx, id, current);
    }
    return generateErrorNode2(ctx, id, current);
  }
  if (current instanceof Error) {
    return generateErrorNode2(ctx, id, current);
  }
  if (Symbol.iterator in current) {
    return generateObjectNode2(ctx, id, current, !!current.constructor);
  }
  throw new UnsupportedTypeError(current);
}
function parseSync(ctx, current) {
  switch (typeof current) {
    case "boolean":
      return current ? TRUE_NODE : FALSE_NODE;
    case "undefined":
      return UNDEFINED_NODE;
    case "string":
      return createStringNode(current);
    case "number":
      return createNumberNode(current);
    case "bigint":
      return createBigIntNode(ctx, current);
    case "object":
      return parseObject2(ctx, current);
    case "symbol":
      return createSymbolNode(ctx, current);
    case "function":
      return createFunctionNode(ctx, current);
    default:
      throw new UnsupportedTypeError(current);
  }
}

// src/core/tree/index.ts
function finalize(ctx, rootID, isObject, result) {
  if (rootID != null && ctx.vars.length) {
    const patches = resolvePatches(ctx);
    let body = result;
    if (patches) {
      const index = getRefParam(ctx, rootID);
      body = result + "," + patches + index;
      if (!result.startsWith(index + "=")) {
        body = index + "=" + body;
      }
    }
    let params = ctx.vars.length > 1 ? ctx.vars.join(",") : ctx.vars[0];
    if (ctx.features & 4 /* ArrowFunction */) {
      params = ctx.vars.length > 1 || ctx.vars.length === 0 ? "(" + params + ")" : params;
      return "(" + params + "=>(" + body + "))()";
    }
    return "(function(" + params + "){return " + body + "})()";
  }
  if (isObject) {
    return "(" + result + ")";
  }
  return result;
}
function serialize(source, options) {
  const ctx = createParserContext(options);
  const tree = parseSync(ctx, source);
  const serial = createSerializerContext({
    markedRefs: ctx.reference.marked,
    features: ctx.features
  });
  const result = serializeTree(serial, tree);
  return finalize(
    serial,
    tree.i,
    tree.t === 10 /* Object */,
    result
  );
}
async function serializeAsync(source, options) {
  const ctx = createParserContext(options);
  const tree = await parseAsync(ctx, source);
  const serial = createSerializerContext({
    markedRefs: ctx.reference.marked,
    features: ctx.features
  });
  const result = serializeTree(serial, tree);
  return finalize(
    serial,
    tree.i,
    tree.t === 10 /* Object */,
    result
  );
}
function deserialize(source) {
  return (0, eval)(source);
}
function toJSON(source, options) {
  const ctx = createParserContext(options);
  return {
    t: parseSync(ctx, source),
    f: ctx.features,
    m: Array.from(ctx.reference.marked)
  };
}
async function toJSONAsync(source, options) {
  const ctx = createParserContext(options);
  return {
    t: await parseAsync(ctx, source),
    f: ctx.features,
    m: Array.from(ctx.reference.marked)
  };
}
function compileJSON(source) {
  const serial = createSerializerContext({
    features: source.f,
    markedRefs: source.m
  });
  const result = serializeTree(serial, source.t);
  return finalize(serial, source.t.i, source.t.i === 10 /* Object */, result);
}
function fromJSON(source) {
  const serial = createDeserializerContext({
    markedRefs: source.m
  });
  return deserializeTree(serial, source.t);
}

// src/core/cross/context.ts
function createCrossParserContext(options = {}) {
  return {
    scopeId: options.scopeId,
    refs: options.refs || /* @__PURE__ */ new Map(),
    features: ALL_ENABLED ^ (options.disabledFeatures || 0)
  };
}
function createCrossIndexedValue(ctx, current) {
  const ref = ctx.refs.get(current);
  if (ref == null) {
    const id = ctx.refs.size;
    ctx.refs.set(current, id);
    return id;
  }
  return ref;
}
function createStreamingCrossParserContext(options) {
  return {
    alive: true,
    pending: 0,
    refs: options.refs || /* @__PURE__ */ new Map(),
    features: ALL_ENABLED ^ (options.disabledFeatures || 0),
    onParse: options.onParse,
    onDone() {
      if (options.onDone) {
        options.onDone();
      }
    },
    scopeId: options.scopeId
  };
}
function pushPendingState(ctx) {
  ctx.pending++;
}
function popPendingState(ctx) {
  if (--ctx.pending <= 0) {
    ctx.onDone();
  }
}
function createCrossSerializerContext(options) {
  return {
    stack: [],
    assignments: [],
    features: options.features,
    flags: []
  };
}

// src/core/cross/primitives.ts
function serializeArrayBuffer3(ctx, current) {
  const id = ctx.refs.get(current);
  if (id != null) {
    return createIndexedValueNode(id);
  }
  const newID = ctx.refs.size;
  ctx.refs.set(current, newID);
  return createArrayBufferNode(newID, current);
}
function createTypedArrayNode2(ctx, id, current) {
  assert(ctx.features & 2048 /* TypedArray */, new UnsupportedTypeError(current));
  return {
    t: 15 /* TypedArray */,
    i: id,
    s: void 0,
    l: current.length,
    c: current.constructor.name,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: serializeArrayBuffer3(ctx, current.buffer),
    b: current.byteOffset,
    o: void 0
  };
}
var BIGINT_FLAG2 = 4096 /* BigIntTypedArray */ | 8 /* BigInt */;
function createBigIntTypedArrayNode2(ctx, id, current) {
  assert(
    (ctx.features & BIGINT_FLAG2) === BIGINT_FLAG2,
    new UnsupportedTypeError(current)
  );
  return {
    t: 16 /* BigIntTypedArray */,
    i: id,
    s: void 0,
    l: current.length,
    c: current.constructor.name,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: serializeArrayBuffer3(ctx, current.buffer),
    b: current.byteOffset,
    o: void 0
  };
}
function createDataViewNode2(ctx, id, current) {
  return {
    t: 22 /* DataView */,
    i: id,
    s: void 0,
    l: current.byteLength,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: serializeArrayBuffer3(ctx, current.buffer),
    b: current.byteOffset,
    o: void 0
  };
}
function createSymbolNode2(ctx, current) {
  const id = ctx.refs.get(current);
  if (id != null) {
    return createIndexedValueNode(id);
  }
  const newID = ctx.refs.size;
  ctx.refs.set(current, newID);
  if (hasReferenceID(current)) {
    return createReferenceNode(newID, current);
  }
  return createWKSymbolNode(ctx, newID, current);
}
function createFunctionNode2(ctx, current) {
  assert(hasReferenceID(current), new Error("Cannot serialize function without reference ID."));
  const id = ctx.refs.get(current);
  if (id != null) {
    return createIndexedValueNode(id);
  }
  const newID = ctx.refs.size;
  ctx.refs.set(current, newID);
  return createReferenceNode(newID, current);
}

// src/core/cross/web-api.ts
async function createBlobNode2(ctx, id, current) {
  assert(ctx.features & 8192 /* WebAPI */, new UnsupportedTypeError(current));
  return {
    t: 23 /* Blob */,
    i: id,
    s: void 0,
    l: void 0,
    c: serializeString(current.type),
    m: void 0,
    p: void 0,
    e: void 0,
    f: serializeArrayBuffer3(ctx, await current.arrayBuffer()),
    a: void 0,
    b: void 0,
    o: void 0
  };
}
async function createFileNode2(ctx, id, current) {
  assert(ctx.features & 8192 /* WebAPI */, new UnsupportedTypeError(current));
  return {
    t: 24 /* File */,
    i: id,
    s: void 0,
    l: void 0,
    c: serializeString(current.type),
    m: serializeString(current.name),
    p: void 0,
    e: void 0,
    f: serializeArrayBuffer3(ctx, await current.arrayBuffer()),
    a: void 0,
    b: current.lastModified,
    o: void 0
  };
}

// src/core/cross/async.ts
async function generateNodeList3(ctx, current) {
  const size = current.length;
  const nodes = new Array(size);
  const deferred = new Array(size);
  let item;
  for (let i = 0; i < size; i++) {
    if (i in current) {
      item = current[i];
      if (isIterable(item)) {
        deferred[i] = item;
      } else {
        nodes[i] = await crossParseAsync(ctx, item);
      }
    }
  }
  for (let i = 0; i < size; i++) {
    if (i in deferred) {
      nodes[i] = await crossParseAsync(ctx, deferred[i]);
    }
  }
  return nodes;
}
async function generateArrayNode3(ctx, id, current) {
  return {
    t: 9 /* Array */,
    i: id,
    s: void 0,
    l: current.length,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: await generateNodeList3(ctx, current),
    f: void 0,
    b: void 0,
    o: getObjectFlag(current)
  };
}
async function generateMapNode3(ctx, id, current) {
  assert(ctx.features & 32 /* Map */, new UnsupportedTypeError(current));
  const len = current.size;
  const keyNodes = new Array(len);
  const valueNodes = new Array(len);
  const deferredKey = new Array(len);
  const deferredValue = new Array(len);
  let deferredSize = 0;
  let nodeSize = 0;
  for (const [key, value] of current.entries()) {
    if (isIterable(key) || isIterable(value)) {
      deferredKey[deferredSize] = key;
      deferredValue[deferredSize] = value;
      deferredSize++;
    } else {
      keyNodes[nodeSize] = await crossParseAsync(ctx, key);
      valueNodes[nodeSize] = await crossParseAsync(ctx, value);
      nodeSize++;
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    keyNodes[nodeSize + i] = await crossParseAsync(ctx, deferredKey[i]);
    valueNodes[nodeSize + i] = await crossParseAsync(ctx, deferredValue[i]);
  }
  return {
    t: 8 /* Map */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: { k: keyNodes, v: valueNodes, s: len },
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
async function generateSetNode3(ctx, id, current) {
  assert(ctx.features & 512 /* Set */, new UnsupportedTypeError(current));
  const len = current.size;
  const nodes = new Array(len);
  const deferred = new Array(len);
  let deferredSize = 0;
  let nodeSize = 0;
  for (const item of current.keys()) {
    if (isIterable(item)) {
      deferred[deferredSize++] = item;
    } else {
      nodes[nodeSize++] = await crossParseAsync(ctx, item);
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    nodes[nodeSize + i] = await crossParseAsync(ctx, deferred[i]);
  }
  return {
    t: 7 /* Set */,
    i: id,
    s: void 0,
    l: len,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: nodes,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
async function generateProperties3(ctx, properties) {
  const keys = Object.keys(properties);
  let size = keys.length;
  const keyNodes = new Array(size);
  const valueNodes = new Array(size);
  const deferredKeys = new Array(size);
  const deferredValues = new Array(size);
  let deferredSize = 0;
  let nodesSize = 0;
  let item;
  let escaped;
  for (const key of keys) {
    item = properties[key];
    escaped = serializeString(key);
    if (isIterable(item)) {
      deferredKeys[deferredSize] = escaped;
      deferredValues[deferredSize] = item;
      deferredSize++;
    } else {
      keyNodes[nodesSize] = escaped;
      valueNodes[nodesSize] = await crossParseAsync(ctx, item);
      nodesSize++;
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    keyNodes[nodesSize + i] = deferredKeys[i];
    valueNodes[nodesSize + i] = await crossParseAsync(ctx, deferredValues[i]);
  }
  if (ctx.features & 1024 /* Symbol */) {
    if (Symbol.iterator in properties) {
      keyNodes[size] = 0 /* SymbolIterator */;
      const items = Array.from(properties);
      valueNodes[size] = await generateArrayNode3(
        ctx,
        createCrossIndexedValue(ctx, items),
        items
      );
      size++;
    }
  }
  return {
    k: keyNodes,
    v: valueNodes,
    s: size
  };
}
async function generatePlainProperties3(ctx, properties) {
  const keys = Object.keys(properties);
  const size = keys.length;
  const keyNodes = new Array(size);
  const valueNodes = new Array(size);
  const deferredKeys = new Array(size);
  const deferredValues = new Array(size);
  let deferredSize = 0;
  let nodesSize = 0;
  let item;
  let escaped;
  for (const key of keys) {
    item = properties[key];
    escaped = serializeString(key);
    if (isIterable(item)) {
      deferredKeys[deferredSize] = escaped;
      deferredValues[deferredSize] = item;
      deferredSize++;
    } else {
      keyNodes[nodesSize] = escaped;
      valueNodes[nodesSize] = await crossParseAsync(ctx, item);
      nodesSize++;
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    keyNodes[nodesSize + i] = deferredKeys[i];
    valueNodes[nodesSize + i] = await crossParseAsync(ctx, deferredValues[i]);
  }
  return {
    k: keyNodes,
    v: valueNodes,
    s: size
  };
}
async function generatePromiseNode2(ctx, id, current) {
  assert(ctx.features & 256 /* Promise */, new UnsupportedTypeError(current));
  const [status, result] = await promiseToResult(current);
  return {
    t: 12 /* Promise */,
    i: id,
    s: status,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: await crossParseAsync(ctx, result),
    b: void 0,
    o: void 0
  };
}
async function generateObjectNode3(ctx, id, current, empty) {
  return {
    t: empty ? 11 /* NullConstructor */ : 10 /* Object */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: await generateProperties3(ctx, current),
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: getObjectFlag(current)
  };
}
async function generateAggregateErrorNode3(ctx, id, current) {
  const options = getErrorOptions(ctx, current);
  const optionsNode = options ? await generateProperties3(ctx, options) : void 0;
  return {
    t: 14 /* AggregateError */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: serializeString(current.message),
    p: optionsNode,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
async function generateErrorNode3(ctx, id, current) {
  const options = getErrorOptions(ctx, current);
  const optionsNode = options ? await generateProperties3(ctx, options) : void 0;
  return {
    t: 13 /* Error */,
    i: id,
    s: void 0,
    l: void 0,
    c: getErrorConstructorName(current),
    m: serializeString(current.message),
    p: optionsNode,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
async function generateHeadersNode3(ctx, id, current) {
  assert(ctx.features & 8192 /* WebAPI */, new UnsupportedTypeError(current));
  const items = {};
  current.forEach((value, key) => {
    items[key] = value;
  });
  return {
    t: 25 /* Headers */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: await generatePlainProperties3(ctx, items),
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
async function generateFormDataNode3(ctx, id, current) {
  assert(ctx.features & 8192 /* WebAPI */, new UnsupportedTypeError(current));
  const items = {};
  current.forEach((value, key) => {
    items[key] = value;
  });
  return {
    t: 26 /* FormData */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: await generatePlainProperties3(ctx, items),
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
async function generateBoxedNode3(ctx, id, current) {
  return {
    t: 27 /* Boxed */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: await crossParseAsync(ctx, current.valueOf()),
    b: void 0,
    o: void 0
  };
}
async function parseObject3(ctx, current) {
  if (!current) {
    return NULL_NODE;
  }
  const registeredID = ctx.refs.get(current);
  if (registeredID != null) {
    return createIndexedValueNode(registeredID);
  }
  const id = ctx.refs.size;
  ctx.refs.set(current, id);
  if (hasReferenceID(current)) {
    return createReferenceNode(id, current);
  }
  if (Array.isArray(current)) {
    return generateArrayNode3(ctx, id, current);
  }
  switch (current.constructor) {
    case Number:
    case Boolean:
    case String:
    case BigInt:
    case Function:
    case Symbol:
      return generateBoxedNode3(ctx, id, current);
    case Date:
      return createDateNode(id, current);
    case RegExp:
      return createRegExpNode(id, current);
    case Promise:
      return generatePromiseNode2(ctx, id, current);
    case ArrayBuffer:
      return createArrayBufferNode(id, current);
    case Int8Array:
    case Int16Array:
    case Int32Array:
    case Uint8Array:
    case Uint16Array:
    case Uint32Array:
    case Uint8ClampedArray:
    case Float32Array:
    case Float64Array:
      return createTypedArrayNode2(ctx, id, current);
    case BigInt64Array:
    case BigUint64Array:
      return createBigIntTypedArrayNode2(ctx, id, current);
    case DataView:
      return createDataViewNode2(ctx, id, current);
    case Map:
      return generateMapNode3(
        ctx,
        id,
        current
      );
    case Set:
      return generateSetNode3(
        ctx,
        id,
        current
      );
    case Object:
      return generateObjectNode3(
        ctx,
        id,
        current,
        false
      );
    case void 0:
      return generateObjectNode3(
        ctx,
        id,
        current,
        true
      );
    case AggregateError:
      if (ctx.features & 1 /* AggregateError */) {
        return generateAggregateErrorNode3(ctx, id, current);
      }
      return generateErrorNode3(ctx, id, current);
    case Error:
    case EvalError:
    case RangeError:
    case ReferenceError:
    case SyntaxError:
    case TypeError:
    case URIError:
      return generateErrorNode3(ctx, id, current);
    case URL:
      return createURLNode(ctx, id, current);
    case URLSearchParams:
      return createURLSearchParamsNode(ctx, id, current);
    case Blob:
      return createBlobNode2(ctx, id, current);
    case File:
      return createFileNode2(ctx, id, current);
    case Headers:
      return generateHeadersNode3(ctx, id, current);
    case FormData:
      return generateFormDataNode3(ctx, id, current);
    default:
      break;
  }
  if (current instanceof AggregateError) {
    if (ctx.features & 1 /* AggregateError */) {
      return generateAggregateErrorNode3(ctx, id, current);
    }
    return generateErrorNode3(ctx, id, current);
  }
  if (current instanceof Error) {
    return generateErrorNode3(ctx, id, current);
  }
  if (current instanceof Promise) {
    return generatePromiseNode2(ctx, id, current);
  }
  if (Symbol.iterator in current) {
    return generateObjectNode3(ctx, id, current, !!current.constructor);
  }
  throw new UnsupportedTypeError(current);
}
async function crossParseAsync(ctx, current) {
  switch (typeof current) {
    case "boolean":
      return current ? TRUE_NODE : FALSE_NODE;
    case "undefined":
      return UNDEFINED_NODE;
    case "string":
      return createStringNode(current);
    case "number":
      return createNumberNode(current);
    case "bigint":
      return createBigIntNode(ctx, current);
    case "object":
      return parseObject3(ctx, current);
    case "symbol":
      return createSymbolNode2(ctx, current);
    case "function":
      return createFunctionNode2(ctx, current);
    default:
      throw new UnsupportedTypeError(current);
  }
}

// src/core/cross/serialize.ts
function getRefExpr(id) {
  return GLOBAL_CONTEXT_REFERENCES + "[" + id + "]";
}
function pushObjectFlag2(ctx, flag, id) {
  if (flag !== 0 /* None */) {
    ctx.flags.push({
      type: flag,
      value: getRefExpr(id)
    });
  }
}
function resolvePatches2(ctx) {
  const assignments = resolveAssignments(ctx.assignments);
  const flags = resolveFlags(ctx.flags);
  if (assignments) {
    if (flags) {
      return assignments + flags;
    }
    return assignments;
  }
  return flags;
}
function createAssignment2(ctx, source, value) {
  ctx.assignments.push({
    t: "index",
    s: source,
    k: void 0,
    v: value
  });
}
function createAddAssignment2(ctx, ref, value) {
  ctx.assignments.push({
    t: "add",
    s: getRefExpr(ref),
    k: void 0,
    v: value
  });
}
function createSetAssignment2(ctx, ref, key, value) {
  ctx.assignments.push({
    t: "set",
    s: getRefExpr(ref),
    k: key,
    v: value
  });
}
function createAppendAssignment2(ctx, ref, key, value) {
  ctx.assignments.push({
    t: "append",
    s: getRefExpr(ref),
    k: key,
    v: value
  });
}
function createArrayAssign2(ctx, ref, index, value) {
  createAssignment2(ctx, getRefExpr(ref) + "[" + index + "]", value);
}
function createObjectAssign2(ctx, ref, key, value) {
  createAssignment2(ctx, getRefExpr(ref) + "." + key, value);
}
function assignIndexedValue3(index, value) {
  return getRefExpr(index) + "=" + value;
}
function isIndexedValueInStack2(ctx, node) {
  return node.t === 4 /* IndexedValue */ && ctx.stack.includes(node.i);
}
function serializeArray2(ctx, node) {
  const id = node.i;
  ctx.stack.push(id);
  let values = "";
  let item;
  let isHoley = false;
  const list = node.a;
  for (let i = 0, len = node.l; i < len; i++) {
    if (i !== 0) {
      values += ",";
    }
    item = list[i];
    if (item) {
      if (isIndexedValueInStack2(ctx, item)) {
        createArrayAssign2(ctx, id, i, getRefExpr(item.i));
        isHoley = true;
      } else {
        values += crossSerializeTree(ctx, item);
        isHoley = false;
      }
    } else {
      isHoley = true;
    }
  }
  ctx.stack.pop();
  pushObjectFlag2(ctx, node.o, node.i);
  return assignIndexedValue3(id, "[" + values + (isHoley ? ",]" : "]"));
}
function getIterableAccess2(ctx) {
  return ctx.features & 2 /* ArrayPrototypeValues */ ? ".values()" : "[Symbol.iterator]()";
}
function serializeIterable2(ctx, node) {
  const parent = ctx.stack;
  ctx.stack = [];
  let serialized = crossSerializeTree(ctx, node) + getIterableAccess2(ctx);
  ctx.stack = parent;
  if (ctx.features & 4 /* ArrowFunction */) {
    serialized = "[Symbol.iterator]:()=>" + serialized;
  } else if (ctx.features & 64 /* MethodShorthand */) {
    serialized = "[Symbol.iterator](){return " + serialized + "}";
  } else {
    serialized = "[Symbol.iterator]:function(){return " + serialized + "}";
  }
  return serialized;
}
function serializeProperties2(ctx, sourceID, node) {
  const len = node.s;
  if (len === 0) {
    return "{}";
  }
  let result = "";
  ctx.stack.push(sourceID);
  let key;
  let val;
  let check;
  let isIdentifier;
  let refParam;
  let hasPrev = false;
  const keys = node.k;
  const values = node.v;
  for (let i = 0; i < len; i++) {
    key = keys[i];
    val = values[i];
    switch (key) {
      case 0 /* SymbolIterator */:
        result += (hasPrev ? "," : "") + serializeIterable2(ctx, val);
        hasPrev = true;
        break;
      default:
        check = Number(key);
        isIdentifier = check >= 0 || isValidIdentifier(key);
        if (isIndexedValueInStack2(ctx, val)) {
          refParam = getRefExpr(val.i);
          if (isIdentifier && Number.isNaN(check)) {
            createObjectAssign2(ctx, sourceID, key, refParam);
          } else {
            createArrayAssign2(ctx, sourceID, isIdentifier ? key : '"' + key + '"', refParam);
          }
        } else {
          result += (hasPrev ? "," : "") + (isIdentifier ? key : '"' + key + '"') + ":" + crossSerializeTree(ctx, val);
          hasPrev = true;
        }
        break;
    }
  }
  ctx.stack.pop();
  return "{" + result + "}";
}
function serializeWithObjectAssign2(ctx, value, id, serialized) {
  const fields = serializeProperties2(ctx, id, value);
  if (fields !== "{}") {
    return "Object.assign(" + serialized + "," + fields + ")";
  }
  return serialized;
}
function serializeAssignments2(ctx, sourceID, node) {
  ctx.stack.push(sourceID);
  const mainAssignments = [];
  let key;
  let value;
  let parentAssignment;
  const keys = node.k;
  const values = node.v;
  for (let i = 0, len = node.s; i < len; i++) {
    key = keys[i];
    value = values[i];
    switch (key) {
      case 0 /* SymbolIterator */:
        {
          const parent = ctx.stack;
          ctx.stack = [];
          const serialized = crossSerializeTree(ctx, value) + getIterableAccess2(ctx);
          ctx.stack = parent;
          parentAssignment = ctx.assignments;
          ctx.assignments = mainAssignments;
          createArrayAssign2(
            ctx,
            sourceID,
            "Symbol.iterator",
            ctx.features & 4 /* ArrowFunction */ ? "()=>" + serialized : "function(){return " + serialized + "}"
          );
          ctx.assignments = parentAssignment;
        }
        break;
      default: {
        const serialized = crossSerializeTree(ctx, value);
        const check = Number(key);
        const isIdentifier = check >= 0 || isValidIdentifier(key);
        if (isIndexedValueInStack2(ctx, value)) {
          if (isIdentifier && Number.isNaN(check)) {
            createObjectAssign2(ctx, sourceID, key, serialized);
          } else {
            createArrayAssign2(ctx, sourceID, isIdentifier ? key : '"' + key + '"', serialized);
          }
        } else {
          parentAssignment = ctx.assignments;
          ctx.assignments = mainAssignments;
          if (isIdentifier && Number.isNaN(check)) {
            createObjectAssign2(ctx, sourceID, key, serialized);
          } else {
            createArrayAssign2(ctx, sourceID, isIdentifier ? key : '"' + key + '"', serialized);
          }
          ctx.assignments = parentAssignment;
        }
      }
    }
  }
  ctx.stack.pop();
  return resolveAssignments(mainAssignments);
}
function serializeDictionary2(ctx, i, p, init) {
  if (p) {
    if (ctx.features & 128 /* ObjectAssign */) {
      init = serializeWithObjectAssign2(ctx, p, i, init);
    } else {
      const assignments = serializeAssignments2(ctx, i, p);
      if (assignments) {
        return "(" + assignIndexedValue3(i, init) + "," + assignments + getRefExpr(i) + ")";
      }
    }
  }
  return assignIndexedValue3(i, init);
}
var NULL_CONSTRUCTOR2 = "Object.create(null)";
function serializeNullConstructor2(ctx, node) {
  pushObjectFlag2(ctx, node.o, node.i);
  return serializeDictionary2(ctx, node.i, node.p, NULL_CONSTRUCTOR2);
}
function serializeObject2(ctx, node) {
  pushObjectFlag2(ctx, node.o, node.i);
  return assignIndexedValue3(node.i, serializeProperties2(ctx, node.i, node.p));
}
function serializeSet2(ctx, node) {
  let serialized = "new Set";
  const size = node.l;
  const id = node.i;
  if (size) {
    let result = "";
    let item;
    let hasPrev = false;
    const items = node.a;
    ctx.stack.push(id);
    for (let i = 0; i < size; i++) {
      item = items[i];
      if (isIndexedValueInStack2(ctx, item)) {
        createAddAssignment2(ctx, id, getRefExpr(item.i));
      } else {
        result += (hasPrev ? "," : "") + crossSerializeTree(ctx, item);
        hasPrev = true;
      }
    }
    ctx.stack.pop();
    if (result) {
      serialized += "([" + result + "])";
    }
  }
  return assignIndexedValue3(id, serialized);
}
function serializeMap2(ctx, node) {
  let serialized = "new Map";
  const size = node.e.s;
  const id = node.i;
  if (size) {
    let result = "";
    let key;
    let val;
    let keyRef;
    let valueRef;
    let parent;
    let hasPrev = false;
    const keys = node.e.k;
    const vals = node.e.v;
    ctx.stack.push(id);
    for (let i = 0; i < size; i++) {
      key = keys[i];
      val = vals[i];
      if (isIndexedValueInStack2(ctx, key)) {
        keyRef = getRefExpr(id);
        if (isIndexedValueInStack2(ctx, val)) {
          valueRef = getRefExpr(val.i);
          createSetAssignment2(ctx, id, keyRef, valueRef);
        } else {
          parent = ctx.stack;
          ctx.stack = [];
          createSetAssignment2(ctx, id, keyRef, crossSerializeTree(ctx, val));
          ctx.stack = parent;
        }
      } else if (isIndexedValueInStack2(ctx, val)) {
        valueRef = getRefExpr(val.i);
        parent = ctx.stack;
        ctx.stack = [];
        createSetAssignment2(ctx, id, crossSerializeTree(ctx, key), valueRef);
        ctx.stack = parent;
      } else {
        result += (hasPrev ? ",[" : "[") + crossSerializeTree(ctx, key) + "," + crossSerializeTree(ctx, val) + "]";
        hasPrev = true;
      }
    }
    ctx.stack.pop();
    if (result) {
      serialized += "([" + result + "])";
    }
  }
  return assignIndexedValue3(id, serialized);
}
function serializeAggregateError2(ctx, node) {
  const id = node.i;
  ctx.stack.push(id);
  const serialized = 'new AggregateError([],"' + node.m + '")';
  ctx.stack.pop();
  return serializeDictionary2(ctx, id, node.p, serialized);
}
function serializeError2(ctx, node) {
  return serializeDictionary2(ctx, node.i, node.p, "new " + node.c + '("' + node.m + '")');
}
var PROMISE_RESOLVE2 = "Promise.resolve";
var PROMISE_REJECT2 = "Promise.reject";
function serializePromise2(ctx, node) {
  let serialized;
  const fulfilled = node.f;
  const id = node.i;
  const constructor = node.s ? PROMISE_RESOLVE2 : PROMISE_REJECT2;
  if (isIndexedValueInStack2(ctx, fulfilled)) {
    const ref = getRefExpr(fulfilled.i);
    if (ctx.features & 4 /* ArrowFunction */) {
      if (node.s) {
        serialized = constructor + "().then(()=>" + ref + ")";
      } else {
        serialized = constructor + "().catch(()=>{throw " + ref + "})";
      }
    } else if (node.s) {
      serialized = constructor + "().then(function(){return " + ref + "})";
    } else {
      serialized = constructor + "().catch(function(){throw " + ref + "})";
    }
  } else {
    ctx.stack.push(id);
    const result = crossSerializeTree(ctx, fulfilled);
    ctx.stack.pop();
    serialized = constructor + "(" + result + ")";
  }
  return assignIndexedValue3(id, serialized);
}
function serializeArrayBuffer4(node) {
  let result = "new Uint8Array(";
  const buffer = node.s;
  const len = buffer.length;
  if (len) {
    result += "[";
    for (let i = 0; i < len; i++) {
      result += (i > 0 ? "," : "") + buffer[i];
    }
    result += "]";
  }
  return assignIndexedValue3(node.i, result + ").buffer");
}
function serializeTypedArray2(ctx, node) {
  return assignIndexedValue3(
    node.i,
    "new " + node.c + "(" + crossSerializeTree(ctx, node.f) + "," + node.b + "," + node.l + ")"
  );
}
function serializeDate2(node) {
  return assignIndexedValue3(node.i, 'new Date("' + node.s + '")');
}
function serializeRegExp2(node) {
  return assignIndexedValue3(node.i, "/" + node.c + "/" + node.m);
}
function serializeURL2(node) {
  return assignIndexedValue3(node.i, 'new URL("' + node.s + '")');
}
function serializeURLSearchParams2(node) {
  return assignIndexedValue3(
    node.i,
    node.s ? 'new URLSearchParams("' + node.s + '")' : "new URLSearchParams"
  );
}
function serializeReference2(node) {
  return assignIndexedValue3(node.i, REFERENCES_KEY + '.get("' + node.s + '")');
}
function serializeDataView2(ctx, node) {
  return assignIndexedValue3(
    node.i,
    "new DataView(" + crossSerializeTree(ctx, node.f) + "," + node.b + "," + node.l + ")"
  );
}
function serializeBlob2(ctx, node) {
  return assignIndexedValue3(
    node.i,
    "new Blob([" + crossSerializeTree(ctx, node.f) + '],{type:"' + node.c + '"})'
  );
}
function serializeFile2(ctx, node) {
  return assignIndexedValue3(
    node.i,
    "new File([" + crossSerializeTree(ctx, node.f) + '],"' + node.m + '",{type:"' + node.c + '",lastModified:' + node.b + "})"
  );
}
function serializeHeaders2(ctx, node) {
  return assignIndexedValue3(
    node.i,
    "new Headers(" + serializeProperties2(ctx, node.i, node.e) + ")"
  );
}
function serializeFormDataEntries2(ctx, node) {
  let value;
  let key;
  const keys = node.e.k;
  const vals = node.e.v;
  const id = node.i;
  const mainAssignments = [];
  let parentAssignment;
  ctx.stack.push(id);
  for (let i = 0, len = node.e.s; i < len; i++) {
    key = keys[i];
    value = crossSerializeTree(ctx, vals[i]);
    parentAssignment = ctx.assignments;
    ctx.assignments = mainAssignments;
    createAppendAssignment2(ctx, id, '"' + key + '"', value);
    ctx.assignments = parentAssignment;
  }
  ctx.stack.pop();
  return resolveAssignments(mainAssignments);
}
function serializeFormData2(ctx, node) {
  const size = node.e.s;
  const id = node.i;
  const result = assignIndexedValue3(id, "new FormData()");
  if (size) {
    const entries = serializeFormDataEntries2(ctx, node);
    return "(" + result + "," + (entries == null ? "" : entries) + getRefExpr(id) + ")";
  }
  return result;
}
function serializeBoxed2(ctx, node) {
  return assignIndexedValue3(node.i, "Object(" + crossSerializeTree(ctx, node.f) + ")");
}
function serializeWKSymbol2(node) {
  return assignIndexedValue3(node.i, SYMBOL_STRING[node.s]);
}
function serializePromiseResolve(ctx, node) {
  return GLOBAL_CONTEXT_API + "." + GLOBAL_CONTEXT_PROMISE_RESOLVE + "(" + getRefExpr(node.i) + "," + crossSerializeTree(ctx, node.f) + ")";
}
function serializePromiseReject(ctx, node) {
  return GLOBAL_CONTEXT_API + "." + GLOBAL_CONTEXT_PROMISE_REJECT + "(" + getRefExpr(node.i) + "," + crossSerializeTree(ctx, node.f) + ")";
}
function serializePromiseConstructor(node) {
  return assignIndexedValue3(node.i, GLOBAL_CONTEXT_API + "." + GLOBAL_CONTEXT_PROMISE_CONSTRUCTOR + "()");
}
function serializeReadableStreamClose(node) {
  return GLOBAL_CONTEXT_API + "." + GLOBAL_CONTEXT_STREAM_EMIT + "(" + getRefExpr(node.i) + ",2)";
}
function serializeReadableStreamEnqueue(ctx, node) {
  return GLOBAL_CONTEXT_API + "." + GLOBAL_CONTEXT_STREAM_EMIT + "(" + getRefExpr(node.i) + ",0," + crossSerializeTree(ctx, node.f) + ")";
}
function serializeReadableStreamError(ctx, node) {
  return GLOBAL_CONTEXT_API + "." + GLOBAL_CONTEXT_STREAM_EMIT + "(" + getRefExpr(node.i) + ",1," + crossSerializeTree(ctx, node.f) + ")";
}
function serializeReadableStreamConstructor(node) {
  return assignIndexedValue3(node.i, GLOBAL_CONTEXT_API + "." + GLOBAL_CONTEXT_STREAM_CONSTRUCTOR + "()");
}
function crossSerializeTree(ctx, node) {
  switch (node.t) {
    case 0 /* Number */:
      return "" + node.s;
    case 1 /* String */:
      return '"' + node.s + '"';
    case 2 /* Constant */:
      return serializeConstant(node);
    case 3 /* BigInt */:
      return node.s + "n";
    case 4 /* IndexedValue */:
      return getRefExpr(node.i);
    case 9 /* Array */:
      return serializeArray2(ctx, node);
    case 10 /* Object */:
      return serializeObject2(ctx, node);
    case 11 /* NullConstructor */:
      return serializeNullConstructor2(ctx, node);
    case 5 /* Date */:
      return serializeDate2(node);
    case 6 /* RegExp */:
      return serializeRegExp2(node);
    case 7 /* Set */:
      return serializeSet2(ctx, node);
    case 8 /* Map */:
      return serializeMap2(ctx, node);
    case 21 /* ArrayBuffer */:
      return serializeArrayBuffer4(node);
    case 16 /* BigIntTypedArray */:
    case 15 /* TypedArray */:
      return serializeTypedArray2(ctx, node);
    case 22 /* DataView */:
      return serializeDataView2(ctx, node);
    case 14 /* AggregateError */:
      return serializeAggregateError2(ctx, node);
    case 13 /* Error */:
      return serializeError2(ctx, node);
    case 12 /* Promise */:
      return serializePromise2(ctx, node);
    case 17 /* WKSymbol */:
      return serializeWKSymbol2(node);
    case 18 /* URL */:
      return serializeURL2(node);
    case 19 /* URLSearchParams */:
      return serializeURLSearchParams2(node);
    case 20 /* Reference */:
      return serializeReference2(node);
    case 23 /* Blob */:
      return serializeBlob2(ctx, node);
    case 24 /* File */:
      return serializeFile2(ctx, node);
    case 25 /* Headers */:
      return serializeHeaders2(ctx, node);
    case 26 /* FormData */:
      return serializeFormData2(ctx, node);
    case 27 /* Boxed */:
      return serializeBoxed2(ctx, node);
    case 29 /* PromiseResolve */:
      return serializePromiseResolve(ctx, node);
    case 30 /* PromiseReject */:
      return serializePromiseReject(ctx, node);
    case 28 /* PromiseConstructor */:
      return serializePromiseConstructor(node);
    case 33 /* ReadableStreamClose */:
      return serializeReadableStreamClose(node);
    case 31 /* ReadableStreamConstructor */:
      return serializeReadableStreamConstructor(node);
    case 32 /* ReadableStreamEnqueue */:
      return serializeReadableStreamEnqueue(ctx, node);
    case 34 /* ReadableStreamError */:
      return serializeReadableStreamError(ctx, node);
    default:
      throw new Error("invariant");
  }
}

// src/core/cross/stream.ts
function generateNodeList4(ctx, current) {
  const size = current.length;
  const nodes = new Array(size);
  const deferred = new Array(size);
  let item;
  for (let i = 0; i < size; i++) {
    if (i in current) {
      item = current[i];
      if (isIterable(item)) {
        deferred[i] = item;
      } else {
        nodes[i] = crossParseStream(ctx, item);
      }
    }
  }
  for (let i = 0; i < size; i++) {
    if (i in deferred) {
      nodes[i] = crossParseStream(ctx, deferred[i]);
    }
  }
  return nodes;
}
function generateArrayNode4(ctx, id, current) {
  return {
    t: 9 /* Array */,
    i: id,
    s: void 0,
    l: current.length,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: generateNodeList4(ctx, current),
    f: void 0,
    b: void 0,
    o: getObjectFlag(current)
  };
}
function generateMapNode4(ctx, id, current) {
  assert(ctx.features & 32 /* Map */, new UnsupportedTypeError(current));
  const len = current.size;
  const keyNodes = new Array(len);
  const valueNodes = new Array(len);
  const deferredKey = new Array(len);
  const deferredValue = new Array(len);
  let deferredSize = 0;
  let nodeSize = 0;
  for (const [key, value] of current.entries()) {
    if (isIterable(key) || isIterable(value)) {
      deferredKey[deferredSize] = key;
      deferredValue[deferredSize] = value;
      deferredSize++;
    } else {
      keyNodes[nodeSize] = crossParseStream(ctx, key);
      valueNodes[nodeSize] = crossParseStream(ctx, value);
      nodeSize++;
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    keyNodes[nodeSize + i] = crossParseStream(ctx, deferredKey[i]);
    valueNodes[nodeSize + i] = crossParseStream(ctx, deferredValue[i]);
  }
  return {
    t: 8 /* Map */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: { k: keyNodes, v: valueNodes, s: len },
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateSetNode4(ctx, id, current) {
  assert(ctx.features & 512 /* Set */, new UnsupportedTypeError(current));
  const len = current.size;
  const nodes = new Array(len);
  const deferred = new Array(len);
  let deferredSize = 0;
  let nodeSize = 0;
  for (const item of current.keys()) {
    if (isIterable(item)) {
      deferred[deferredSize++] = item;
    } else {
      nodes[nodeSize++] = crossParseStream(ctx, item);
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    nodes[nodeSize + i] = crossParseStream(ctx, deferred[i]);
  }
  return {
    t: 7 /* Set */,
    i: id,
    s: void 0,
    l: len,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: nodes,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateProperties4(ctx, properties) {
  const keys = Object.keys(properties);
  let size = keys.length;
  const keyNodes = new Array(size);
  const valueNodes = new Array(size);
  const deferredKeys = new Array(size);
  const deferredValues = new Array(size);
  let deferredSize = 0;
  let nodesSize = 0;
  let item;
  let escaped;
  for (const key of keys) {
    item = properties[key];
    escaped = serializeString(key);
    if (isIterable(item)) {
      deferredKeys[deferredSize] = escaped;
      deferredValues[deferredSize] = item;
      deferredSize++;
    } else {
      keyNodes[nodesSize] = escaped;
      valueNodes[nodesSize] = crossParseStream(ctx, item);
      nodesSize++;
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    keyNodes[nodesSize + i] = deferredKeys[i];
    valueNodes[nodesSize + i] = crossParseStream(ctx, deferredValues[i]);
  }
  if (ctx.features & 1024 /* Symbol */) {
    if (Symbol.iterator in properties) {
      keyNodes[size] = 0 /* SymbolIterator */;
      const items = Array.from(properties);
      valueNodes[size] = generateArrayNode4(
        ctx,
        createCrossIndexedValue(ctx, items),
        items
      );
      size++;
    }
  }
  return {
    k: keyNodes,
    v: valueNodes,
    s: size
  };
}
function generatePlainProperties4(ctx, properties) {
  const keys = Object.keys(properties);
  const size = keys.length;
  const keyNodes = new Array(size);
  const valueNodes = new Array(size);
  const deferredKeys = new Array(size);
  const deferredValues = new Array(size);
  let deferredSize = 0;
  let nodesSize = 0;
  let item;
  let escaped;
  for (const key of keys) {
    item = properties[key];
    escaped = serializeString(key);
    if (isIterable(item)) {
      deferredKeys[deferredSize] = escaped;
      deferredValues[deferredSize] = item;
      deferredSize++;
    } else {
      keyNodes[nodesSize] = escaped;
      valueNodes[nodesSize] = crossParseStream(ctx, item);
      nodesSize++;
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    keyNodes[nodesSize + i] = deferredKeys[i];
    valueNodes[nodesSize + i] = crossParseStream(ctx, deferredValues[i]);
  }
  return {
    k: keyNodes,
    v: valueNodes,
    s: size
  };
}
function generatePromiseNode3(ctx, id, current) {
  assert(ctx.features & 256 /* Promise */, new UnsupportedTypeError(current));
  current.then(
    (data) => {
      if (ctx.alive) {
        ctx.onParse({
          t: 29 /* PromiseResolve */,
          i: id,
          s: void 0,
          l: void 0,
          c: void 0,
          m: void 0,
          p: void 0,
          e: void 0,
          a: void 0,
          f: crossParseStream(ctx, data),
          b: void 0,
          o: void 0
        }, false);
        popPendingState(ctx);
      }
    },
    (data) => {
      if (ctx.alive) {
        ctx.onParse({
          t: 30 /* PromiseReject */,
          i: id,
          s: void 0,
          l: void 0,
          c: void 0,
          m: void 0,
          p: void 0,
          e: void 0,
          a: void 0,
          f: crossParseStream(ctx, data),
          b: void 0,
          o: void 0
        }, false);
        popPendingState(ctx);
      }
    }
  );
  pushPendingState(ctx);
  return {
    t: 28 /* PromiseConstructor */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateObjectNode4(ctx, id, current, empty) {
  return {
    t: empty ? 11 /* NullConstructor */ : 10 /* Object */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: generateProperties4(ctx, current),
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: getObjectFlag(current)
  };
}
function generateAggregateErrorNode4(ctx, id, current) {
  const options = getErrorOptions(ctx, current);
  const optionsNode = options ? generateProperties4(ctx, options) : void 0;
  return {
    t: 14 /* AggregateError */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: serializeString(current.message),
    p: optionsNode,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateErrorNode4(ctx, id, current) {
  const options = getErrorOptions(ctx, current);
  const optionsNode = options ? generateProperties4(ctx, options) : void 0;
  return {
    t: 13 /* Error */,
    i: id,
    s: void 0,
    l: void 0,
    c: getErrorConstructorName(current),
    m: serializeString(current.message),
    p: optionsNode,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateHeadersNode4(ctx, id, current) {
  assert(ctx.features & 8192 /* WebAPI */, new UnsupportedTypeError(current));
  const items = {};
  current.forEach((value, key) => {
    items[key] = value;
  });
  return {
    t: 25 /* Headers */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: generatePlainProperties4(ctx, items),
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateFormDataNode4(ctx, id, current) {
  assert(ctx.features & 8192 /* WebAPI */, new UnsupportedTypeError(current));
  const items = {};
  current.forEach((value, key) => {
    items[key] = value;
  });
  return {
    t: 26 /* FormData */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: generatePlainProperties4(ctx, items),
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateBoxedNode4(ctx, id, current) {
  return {
    t: 27 /* Boxed */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: crossParseStream(ctx, current.valueOf()),
    b: void 0,
    o: void 0
  };
}
function generateReadableStreamNode(ctx, id, current) {
  assert(ctx.features & 8192 /* WebAPI */, new UnsupportedTypeError(current));
  const reader = current.getReader();
  pushPendingState(ctx);
  function push() {
    reader.read().then(
      (data) => {
        if (ctx.alive) {
          if (data.done) {
            ctx.onParse({
              t: 33 /* ReadableStreamClose */,
              i: id,
              s: void 0,
              l: void 0,
              c: void 0,
              m: void 0,
              p: void 0,
              e: void 0,
              a: void 0,
              f: void 0,
              b: void 0,
              o: void 0
            }, false);
            popPendingState(ctx);
          } else {
            ctx.onParse({
              t: 32 /* ReadableStreamEnqueue */,
              i: id,
              s: void 0,
              l: void 0,
              c: void 0,
              m: void 0,
              p: void 0,
              e: void 0,
              a: void 0,
              f: crossParseStream(ctx, data.value),
              b: void 0,
              o: void 0
            }, false);
            push();
          }
        }
      },
      (value) => {
        if (ctx.alive) {
          ctx.onParse({
            t: 34 /* ReadableStreamError */,
            i: id,
            s: void 0,
            l: void 0,
            c: void 0,
            m: void 0,
            p: void 0,
            e: void 0,
            a: void 0,
            f: crossParseStream(ctx, value),
            b: void 0,
            o: void 0
          }, false);
          popPendingState(ctx);
        }
      }
    );
  }
  push();
  return {
    t: 31 /* ReadableStreamConstructor */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function parseObject4(ctx, current) {
  if (!current) {
    return NULL_NODE;
  }
  const registeredID = ctx.refs.get(current);
  if (registeredID != null) {
    return createIndexedValueNode(registeredID);
  }
  const id = ctx.refs.size;
  ctx.refs.set(current, id);
  if (hasReferenceID(current)) {
    return createReferenceNode(id, current);
  }
  if (Array.isArray(current)) {
    return generateArrayNode4(ctx, id, current);
  }
  switch (current.constructor) {
    case Number:
    case Boolean:
    case String:
    case BigInt:
    case Function:
    case Symbol:
      return generateBoxedNode4(ctx, id, current);
    case Date:
      return createDateNode(id, current);
    case RegExp:
      return createRegExpNode(id, current);
    case Promise:
      return generatePromiseNode3(ctx, id, current);
    case ArrayBuffer:
      return createArrayBufferNode(id, current);
    case Int8Array:
    case Int16Array:
    case Int32Array:
    case Uint8Array:
    case Uint16Array:
    case Uint32Array:
    case Uint8ClampedArray:
    case Float32Array:
    case Float64Array:
      return createTypedArrayNode2(ctx, id, current);
    case BigInt64Array:
    case BigUint64Array:
      return createBigIntTypedArrayNode2(ctx, id, current);
    case DataView:
      return createDataViewNode2(ctx, id, current);
    case Map:
      return generateMapNode4(
        ctx,
        id,
        current
      );
    case Set:
      return generateSetNode4(
        ctx,
        id,
        current
      );
    case Object:
      return generateObjectNode4(
        ctx,
        id,
        current,
        false
      );
    case void 0:
      return generateObjectNode4(
        ctx,
        id,
        current,
        true
      );
    case AggregateError:
      if (ctx.features & 1 /* AggregateError */) {
        return generateAggregateErrorNode4(ctx, id, current);
      }
      return generateErrorNode4(ctx, id, current);
    case Error:
    case EvalError:
    case RangeError:
    case ReferenceError:
    case SyntaxError:
    case TypeError:
    case URIError:
      return generateErrorNode4(ctx, id, current);
    case URL:
      return createURLNode(ctx, id, current);
    case URLSearchParams:
      return createURLSearchParamsNode(ctx, id, current);
    case Headers:
      return generateHeadersNode4(ctx, id, current);
    case FormData:
      return generateFormDataNode4(ctx, id, current);
    case ReadableStream:
      return generateReadableStreamNode(ctx, id, current);
    default:
      break;
  }
  if (current instanceof AggregateError) {
    if (ctx.features & 1 /* AggregateError */) {
      return generateAggregateErrorNode4(ctx, id, current);
    }
    return generateErrorNode4(ctx, id, current);
  }
  if (current instanceof Error) {
    return generateErrorNode4(ctx, id, current);
  }
  if (current instanceof Promise) {
    return generatePromiseNode3(ctx, id, current);
  }
  if (Symbol.iterator in current) {
    return generateObjectNode4(ctx, id, current, !!current.constructor);
  }
  throw new UnsupportedTypeError(current);
}
function crossParseStream(ctx, current) {
  switch (typeof current) {
    case "boolean":
      return current ? TRUE_NODE : FALSE_NODE;
    case "undefined":
      return UNDEFINED_NODE;
    case "string":
      return createStringNode(current);
    case "number":
      return createNumberNode(current);
    case "bigint":
      return createBigIntNode(ctx, current);
    case "object":
      return parseObject4(ctx, current);
    case "symbol":
      return createSymbolNode2(ctx, current);
    case "function":
      return createFunctionNode2(ctx, current);
    default:
      throw new UnsupportedTypeError(current);
  }
}

// src/core/cross/sync.ts
function generateNodeList5(ctx, current) {
  const size = current.length;
  const nodes = new Array(size);
  const deferred = new Array(size);
  let item;
  for (let i = 0; i < size; i++) {
    if (i in current) {
      item = current[i];
      if (isIterable(item)) {
        deferred[i] = item;
      } else {
        nodes[i] = crossParseSync(ctx, item);
      }
    }
  }
  for (let i = 0; i < size; i++) {
    if (i in deferred) {
      nodes[i] = crossParseSync(ctx, deferred[i]);
    }
  }
  return nodes;
}
function generateArrayNode5(ctx, id, current) {
  return {
    t: 9 /* Array */,
    i: id,
    s: void 0,
    l: current.length,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: generateNodeList5(ctx, current),
    f: void 0,
    b: void 0,
    o: getObjectFlag(current)
  };
}
function generateMapNode5(ctx, id, current) {
  assert(ctx.features & 32 /* Map */, new UnsupportedTypeError(current));
  const len = current.size;
  const keyNodes = new Array(len);
  const valueNodes = new Array(len);
  const deferredKey = new Array(len);
  const deferredValue = new Array(len);
  let deferredSize = 0;
  let nodeSize = 0;
  for (const [key, value] of current.entries()) {
    if (isIterable(key) || isIterable(value)) {
      deferredKey[deferredSize] = key;
      deferredValue[deferredSize] = value;
      deferredSize++;
    } else {
      keyNodes[nodeSize] = crossParseSync(ctx, key);
      valueNodes[nodeSize] = crossParseSync(ctx, value);
      nodeSize++;
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    keyNodes[nodeSize + i] = crossParseSync(ctx, deferredKey[i]);
    valueNodes[nodeSize + i] = crossParseSync(ctx, deferredValue[i]);
  }
  return {
    t: 8 /* Map */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: { k: keyNodes, v: valueNodes, s: len },
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateSetNode5(ctx, id, current) {
  assert(ctx.features & 512 /* Set */, new UnsupportedTypeError(current));
  const len = current.size;
  const nodes = new Array(len);
  const deferred = new Array(len);
  let deferredSize = 0;
  let nodeSize = 0;
  for (const item of current.keys()) {
    if (isIterable(item)) {
      deferred[deferredSize++] = item;
    } else {
      nodes[nodeSize++] = crossParseSync(ctx, item);
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    nodes[nodeSize + i] = crossParseSync(ctx, deferred[i]);
  }
  return {
    t: 7 /* Set */,
    i: id,
    s: void 0,
    l: len,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: nodes,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateProperties5(ctx, properties) {
  const keys = Object.keys(properties);
  let size = keys.length;
  const keyNodes = new Array(size);
  const valueNodes = new Array(size);
  const deferredKeys = new Array(size);
  const deferredValues = new Array(size);
  let deferredSize = 0;
  let nodesSize = 0;
  let item;
  let escaped;
  for (const key of keys) {
    item = properties[key];
    escaped = serializeString(key);
    if (isIterable(item)) {
      deferredKeys[deferredSize] = escaped;
      deferredValues[deferredSize] = item;
      deferredSize++;
    } else {
      keyNodes[nodesSize] = escaped;
      valueNodes[nodesSize] = crossParseSync(ctx, item);
      nodesSize++;
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    keyNodes[nodesSize + i] = deferredKeys[i];
    valueNodes[nodesSize + i] = crossParseSync(ctx, deferredValues[i]);
  }
  if (ctx.features & 1024 /* Symbol */) {
    if (Symbol.iterator in properties) {
      keyNodes[size] = 0 /* SymbolIterator */;
      const items = Array.from(properties);
      valueNodes[size] = generateArrayNode5(ctx, createCrossIndexedValue(ctx, items), items);
      size++;
    }
  }
  return {
    k: keyNodes,
    v: valueNodes,
    s: size
  };
}
function generatePlainProperties5(ctx, properties) {
  const keys = Object.keys(properties);
  const size = keys.length;
  const keyNodes = new Array(size);
  const valueNodes = new Array(size);
  const deferredKeys = new Array(size);
  const deferredValues = new Array(size);
  let deferredSize = 0;
  let nodesSize = 0;
  let item;
  let escaped;
  for (const key of keys) {
    item = properties[key];
    escaped = serializeString(key);
    if (isIterable(item)) {
      deferredKeys[deferredSize] = escaped;
      deferredValues[deferredSize] = item;
      deferredSize++;
    } else {
      keyNodes[nodesSize] = escaped;
      valueNodes[nodesSize] = crossParseSync(ctx, item);
      nodesSize++;
    }
  }
  for (let i = 0; i < deferredSize; i++) {
    keyNodes[nodesSize + i] = deferredKeys[i];
    valueNodes[nodesSize + i] = crossParseSync(ctx, deferredValues[i]);
  }
  return {
    k: keyNodes,
    v: valueNodes,
    s: size
  };
}
function generateObjectNode5(ctx, id, current, empty) {
  return {
    t: empty ? 11 /* NullConstructor */ : 10 /* Object */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: generateProperties5(ctx, current),
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: getObjectFlag(current)
  };
}
function generateAggregateErrorNode5(ctx, id, current) {
  const options = getErrorOptions(ctx, current);
  const optionsNode = options ? generateProperties5(ctx, options) : void 0;
  return {
    t: 14 /* AggregateError */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: serializeString(current.message),
    p: optionsNode,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateErrorNode5(ctx, id, current) {
  const options = getErrorOptions(ctx, current);
  const optionsNode = options ? generateProperties5(ctx, options) : void 0;
  return {
    t: 13 /* Error */,
    i: id,
    s: void 0,
    l: void 0,
    c: getErrorConstructorName(current),
    m: serializeString(current.message),
    p: optionsNode,
    e: void 0,
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateHeadersNode5(ctx, id, current) {
  assert(ctx.features & 8192 /* WebAPI */, new UnsupportedTypeError(current));
  const items = {};
  current.forEach((value, key) => {
    items[key] = value;
  });
  return {
    t: 25 /* Headers */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: generatePlainProperties5(ctx, items),
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateFormDataNode5(ctx, id, current) {
  assert(ctx.features & 8192 /* WebAPI */, new UnsupportedTypeError(current));
  const items = {};
  current.forEach((value, key) => {
    items[key] = value;
  });
  return {
    t: 26 /* FormData */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: generatePlainProperties5(ctx, items),
    a: void 0,
    f: void 0,
    b: void 0,
    o: void 0
  };
}
function generateBoxedNode5(ctx, id, current) {
  return {
    t: 27 /* Boxed */,
    i: id,
    s: void 0,
    l: void 0,
    c: void 0,
    m: void 0,
    p: void 0,
    e: void 0,
    a: void 0,
    f: crossParseSync(ctx, current.valueOf()),
    b: void 0,
    o: void 0
  };
}
function parseObject5(ctx, current) {
  if (!current) {
    return NULL_NODE;
  }
  const registeredID = ctx.refs.get(current);
  if (registeredID != null) {
    return createIndexedValueNode(registeredID);
  }
  const id = ctx.refs.size;
  ctx.refs.set(current, id);
  if (hasReferenceID(current)) {
    return createReferenceNode(id, current);
  }
  if (Array.isArray(current)) {
    return generateArrayNode5(ctx, id, current);
  }
  switch (current.constructor) {
    case Number:
    case Boolean:
    case String:
    case BigInt:
    case Function:
    case Symbol:
      return generateBoxedNode5(ctx, id, current);
    case Date:
      return createDateNode(id, current);
    case RegExp:
      return createRegExpNode(id, current);
    case ArrayBuffer:
      return createArrayBufferNode(id, current);
    case Int8Array:
    case Int16Array:
    case Int32Array:
    case Uint8Array:
    case Uint16Array:
    case Uint32Array:
    case Uint8ClampedArray:
    case Float32Array:
    case Float64Array:
      return createTypedArrayNode2(ctx, id, current);
    case BigInt64Array:
    case BigUint64Array:
      return createBigIntTypedArrayNode2(ctx, id, current);
    case DataView:
      return createDataViewNode2(ctx, id, current);
    case Map:
      return generateMapNode5(ctx, id, current);
    case Set:
      return generateSetNode5(ctx, id, current);
    case Object:
      return generateObjectNode5(
        ctx,
        id,
        current,
        false
      );
    case void 0:
      return generateObjectNode5(
        ctx,
        id,
        current,
        true
      );
    case AggregateError:
      if (ctx.features & 1 /* AggregateError */) {
        return generateAggregateErrorNode5(ctx, id, current);
      }
      return generateErrorNode5(ctx, id, current);
    case Error:
    case EvalError:
    case RangeError:
    case ReferenceError:
    case SyntaxError:
    case TypeError:
    case URIError:
      return generateErrorNode5(ctx, id, current);
    case URL:
      return createURLNode(ctx, id, current);
    case URLSearchParams:
      return createURLSearchParamsNode(ctx, id, current);
    case Headers:
      return generateHeadersNode5(ctx, id, current);
    case FormData:
      return generateFormDataNode5(ctx, id, current);
    default:
      break;
  }
  if (current instanceof AggregateError) {
    if (ctx.features & 1 /* AggregateError */) {
      return generateAggregateErrorNode5(ctx, id, current);
    }
    return generateErrorNode5(ctx, id, current);
  }
  if (current instanceof Error) {
    return generateErrorNode5(ctx, id, current);
  }
  if (Symbol.iterator in current) {
    return generateObjectNode5(ctx, id, current, !!current.constructor);
  }
  throw new UnsupportedTypeError(current);
}
function crossParseSync(ctx, current) {
  switch (typeof current) {
    case "boolean":
      return current ? TRUE_NODE : FALSE_NODE;
    case "undefined":
      return UNDEFINED_NODE;
    case "string":
      return createStringNode(current);
    case "number":
      return createNumberNode(current);
    case "bigint":
      return createBigIntNode(ctx, current);
    case "object":
      return parseObject5(ctx, current);
    case "symbol":
      return createSymbolNode2(ctx, current);
    case "function":
      return createFunctionNode2(ctx, current);
    default:
      throw new UnsupportedTypeError(current);
  }
}

// src/core/cross/index.ts
function finalize2(ctx, scopeId, id, result) {
  if (id == null) {
    return result;
  }
  const patches = resolvePatches2(ctx);
  const ref = getRefExpr(id);
  const params = scopeId == null ? "" : GLOBAL_CONTEXT_REFERENCES;
  const mainBody = patches ? result + "," + patches : result;
  if (params === "") {
    return patches ? "(" + mainBody + ref + ")" : mainBody;
  }
  const args = scopeId == null ? "()" : "(" + GLOBAL_CONTEXT_REFERENCES + '["' + serializeString(scopeId) + '"])';
  const body = mainBody + (patches ? ref : "");
  if (ctx.features & 4 /* ArrowFunction */) {
    return "(" + params + "=>(" + body + "))" + args;
  }
  return "(function(" + params + "){return " + body + "})" + args;
}
function crossSerialize(source, options) {
  const ctx = createCrossParserContext(options);
  const tree = crossParseSync(ctx, source);
  const serial = createCrossSerializerContext({
    features: ctx.features
  });
  const result = crossSerializeTree(serial, tree);
  return finalize2(
    serial,
    ctx.scopeId,
    tree.i,
    result
  );
}
async function crossSerializeAsync(source, options) {
  const ctx = createCrossParserContext(options);
  const tree = await crossParseAsync(ctx, source);
  const serial = createCrossSerializerContext({
    features: ctx.features
  });
  const result = crossSerializeTree(serial, tree);
  return finalize2(
    serial,
    ctx.scopeId,
    tree.i,
    result
  );
}
function crossSerializeStream(source, options) {
  const ctx = createStreamingCrossParserContext({
    scopeId: options.scopeId,
    refs: options.refs,
    disabledFeatures: options.disabledFeatures,
    onParse(node, initial) {
      const serial = createCrossSerializerContext({
        features: ctx.features
      });
      options.onSerialize(
        finalize2(
          serial,
          ctx.scopeId,
          node.i,
          crossSerializeTree(serial, node)
        ),
        initial
      );
    },
    onDone: options.onDone
  });
  ctx.onParse(crossParseStream(ctx, source), true);
  if (ctx.pending <= 0) {
    ctx.onDone();
    ctx.alive = false;
  }
  return () => {
    if (ctx.alive) {
      ctx.alive = false;
      ctx.onDone();
    }
  };
}

// src/core/Serializer.ts
var Serializer = class {
  constructor(options) {
    this.options = options;
    __publicField(this, "alive", true);
    __publicField(this, "flushed", false);
    __publicField(this, "done", false);
    __publicField(this, "pending", 0);
    __publicField(this, "cleanups", []);
    __publicField(this, "refs", /* @__PURE__ */ new Map());
  }
  write(key, value) {
    if (this.alive && !this.flushed) {
      this.pending++;
      this.cleanups.push(crossSerializeStream(value, {
        scopeId: this.options.scopeId,
        refs: this.refs,
        disabledFeatures: this.options.disabledFeatures,
        onSerialize: (data, initial) => {
          if (this.alive) {
            this.options.onData(
              initial ? this.options.globalIdentifier + '["' + serializeString(key) + '"]=' + data : data
            );
          }
        },
        onDone: () => {
          if (this.alive) {
            this.pending--;
            if (this.pending <= 0 && this.flushed && !this.done && this.options.onDone) {
              this.options.onDone();
              this.done = true;
            }
          }
        }
      }));
    }
  }
  flush() {
    if (this.alive) {
      this.flushed = true;
      if (this.pending <= 0 && !this.done && this.options.onDone) {
        this.options.onDone();
        this.done = true;
      }
    }
  }
  close() {
    if (this.alive) {
      for (let i = 0, len = this.cleanups.length; i < len; i++) {
        this.cleanups[i]();
      }
      if (!this.done && this.options.onDone) {
        this.options.onDone();
        this.done = true;
      }
      this.alive = false;
    }
  }
};

// src/index.ts
var src_default = serialize;
//# sourceMappingURL=index.cjs.map
