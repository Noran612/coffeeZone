{
  "version": 3,
  "sources": ["../../@radix-ui/primitive/dist/packages/core/primitive/src/index.ts", "../../@radix-ui/primitive/dist/packages/core/primitive/src/primitive.tsx", "../../@radix-ui/react-context/dist/packages/react/context/src/index.ts", "../../@radix-ui/react-context/dist/packages/react/context/src/createContext.tsx", "../../@radix-ui/react-collection/dist/packages/react/collection/src/index.ts", "../../@radix-ui/react-collection/dist/packages/react/collection/src/Collection.tsx", "../../@radix-ui/react-use-callback-ref/dist/packages/react/use-callback-ref/src/index.ts", "../../@radix-ui/react-use-callback-ref/dist/packages/react/use-callback-ref/src/useCallbackRef.tsx", "../../@radix-ui/react-use-escape-keydown/dist/packages/react/use-escape-keydown/src/index.ts", "../../@radix-ui/react-use-escape-keydown/dist/packages/react/use-escape-keydown/src/useEscapeKeydown.tsx", "../../@radix-ui/react-dismissable-layer/dist/packages/react/dismissable-layer/src/index.ts", "../../@radix-ui/react-dismissable-layer/dist/packages/react/dismissable-layer/src/DismissableLayer.tsx", "../../@radix-ui/react-portal/dist/packages/react/portal/src/index.ts", "../../@radix-ui/react-portal/dist/packages/react/portal/src/Portal.tsx", "../../@radix-ui/react-use-layout-effect/dist/packages/react/use-layout-effect/src/index.ts", "../../@radix-ui/react-use-layout-effect/dist/packages/react/use-layout-effect/src/useLayoutEffect.tsx", "../../@radix-ui/react-presence/dist/packages/react/presence/src/index.ts", "../../@radix-ui/react-presence/dist/packages/react/presence/src/Presence.tsx", "../../@radix-ui/react-presence/dist/packages/react/presence/src/useStateMachine.tsx", "../../@radix-ui/react-use-controllable-state/dist/packages/react/use-controllable-state/src/index.ts", "../../@radix-ui/react-use-controllable-state/dist/packages/react/use-controllable-state/src/useControllableState.tsx", "../../@radix-ui/react-visually-hidden/dist/packages/react/visually-hidden/src/index.ts", "../../@radix-ui/react-visually-hidden/dist/packages/react/visually-hidden/src/VisuallyHidden.tsx", "../../@radix-ui/react-toast/dist/packages/react/toast/src/index.ts", "../../@radix-ui/react-toast/dist/packages/react/toast/src/Toast.tsx"],
  "sourcesContent": ["export { composeEventHandlers } from './primitive';\n", "function composeEventHandlers<E>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {}\n) {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event);\n\n    if (checkForDefaultPrevented === false || !((event as unknown) as Event).defaultPrevented) {\n      return ourEventHandler?.(event);\n    }\n  };\n}\n\nexport { composeEventHandlers };\n", "export { createContext, createContextScope } from './createContext';\nexport type { CreateScope, Scope } from './createContext';\n", "import * as React from 'react';\n\nfunction createContext<ContextValueType extends object | null>(\n  rootComponentName: string,\n  defaultContext?: ContextValueType\n) {\n  const Context = React.createContext<ContextValueType | undefined>(defaultContext);\n\n  function Provider(props: ContextValueType & { children: React.ReactNode }) {\n    const { children, ...context } = props;\n    // Only re-memoize when prop values change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n    return <Context.Provider value={value}>{children}</Context.Provider>;\n  }\n\n  function useContext(consumerName: string) {\n    const context = React.useContext(Context);\n    if (context) return context;\n    if (defaultContext !== undefined) return defaultContext;\n    // if a defaultContext wasn't specified, it's a required context.\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n  }\n\n  Provider.displayName = rootComponentName + 'Provider';\n  return [Provider, useContext] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * createContextScope\n * -----------------------------------------------------------------------------------------------*/\n\ntype Scope<C = any> = { [scopeName: string]: React.Context<C>[] } | undefined;\ntype ScopeHook = (scope: Scope) => { [__scopeProp: string]: Scope };\ninterface CreateScope {\n  scopeName: string;\n  (): ScopeHook;\n}\n\nfunction createContextScope(scopeName: string, createContextScopeDeps: CreateScope[] = []) {\n  let defaultContexts: any[] = [];\n\n  /* -----------------------------------------------------------------------------------------------\n   * createContext\n   * ---------------------------------------------------------------------------------------------*/\n\n  function createContext<ContextValueType extends object | null>(\n    rootComponentName: string,\n    defaultContext?: ContextValueType\n  ) {\n    const BaseContext = React.createContext<ContextValueType | undefined>(defaultContext);\n    const index = defaultContexts.length;\n    defaultContexts = [...defaultContexts, defaultContext];\n\n    function Provider(\n      props: ContextValueType & { scope: Scope<ContextValueType>; children: React.ReactNode }\n    ) {\n      const { scope, children, ...context } = props;\n      const Context = scope?.[scopeName][index] || BaseContext;\n      // Only re-memoize when prop values change\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n      return <Context.Provider value={value}>{children}</Context.Provider>;\n    }\n\n    function useContext(consumerName: string, scope: Scope<ContextValueType | undefined>) {\n      const Context = scope?.[scopeName][index] || BaseContext;\n      const context = React.useContext(Context);\n      if (context) return context;\n      if (defaultContext !== undefined) return defaultContext;\n      // if a defaultContext wasn't specified, it's a required context.\n      throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n    }\n\n    Provider.displayName = rootComponentName + 'Provider';\n    return [Provider, useContext] as const;\n  }\n\n  /* -----------------------------------------------------------------------------------------------\n   * createScope\n   * ---------------------------------------------------------------------------------------------*/\n\n  const createScope: CreateScope = () => {\n    const scopeContexts = defaultContexts.map((defaultContext) => {\n      return React.createContext(defaultContext);\n    });\n    return function useScope(scope: Scope) {\n      const contexts = scope?.[scopeName] || scopeContexts;\n      return React.useMemo(\n        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),\n        [scope, contexts]\n      );\n    };\n  };\n\n  createScope.scopeName = scopeName;\n  return [createContext, composeContextScopes(createScope, ...createContextScopeDeps)] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * composeContextScopes\n * -----------------------------------------------------------------------------------------------*/\n\nfunction composeContextScopes(...scopes: CreateScope[]) {\n  const baseScope = scopes[0];\n  if (scopes.length === 1) return baseScope;\n\n  const createScope: CreateScope = () => {\n    const scopeHooks = scopes.map((createScope) => ({\n      useScope: createScope(),\n      scopeName: createScope.scopeName,\n    }));\n\n    return function useComposedScopes(overrideScopes) {\n      const nextScopes = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {\n        // We are calling a hook inside a callback which React warns against to avoid inconsistent\n        // renders, however, scoping doesn't have render side effects so we ignore the rule.\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const scopeProps = useScope(overrideScopes);\n        const currentScope = scopeProps[`__scope${scopeName}`];\n        return { ...nextScopes, ...currentScope };\n      }, {});\n\n      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);\n    };\n  };\n\n  createScope.scopeName = baseScope.scopeName;\n  return createScope;\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nexport { createContext, createContextScope };\nexport type { CreateScope, Scope };\n", "export { createCollection } from './Collection';\nexport type { CollectionProps } from './Collection';\n", "import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Slot } from '@radix-ui/react-slot';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\ntype SlotProps = Radix.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>â€¦</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement>;\n    itemMap: Map<React.RefObject<ItemElement>, { ref: React.RefObject<ItemElement> } & ItemData>;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ children?: React.ReactNode; scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <Slot ref={composedRefs}>{children}</Slot>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <Slot {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </Slot>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n", "export { useCallbackRef } from './useCallbackRef';\n", "import * as React from 'react';\n\n/**\n * A custom hook that converts a callback to a ref to avoid triggering re-renders when passed as a\n * prop or avoid re-executing effects when passed as a dependency\n */\nfunction useCallbackRef<T extends (...args: any[]) => any>(callback: T | undefined): T {\n  const callbackRef = React.useRef(callback);\n\n  React.useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  // https://github.com/facebook/react/issues/19240\n  return React.useMemo(() => ((...args) => callbackRef.current?.(...args)) as T, []);\n}\n\nexport { useCallbackRef };\n", "export { useEscapeKeydown } from './useEscapeKeydown';\n", "import * as React from 'react';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\n/**\n * Listens for when the escape key is down\n */\nfunction useEscapeKeydown(\n  onEscapeKeyDownProp?: (event: KeyboardEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);\n\n  React.useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === 'Escape') {\n        onEscapeKeyDown(event);\n      }\n    };\n    ownerDocument.addEventListener('keydown', handleKeyDown);\n    return () => ownerDocument.removeEventListener('keydown', handleKeyDown);\n  }, [onEscapeKeyDown, ownerDocument]);\n}\n\nexport { useEscapeKeydown };\n", "export {\n  DismissableLayer,\n  DismissableLayerBranch,\n  //\n  Root,\n  Branch,\n} from './DismissableLayer';\nexport type { DismissableLayerProps } from './DismissableLayer';\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayer\n * -----------------------------------------------------------------------------------------------*/\n\nconst DISMISSABLE_LAYER_NAME = 'DismissableLayer';\nconst CONTEXT_UPDATE = 'dismissableLayer.update';\nconst POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside';\nconst FOCUS_OUTSIDE = 'dismissableLayer.focusOutside';\n\nlet originalBodyPointerEvents: string;\n\nconst DismissableLayerContext = React.createContext({\n  layers: new Set<DismissableLayerElement>(),\n  layersWithOutsidePointerEventsDisabled: new Set<DismissableLayerElement>(),\n  branches: new Set<DismissableLayerBranchElement>(),\n});\n\ntype DismissableLayerElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface DismissableLayerProps extends PrimitiveDivProps {\n  /**\n   * When `true`, hover/focus/click interactions will be disabled on elements outside\n   * the `DismissableLayer`. Users will need to click twice on outside elements to\n   * interact with them: once to close the `DismissableLayer`, and again to trigger the element.\n   */\n  disableOutsidePointerEvents?: boolean;\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void;\n  /**\n   * Event handler called when the focus moves outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onFocusOutside?: (event: FocusOutsideEvent) => void;\n  /**\n   * Event handler called when an interaction happens outside the `DismissableLayer`.\n   * Specifically, when a `pointerdown` event happens outside or focus moves outside of it.\n   * Can be prevented.\n   */\n  onInteractOutside?: (event: PointerDownOutsideEvent | FocusOutsideEvent) => void;\n  /**\n   * Handler called when the `DismissableLayer` should be dismissed\n   */\n  onDismiss?: () => void;\n}\n\nconst DismissableLayer = React.forwardRef<DismissableLayerElement, DismissableLayerProps>(\n  (props, forwardedRef) => {\n    const {\n      disableOutsidePointerEvents = false,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      ...layerProps\n    } = props;\n    const context = React.useContext(DismissableLayerContext);\n    const [node, setNode] = React.useState<DismissableLayerElement | null>(null);\n    const ownerDocument = node?.ownerDocument ?? globalThis?.document;\n    const [, force] = React.useState({});\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const layers = Array.from(context.layers);\n    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1); // prettier-ignore\n    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled); // prettier-ignore\n    const index = node ? layers.indexOf(node) : -1;\n    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;\n    const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;\n\n    const pointerDownOutside = usePointerDownOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;\n      onPointerDownOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    }, ownerDocument);\n\n    const focusOutside = useFocusOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (isFocusInBranch) return;\n      onFocusOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    }, ownerDocument);\n\n    useEscapeKeydown((event) => {\n      const isHighestLayer = index === context.layers.size - 1;\n      if (!isHighestLayer) return;\n      onEscapeKeyDown?.(event);\n      if (!event.defaultPrevented && onDismiss) {\n        event.preventDefault();\n        onDismiss();\n      }\n    }, ownerDocument);\n\n    React.useEffect(() => {\n      if (!node) return;\n      if (disableOutsidePointerEvents) {\n        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {\n          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;\n          ownerDocument.body.style.pointerEvents = 'none';\n        }\n        context.layersWithOutsidePointerEventsDisabled.add(node);\n      }\n      context.layers.add(node);\n      dispatchUpdate();\n      return () => {\n        if (\n          disableOutsidePointerEvents &&\n          context.layersWithOutsidePointerEventsDisabled.size === 1\n        ) {\n          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;\n        }\n      };\n    }, [node, ownerDocument, disableOutsidePointerEvents, context]);\n\n    /**\n     * We purposefully prevent combining this effect with the `disableOutsidePointerEvents` effect\n     * because a change to `disableOutsidePointerEvents` would remove this layer from the stack\n     * and add it to the end again so the layering order wouldn't be _creation order_.\n     * We only want them to be removed from context stacks when unmounted.\n     */\n    React.useEffect(() => {\n      return () => {\n        if (!node) return;\n        context.layers.delete(node);\n        context.layersWithOutsidePointerEventsDisabled.delete(node);\n        dispatchUpdate();\n      };\n    }, [node, context]);\n\n    React.useEffect(() => {\n      const handleUpdate = () => force({});\n      document.addEventListener(CONTEXT_UPDATE, handleUpdate);\n      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);\n    }, []);\n\n    return (\n      <Primitive.div\n        {...layerProps}\n        ref={composedRefs}\n        style={{\n          pointerEvents: isBodyPointerEventsDisabled\n            ? isPointerEventsEnabled\n              ? 'auto'\n              : 'none'\n            : undefined,\n          ...props.style,\n        }}\n        onFocusCapture={composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture)}\n        onBlurCapture={composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture)}\n        onPointerDownCapture={composeEventHandlers(\n          props.onPointerDownCapture,\n          pointerDownOutside.onPointerDownCapture\n        )}\n      />\n    );\n  }\n);\n\nDismissableLayer.displayName = DISMISSABLE_LAYER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayerBranch\n * -----------------------------------------------------------------------------------------------*/\n\nconst BRANCH_NAME = 'DismissableLayerBranch';\n\ntype DismissableLayerBranchElement = React.ElementRef<typeof Primitive.div>;\ninterface DismissableLayerBranchProps extends PrimitiveDivProps {}\n\nconst DismissableLayerBranch = React.forwardRef<\n  DismissableLayerBranchElement,\n  DismissableLayerBranchProps\n>((props, forwardedRef) => {\n  const context = React.useContext(DismissableLayerContext);\n  const ref = React.useRef<DismissableLayerBranchElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      context.branches.add(node);\n      return () => {\n        context.branches.delete(node);\n      };\n    }\n  }, [context.branches]);\n\n  return <Primitive.div {...props} ref={composedRefs} />;\n});\n\nDismissableLayerBranch.displayName = BRANCH_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype PointerDownOutsideEvent = CustomEvent<{ originalEvent: PointerEvent }>;\ntype FocusOutsideEvent = CustomEvent<{ originalEvent: FocusEvent }>;\n\n/**\n * Listens for `pointerdown` outside a react subtree. We use `pointerdown` rather than `pointerup`\n * to mimic layer dismissing behaviour present in OS.\n * Returns props to pass to the node we want to check for outside events.\n */\nfunction usePointerDownOutside(\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside) as EventListener;\n  const isPointerInsideReactTreeRef = React.useRef(false);\n  const handleClickRef = React.useRef(() => {});\n\n  React.useEffect(() => {\n    const handlePointerDown = (event: PointerEvent) => {\n      if (event.target && !isPointerInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n\n        function handleAndDispatchPointerDownOutsideEvent() {\n          handleAndDispatchCustomEvent(\n            POINTER_DOWN_OUTSIDE,\n            handlePointerDownOutside,\n            eventDetail,\n            { discrete: true }\n          );\n        }\n\n        /**\n         * On touch devices, we need to wait for a click event because browsers implement\n         * a ~350ms delay between the time the user stops touching the display and when the\n         * browser executres events. We need to ensure we don't reactivate pointer-events within\n         * this timeframe otherwise the browser may execute events that should have been prevented.\n         *\n         * Additionally, this also lets us deal automatically with cancellations when a click event\n         * isn't raised because the page was considered scrolled/drag-scrolled, long-pressed, etc.\n         *\n         * This is why we also continuously remove the previous listener, because we cannot be\n         * certain that it was raised, and therefore cleaned-up.\n         */\n        if (event.pointerType === 'touch') {\n          ownerDocument.removeEventListener('click', handleClickRef.current);\n          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;\n          ownerDocument.addEventListener('click', handleClickRef.current, { once: true });\n        } else {\n          handleAndDispatchPointerDownOutsideEvent();\n        }\n      } else {\n        // We need to remove the event listener in case the outside click has been canceled.\n        // See: https://github.com/radix-ui/primitives/issues/2171\n        ownerDocument.removeEventListener('click', handleClickRef.current);\n      }\n      isPointerInsideReactTreeRef.current = false;\n    };\n    /**\n     * if this hook executes in a component that mounts via a `pointerdown` event, the event\n     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid\n     * this by delaying the event listener registration on the document.\n     * This is not React specific, but rather how the DOM works, ie:\n     * ```\n     * button.addEventListener('pointerdown', () => {\n     *   console.log('I will log');\n     *   document.addEventListener('pointerdown', () => {\n     *     console.log('I will also log');\n     *   })\n     * });\n     */\n    const timerId = window.setTimeout(() => {\n      ownerDocument.addEventListener('pointerdown', handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      ownerDocument.removeEventListener('pointerdown', handlePointerDown);\n      ownerDocument.removeEventListener('click', handleClickRef.current);\n    };\n  }, [ownerDocument, handlePointerDownOutside]);\n\n  return {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => (isPointerInsideReactTreeRef.current = true),\n  };\n}\n\n/**\n * Listens for when focus happens outside a react subtree.\n * Returns props to pass to the root (node) of the subtree we want to check.\n */\nfunction useFocusOutside(\n  onFocusOutside?: (event: FocusOutsideEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const handleFocusOutside = useCallbackRef(onFocusOutside) as EventListener;\n  const isFocusInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handleFocus = (event: FocusEvent) => {\n      if (event.target && !isFocusInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {\n          discrete: false,\n        });\n      }\n    };\n    ownerDocument.addEventListener('focusin', handleFocus);\n    return () => ownerDocument.removeEventListener('focusin', handleFocus);\n  }, [ownerDocument, handleFocusOutside]);\n\n  return {\n    onFocusCapture: () => (isFocusInsideReactTreeRef.current = true),\n    onBlurCapture: () => (isFocusInsideReactTreeRef.current = false),\n  };\n}\n\nfunction dispatchUpdate() {\n  const event = new CustomEvent(CONTEXT_UPDATE);\n  document.dispatchEvent(event);\n}\n\nfunction handleAndDispatchCustomEvent<E extends CustomEvent, OriginalEvent extends Event>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: OriginalEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const target = detail.originalEvent.target;\n  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });\n  if (handler) target.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(target, event);\n  } else {\n    target.dispatchEvent(event);\n  }\n}\n\nconst Root = DismissableLayer;\nconst Branch = DismissableLayerBranch;\n\nexport {\n  DismissableLayer,\n  DismissableLayerBranch,\n  //\n  Root,\n  Branch,\n};\nexport type { DismissableLayerProps };\n", "export {\n  Portal,\n  //\n  Root,\n} from './Portal';\nexport type { PortalProps } from './Portal';\n", "import * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * Portal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'Portal';\n\ntype PortalElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface PortalProps extends PrimitiveDivProps {\n  /**\n   * An optional container where the portaled content should be appended.\n   */\n  container?: HTMLElement | null;\n}\n\nconst Portal = React.forwardRef<PortalElement, PortalProps>((props, forwardedRef) => {\n  const { container = globalThis?.document?.body, ...portalProps } = props;\n  return container\n    ? ReactDOM.createPortal(<Primitive.div {...portalProps} ref={forwardedRef} />, container)\n    : null;\n});\n\nPortal.displayName = PORTAL_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Portal;\n\nexport {\n  Portal,\n  //\n  Root,\n};\nexport type { PortalProps };\n", "export { useLayoutEffect } from './useLayoutEffect';\n", "import * as React from 'react';\n\n/**\n * On the server, React emits a warning when calling `useLayoutEffect`.\n * This is because neither `useLayoutEffect` nor `useEffect` run on the server.\n * We use this safe version which suppresses the warning by replacing it with a noop on the server.\n *\n * See: https://reactjs.org/docs/hooks-reference.html#uselayouteffect\n */\nconst useLayoutEffect = Boolean(globalThis?.document) ? React.useLayoutEffect : () => {};\n\nexport { useLayoutEffect };\n", "export { Presence } from './Presence';\nexport type { PresenceProps } from './Presence';\n", "import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useStateMachine } from './useStateMachine';\n\ninterface PresenceProps {\n  children: React.ReactElement | ((props: { present: boolean }) => React.ReactElement);\n  present: boolean;\n}\n\nconst Presence: React.FC<PresenceProps> = (props) => {\n  const { present, children } = props;\n  const presence = usePresence(present);\n\n  const child = (\n    typeof children === 'function'\n      ? children({ present: presence.isPresent })\n      : React.Children.only(children)\n  ) as React.ReactElement;\n\n  const ref = useComposedRefs(presence.ref, (child as any).ref);\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;\n};\n\nPresence.displayName = 'Presence';\n\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction usePresence(present: boolean) {\n  const [node, setNode] = React.useState<HTMLElement>();\n  const stylesRef = React.useRef<CSSStyleDeclaration>({} as any);\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>('none');\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  });\n\n  React.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';\n  }, [state]);\n\n  useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send('MOUNT');\n      } else if (currentAnimationName === 'none' || styles?.display === 'none') {\n        // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');\n      } else {\n        /**\n         * When `present` changes to `false`, we check changes to animation-name to\n         * determine whether an animation has started. We chose this approach (reading\n         * computed styles) because there is no `animationrun` event and `animationstart`\n         * fires after `animation-delay` has expired which would be too late.\n         */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send('ANIMATION_OUT');\n        } else {\n          send('UNMOUNT');\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n\n  useLayoutEffect(() => {\n    if (node) {\n      /**\n       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n       * make sure we only trigger ANIMATION_END for the currently active animation.\n       */\n      const handleAnimationEnd = (event: AnimationEvent) => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node && isCurrentAnimation) {\n          // With React 18 concurrency this update is applied\n          // a frame after the animation ends, creating a flash of visible content.\n          // By manually flushing we ensure they sync within a frame, removing the flash.\n          ReactDOM.flushSync(() => send('ANIMATION_END'));\n        }\n      };\n      const handleAnimationStart = (event: AnimationEvent) => {\n        if (event.target === node) {\n          // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n      node.addEventListener('animationstart', handleAnimationStart);\n      node.addEventListener('animationcancel', handleAnimationEnd);\n      node.addEventListener('animationend', handleAnimationEnd);\n      return () => {\n        node.removeEventListener('animationstart', handleAnimationStart);\n        node.removeEventListener('animationcancel', handleAnimationEnd);\n        node.removeEventListener('animationend', handleAnimationEnd);\n      };\n    } else {\n      // Transition to the unmounted state if the node is removed prematurely.\n      // We avoid doing so during cleanup as the node may change but still exist.\n      send('ANIMATION_END');\n    }\n  }, [node, send]);\n\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: React.useCallback((node: HTMLElement) => {\n      if (node) stylesRef.current = getComputedStyle(node);\n      setNode(node);\n    }, []),\n  };\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getAnimationName(styles?: CSSStyleDeclaration) {\n  return styles?.animationName || 'none';\n}\n\nexport { Presence };\nexport type { PresenceProps };\n", "import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n// ðŸ¤¯ https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n", "export { useControllableState } from './useControllableState';\n", "import * as React from 'react';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\ntype UseControllableStateParams<T> = {\n  prop?: T | undefined;\n  defaultProp?: T | undefined;\n  onChange?: (state: T) => void;\n};\n\ntype SetStateFn<T> = (prevState?: T) => T;\n\nfunction useControllableState<T>({\n  prop,\n  defaultProp,\n  onChange = () => {},\n}: UseControllableStateParams<T>) {\n  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });\n  const isControlled = prop !== undefined;\n  const value = isControlled ? prop : uncontrolledProp;\n  const handleChange = useCallbackRef(onChange);\n\n  const setValue: React.Dispatch<React.SetStateAction<T | undefined>> = React.useCallback(\n    (nextValue) => {\n      if (isControlled) {\n        const setter = nextValue as SetStateFn<T>;\n        const value = typeof nextValue === 'function' ? setter(prop) : nextValue;\n        if (value !== prop) handleChange(value as T);\n      } else {\n        setUncontrolledProp(nextValue);\n      }\n    },\n    [isControlled, prop, setUncontrolledProp, handleChange]\n  );\n\n  return [value, setValue] as const;\n}\n\nfunction useUncontrolledState<T>({\n  defaultProp,\n  onChange,\n}: Omit<UseControllableStateParams<T>, 'prop'>) {\n  const uncontrolledState = React.useState<T | undefined>(defaultProp);\n  const [value] = uncontrolledState;\n  const prevValueRef = React.useRef(value);\n  const handleChange = useCallbackRef(onChange);\n\n  React.useEffect(() => {\n    if (prevValueRef.current !== value) {\n      handleChange(value as T);\n      prevValueRef.current = value;\n    }\n  }, [value, prevValueRef, handleChange]);\n\n  return uncontrolledState;\n}\n\nexport { useControllableState };\n", "export {\n  VisuallyHidden,\n  //\n  Root,\n} from './VisuallyHidden';\nexport type { VisuallyHiddenProps } from './VisuallyHidden';\n", "import * as React from 'react';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * VisuallyHidden\n * -----------------------------------------------------------------------------------------------*/\n\nconst NAME = 'VisuallyHidden';\n\ntype VisuallyHiddenElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface VisuallyHiddenProps extends PrimitiveSpanProps {}\n\nconst VisuallyHidden = React.forwardRef<VisuallyHiddenElement, VisuallyHiddenProps>(\n  (props, forwardedRef) => {\n    return (\n      <Primitive.span\n        {...props}\n        ref={forwardedRef}\n        style={{\n          // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss\n          position: 'absolute',\n          border: 0,\n          width: 1,\n          height: 1,\n          padding: 0,\n          margin: -1,\n          overflow: 'hidden',\n          clip: 'rect(0, 0, 0, 0)',\n          whiteSpace: 'nowrap',\n          wordWrap: 'normal',\n          ...props.style,\n        }}\n      />\n    );\n  }\n);\n\nVisuallyHidden.displayName = NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = VisuallyHidden;\n\nexport {\n  VisuallyHidden,\n  //\n  Root,\n};\nexport type { VisuallyHiddenProps };\n", "export {\n  createToastScope,\n  //\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastAction,\n  ToastClose,\n  //\n  Provider,\n  Viewport,\n  Root,\n  Title,\n  Description,\n  Action,\n  Close,\n} from './Toast';\nexport type {\n  ToastProviderProps,\n  ToastViewportProps,\n  ToastProps,\n  ToastTitleProps,\n  ToastDescriptionProps,\n  ToastActionProps,\n  ToastCloseProps,\n} from './Toast';\n", "import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { createContextScope } from '@radix-ui/react-context';\nimport * as DismissableLayer from '@radix-ui/react-dismissable-layer';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { VisuallyHidden } from '@radix-ui/react-visually-hidden';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * ToastProvider\n * -----------------------------------------------------------------------------------------------*/\n\nconst PROVIDER_NAME = 'ToastProvider';\n\nconst [Collection, useCollection, createCollectionScope] = createCollection<ToastElement>('Toast');\n\ntype SwipeDirection = 'up' | 'down' | 'left' | 'right';\ntype ToastProviderContextValue = {\n  label: string;\n  duration: number;\n  swipeDirection: SwipeDirection;\n  swipeThreshold: number;\n  toastCount: number;\n  viewport: ToastViewportElement | null;\n  onViewportChange(viewport: ToastViewportElement): void;\n  onToastAdd(): void;\n  onToastRemove(): void;\n  isFocusedToastEscapeKeyDownRef: React.MutableRefObject<boolean>;\n  isClosePausedRef: React.MutableRefObject<boolean>;\n};\n\ntype ScopedProps<P> = P & { __scopeToast?: Scope };\nconst [createToastContext, createToastScope] = createContextScope('Toast', [createCollectionScope]);\nconst [ToastProviderProvider, useToastProviderContext] =\n  createToastContext<ToastProviderContextValue>(PROVIDER_NAME);\n\ninterface ToastProviderProps {\n  children?: React.ReactNode;\n  /**\n   * An author-localized label for each toast. Used to help screen reader users\n   * associate the interruption with a toast.\n   * @defaultValue 'Notification'\n   */\n  label?: string;\n  /**\n   * Time in milliseconds that each toast should remain visible for.\n   * @defaultValue 5000\n   */\n  duration?: number;\n  /**\n   * Direction of pointer swipe that should close the toast.\n   * @defaultValue 'right'\n   */\n  swipeDirection?: SwipeDirection;\n  /**\n   * Distance in pixels that the swipe must pass before a close is triggered.\n   * @defaultValue 50\n   */\n  swipeThreshold?: number;\n}\n\nconst ToastProvider: React.FC<ToastProviderProps> = (props: ScopedProps<ToastProviderProps>) => {\n  const {\n    __scopeToast,\n    label = 'Notification',\n    duration = 5000,\n    swipeDirection = 'right',\n    swipeThreshold = 50,\n    children,\n  } = props;\n  const [viewport, setViewport] = React.useState<ToastViewportElement | null>(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n  return (\n    <Collection.Provider scope={__scopeToast}>\n      <ToastProviderProvider\n        scope={__scopeToast}\n        label={label}\n        duration={duration}\n        swipeDirection={swipeDirection}\n        swipeThreshold={swipeThreshold}\n        toastCount={toastCount}\n        viewport={viewport}\n        onViewportChange={setViewport}\n        onToastAdd={React.useCallback(() => setToastCount((prevCount) => prevCount + 1), [])}\n        onToastRemove={React.useCallback(() => setToastCount((prevCount) => prevCount - 1), [])}\n        isFocusedToastEscapeKeyDownRef={isFocusedToastEscapeKeyDownRef}\n        isClosePausedRef={isClosePausedRef}\n      >\n        {children}\n      </ToastProviderProvider>\n    </Collection.Provider>\n  );\n};\n\nToastProvider.propTypes = {\n  label(props) {\n    if (props.label && typeof props.label === 'string' && !props.label.trim()) {\n      const error = `Invalid prop \\`label\\` supplied to \\`${PROVIDER_NAME}\\`. Expected non-empty \\`string\\`.`;\n      return new Error(error);\n    }\n    return null;\n  },\n};\n\nToastProvider.displayName = PROVIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastViewport\n * -----------------------------------------------------------------------------------------------*/\n\nconst VIEWPORT_NAME = 'ToastViewport';\nconst VIEWPORT_DEFAULT_HOTKEY = ['F8'];\nconst VIEWPORT_PAUSE = 'toast.viewportPause';\nconst VIEWPORT_RESUME = 'toast.viewportResume';\n\ntype ToastViewportElement = React.ElementRef<typeof Primitive.ol>;\ntype PrimitiveOrderedListProps = Radix.ComponentPropsWithoutRef<typeof Primitive.ol>;\ninterface ToastViewportProps extends PrimitiveOrderedListProps {\n  /**\n   * The keys to use as the keyboard shortcut that will move focus to the toast viewport.\n   * @defaultValue ['F8']\n   */\n  hotkey?: string[];\n  /**\n   * An author-localized label for the toast viewport to provide context for screen reader users\n   * when navigating page landmarks. The available `{hotkey}` placeholder will be replaced for you.\n   * @defaultValue 'Notifications ({hotkey})'\n   */\n  label?: string;\n}\n\nconst ToastViewport = React.forwardRef<ToastViewportElement, ToastViewportProps>(\n  (props: ScopedProps<ToastViewportProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      hotkey = VIEWPORT_DEFAULT_HOTKEY,\n      label = 'Notifications ({hotkey})',\n      ...viewportProps\n    } = props;\n    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n    const getItems = useCollection(__scopeToast);\n    const wrapperRef = React.useRef<HTMLDivElement>(null);\n    const headFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const tailFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const ref = React.useRef<ToastViewportElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n    const hotkeyLabel = hotkey.join('+').replace(/Key/g, '').replace(/Digit/g, '');\n    const hasToasts = context.toastCount > 0;\n\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        // we use `event.code` as it is consistent regardless of meta keys that were pressed.\n        // for example, `event.key` for `Control+Alt+t` is `â€ ` and `t !== â€ `\n        const isHotkeyPressed = hotkey.every((key) => (event as any)[key] || event.code === key);\n        if (isHotkeyPressed) ref.current?.focus();\n      };\n      document.addEventListener('keydown', handleKeyDown);\n      return () => document.removeEventListener('keydown', handleKeyDown);\n    }, [hotkey]);\n\n    React.useEffect(() => {\n      const wrapper = wrapperRef.current;\n      const viewport = ref.current;\n      if (hasToasts && wrapper && viewport) {\n        const handlePause = () => {\n          if (!context.isClosePausedRef.current) {\n            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n            viewport.dispatchEvent(pauseEvent);\n            context.isClosePausedRef.current = true;\n          }\n        };\n\n        const handleResume = () => {\n          if (context.isClosePausedRef.current) {\n            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n            viewport.dispatchEvent(resumeEvent);\n            context.isClosePausedRef.current = false;\n          }\n        };\n\n        const handleFocusOutResume = (event: FocusEvent) => {\n          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget as HTMLElement);\n          if (isFocusMovingOutside) handleResume();\n        };\n\n        const handlePointerLeaveResume = () => {\n          const isFocusInside = wrapper.contains(document.activeElement);\n          if (!isFocusInside) handleResume();\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        wrapper.addEventListener('focusin', handlePause);\n        wrapper.addEventListener('focusout', handleFocusOutResume);\n        wrapper.addEventListener('pointermove', handlePause);\n        wrapper.addEventListener('pointerleave', handlePointerLeaveResume);\n        window.addEventListener('blur', handlePause);\n        window.addEventListener('focus', handleResume);\n        return () => {\n          wrapper.removeEventListener('focusin', handlePause);\n          wrapper.removeEventListener('focusout', handleFocusOutResume);\n          wrapper.removeEventListener('pointermove', handlePause);\n          wrapper.removeEventListener('pointerleave', handlePointerLeaveResume);\n          window.removeEventListener('blur', handlePause);\n          window.removeEventListener('focus', handleResume);\n        };\n      }\n    }, [hasToasts, context.isClosePausedRef]);\n\n    const getSortedTabbableCandidates = React.useCallback(\n      ({ tabbingDirection }: { tabbingDirection: 'forwards' | 'backwards' }) => {\n        const toastItems = getItems();\n        const tabbableCandidates = toastItems.map((toastItem) => {\n          const toastNode = toastItem.ref.current!;\n          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n          return tabbingDirection === 'forwards'\n            ? toastTabbableCandidates\n            : toastTabbableCandidates.reverse();\n        });\n        return (\n          tabbingDirection === 'forwards' ? tabbableCandidates.reverse() : tabbableCandidates\n        ).flat();\n      },\n      [getItems]\n    );\n\n    React.useEffect(() => {\n      const viewport = ref.current;\n      // We programmatically manage tabbing as we are unable to influence\n      // the source order with portals, this allows us to reverse the\n      // tab order so that it runs from most recent toast to least\n      if (viewport) {\n        const handleKeyDown = (event: KeyboardEvent) => {\n          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n          const isTabKey = event.key === 'Tab' && !isMetaKey;\n\n          if (isTabKey) {\n            const focusedElement = document.activeElement;\n            const isTabbingBackwards = event.shiftKey;\n            const targetIsViewport = event.target === viewport;\n\n            // If we're back tabbing after jumping to the viewport then we simply\n            // proxy focus out to the preceding document\n            if (targetIsViewport && isTabbingBackwards) {\n              headFocusProxyRef.current?.focus();\n              return;\n            }\n\n            const tabbingDirection = isTabbingBackwards ? 'backwards' : 'forwards';\n            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });\n            const index = sortedCandidates.findIndex((candidate) => candidate === focusedElement);\n            if (focusFirst(sortedCandidates.slice(index + 1))) {\n              event.preventDefault();\n            } else {\n              // If we can't focus that means we're at the edges so we\n              // proxy to the corresponding exit point and let the browser handle\n              // tab/shift+tab keypress and implicitly pass focus to the next valid element in the document\n              isTabbingBackwards\n                ? headFocusProxyRef.current?.focus()\n                : tailFocusProxyRef.current?.focus();\n            }\n          }\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        viewport.addEventListener('keydown', handleKeyDown);\n        return () => viewport.removeEventListener('keydown', handleKeyDown);\n      }\n    }, [getItems, getSortedTabbableCandidates]);\n\n    return (\n      <DismissableLayer.Branch\n        ref={wrapperRef}\n        role=\"region\"\n        aria-label={label.replace('{hotkey}', hotkeyLabel)}\n        // Ensure virtual cursor from landmarks menus triggers focus/blur for pause/resume\n        tabIndex={-1}\n        // incase list has size when empty (e.g. padding), we remove pointer events so\n        // it doesn't prevent interactions with page elements that it overlays\n        style={{ pointerEvents: hasToasts ? undefined : 'none' }}\n      >\n        {hasToasts && (\n          <FocusProxy\n            ref={headFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'forwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n        {/**\n         * tabindex on the the list so that it can be focused when items are removed. we focus\n         * the list instead of the viewport so it announces number of items remaining.\n         */}\n        <Collection.Slot scope={__scopeToast}>\n          <Primitive.ol tabIndex={-1} {...viewportProps} ref={composedRefs} />\n        </Collection.Slot>\n        {hasToasts && (\n          <FocusProxy\n            ref={tailFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'backwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n      </DismissableLayer.Branch>\n    );\n  }\n);\n\nToastViewport.displayName = VIEWPORT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_PROXY_NAME = 'ToastFocusProxy';\n\ntype FocusProxyElement = React.ElementRef<typeof VisuallyHidden>;\ntype VisuallyHiddenProps = Radix.ComponentPropsWithoutRef<typeof VisuallyHidden>;\ninterface FocusProxyProps extends VisuallyHiddenProps {\n  onFocusFromOutsideViewport(): void;\n}\n\nconst FocusProxy = React.forwardRef<FocusProxyElement, ScopedProps<FocusProxyProps>>(\n  (props, forwardedRef) => {\n    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;\n    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n\n    return (\n      <VisuallyHidden\n        aria-hidden\n        tabIndex={0}\n        {...proxyProps}\n        ref={forwardedRef}\n        // Avoid page scrolling when focus is on the focus proxy\n        style={{ position: 'fixed' }}\n        onFocus={(event) => {\n          const prevFocusedElement = event.relatedTarget as HTMLElement | null;\n          const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);\n          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n        }}\n      />\n    );\n  }\n);\n\nFocusProxy.displayName = FOCUS_PROXY_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Toast\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOAST_NAME = 'Toast';\nconst TOAST_SWIPE_START = 'toast.swipeStart';\nconst TOAST_SWIPE_MOVE = 'toast.swipeMove';\nconst TOAST_SWIPE_CANCEL = 'toast.swipeCancel';\nconst TOAST_SWIPE_END = 'toast.swipeEnd';\n\ntype ToastElement = ToastImplElement;\ninterface ToastProps extends Omit<ToastImplProps, keyof ToastImplPrivateProps> {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst Toast = React.forwardRef<ToastElement, ToastProps>(\n  (props: ScopedProps<ToastProps>, forwardedRef) => {\n    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;\n    const [open = true, setOpen] = useControllableState({\n      prop: openProp,\n      defaultProp: defaultOpen,\n      onChange: onOpenChange,\n    });\n    return (\n      <Presence present={forceMount || open}>\n        <ToastImpl\n          open={open}\n          {...toastProps}\n          ref={forwardedRef}\n          onClose={() => setOpen(false)}\n          onPause={useCallbackRef(props.onPause)}\n          onResume={useCallbackRef(props.onResume)}\n          onSwipeStart={composeEventHandlers(props.onSwipeStart, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'start');\n          })}\n          onSwipeMove={composeEventHandlers(props.onSwipeMove, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'move');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-y', `${y}px`);\n          })}\n          onSwipeCancel={composeEventHandlers(props.onSwipeCancel, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'cancel');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-y');\n          })}\n          onSwipeEnd={composeEventHandlers(props.onSwipeEnd, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'end');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-y', `${y}px`);\n            setOpen(false);\n          })}\n        />\n      </Presence>\n    );\n  }\n);\n\nToast.displayName = TOAST_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype SwipeEvent = { currentTarget: EventTarget & ToastElement } & Omit<\n  CustomEvent<{ originalEvent: React.PointerEvent; delta: { x: number; y: number } }>,\n  'currentTarget'\n>;\n\nconst [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {},\n});\n\ntype ToastImplElement = React.ElementRef<typeof Primitive.li>;\ntype DismissableLayerProps = Radix.ComponentPropsWithoutRef<typeof DismissableLayer.Root>;\ntype ToastImplPrivateProps = { open: boolean; onClose(): void };\ntype PrimitiveListItemProps = Radix.ComponentPropsWithoutRef<typeof Primitive.li>;\ninterface ToastImplProps extends ToastImplPrivateProps, PrimitiveListItemProps {\n  type?: 'foreground' | 'background';\n  /**\n   * Time in milliseconds that toast should remain visible for. Overrides value\n   * given to `ToastProvider`.\n   */\n  duration?: number;\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPause?(): void;\n  onResume?(): void;\n  onSwipeStart?(event: SwipeEvent): void;\n  onSwipeMove?(event: SwipeEvent): void;\n  onSwipeCancel?(event: SwipeEvent): void;\n  onSwipeEnd?(event: SwipeEvent): void;\n}\n\nconst ToastImpl = React.forwardRef<ToastImplElement, ToastImplProps>(\n  (props: ScopedProps<ToastImplProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      type = 'foreground',\n      duration: durationProp,\n      open,\n      onClose,\n      onEscapeKeyDown,\n      onPause,\n      onResume,\n      onSwipeStart,\n      onSwipeMove,\n      onSwipeCancel,\n      onSwipeEnd,\n      ...toastProps\n    } = props;\n    const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n    const [node, setNode] = React.useState<ToastImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const pointerStartRef = React.useRef<{ x: number; y: number } | null>(null);\n    const swipeDeltaRef = React.useRef<{ x: number; y: number } | null>(null);\n    const duration = durationProp || context.duration;\n    const closeTimerStartTimeRef = React.useRef(0);\n    const closeTimerRemainingTimeRef = React.useRef(duration);\n    const closeTimerRef = React.useRef(0);\n    const { onToastAdd, onToastRemove } = context;\n    const handleClose = useCallbackRef(() => {\n      // focus viewport if focus is within toast to read the remaining toast\n      // count to SR users and ensure focus isn't lost\n      const isFocusInToast = node?.contains(document.activeElement);\n      if (isFocusInToast) context.viewport?.focus();\n      onClose();\n    });\n\n    const startTimer = React.useCallback(\n      (duration: number) => {\n        if (!duration || duration === Infinity) return;\n        window.clearTimeout(closeTimerRef.current);\n        closeTimerStartTimeRef.current = new Date().getTime();\n        closeTimerRef.current = window.setTimeout(handleClose, duration);\n      },\n      [handleClose]\n    );\n\n    React.useEffect(() => {\n      const viewport = context.viewport;\n      if (viewport) {\n        const handleResume = () => {\n          startTimer(closeTimerRemainingTimeRef.current);\n          onResume?.();\n        };\n        const handlePause = () => {\n          const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.current;\n          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n          window.clearTimeout(closeTimerRef.current);\n          onPause?.();\n        };\n        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n        return () => {\n          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n        };\n      }\n    }, [context.viewport, duration, onPause, onResume, startTimer]);\n\n    // start timer when toast opens or duration changes.\n    // we include `open` in deps because closed !== unmounted when animating\n    // so it could reopen before being completely unmounted\n    React.useEffect(() => {\n      if (open && !context.isClosePausedRef.current) startTimer(duration);\n    }, [open, duration, context.isClosePausedRef, startTimer]);\n\n    React.useEffect(() => {\n      onToastAdd();\n      return () => onToastRemove();\n    }, [onToastAdd, onToastRemove]);\n\n    const announceTextContent = React.useMemo(() => {\n      return node ? getAnnounceTextContent(node) : null;\n    }, [node]);\n\n    if (!context.viewport) return null;\n\n    return (\n      <>\n        {announceTextContent && (\n          <ToastAnnounce\n            __scopeToast={__scopeToast}\n            // Toasts are always role=status to avoid stuttering issues with role=alert in SRs.\n            role=\"status\"\n            aria-live={type === 'foreground' ? 'assertive' : 'polite'}\n            aria-atomic\n          >\n            {announceTextContent}\n          </ToastAnnounce>\n        )}\n\n        <ToastInteractiveProvider scope={__scopeToast} onClose={handleClose}>\n          {ReactDOM.createPortal(\n            <Collection.ItemSlot scope={__scopeToast}>\n              <DismissableLayer.Root\n                asChild\n                onEscapeKeyDown={composeEventHandlers(onEscapeKeyDown, () => {\n                  if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n                  context.isFocusedToastEscapeKeyDownRef.current = false;\n                })}\n              >\n                <Primitive.li\n                  // Ensure toasts are announced as status list or status when focused\n                  role=\"status\"\n                  aria-live=\"off\"\n                  aria-atomic\n                  tabIndex={0}\n                  data-state={open ? 'open' : 'closed'}\n                  data-swipe-direction={context.swipeDirection}\n                  {...toastProps}\n                  ref={composedRefs}\n                  style={{ userSelect: 'none', touchAction: 'none', ...props.style }}\n                  onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                    if (event.key !== 'Escape') return;\n                    onEscapeKeyDown?.(event.nativeEvent);\n                    if (!event.nativeEvent.defaultPrevented) {\n                      context.isFocusedToastEscapeKeyDownRef.current = true;\n                      handleClose();\n                    }\n                  })}\n                  onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n                    if (event.button !== 0) return;\n                    pointerStartRef.current = { x: event.clientX, y: event.clientY };\n                  })}\n                  onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n                    if (!pointerStartRef.current) return;\n                    const x = event.clientX - pointerStartRef.current.x;\n                    const y = event.clientY - pointerStartRef.current.y;\n                    const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n                    const isHorizontalSwipe = ['left', 'right'].includes(context.swipeDirection);\n                    const clamp = ['left', 'up'].includes(context.swipeDirection)\n                      ? Math.min\n                      : Math.max;\n                    const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n                    const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n                    const moveStartBuffer = event.pointerType === 'touch' ? 10 : 2;\n                    const delta = { x: clampedX, y: clampedY };\n                    const eventDetail = { originalEvent: event, delta };\n                    if (hasSwipeMoveStarted) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                        discrete: false,\n                      });\n                    } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                        discrete: false,\n                      });\n                      (event.target as HTMLElement).setPointerCapture(event.pointerId);\n                    } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                      // User is swiping in wrong direction so we disable swipe gesture\n                      // for the current pointer down interaction\n                      pointerStartRef.current = null;\n                    }\n                  })}\n                  onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n                    const delta = swipeDeltaRef.current;\n                    const target = event.target as HTMLElement;\n                    if (target.hasPointerCapture(event.pointerId)) {\n                      target.releasePointerCapture(event.pointerId);\n                    }\n                    swipeDeltaRef.current = null;\n                    pointerStartRef.current = null;\n                    if (delta) {\n                      const toast = event.currentTarget;\n                      const eventDetail = { originalEvent: event, delta };\n                      if (\n                        isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)\n                      ) {\n                        handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                          discrete: true,\n                        });\n                      } else {\n                        handleAndDispatchCustomEvent(\n                          TOAST_SWIPE_CANCEL,\n                          onSwipeCancel,\n                          eventDetail,\n                          {\n                            discrete: true,\n                          }\n                        );\n                      }\n                      // Prevent click event from triggering on items within the toast when\n                      // pointer up is part of a swipe gesture\n                      toast.addEventListener('click', (event) => event.preventDefault(), {\n                        once: true,\n                      });\n                    }\n                  })}\n                />\n              </DismissableLayer.Root>\n            </Collection.ItemSlot>,\n            context.viewport\n          )}\n        </ToastInteractiveProvider>\n      </>\n    );\n  }\n);\n\nToastImpl.propTypes = {\n  type(props) {\n    if (props.type && !['foreground', 'background'].includes(props.type)) {\n      const error = `Invalid prop \\`type\\` supplied to \\`${TOAST_NAME}\\`. Expected \\`foreground | background\\`.`;\n      return new Error(error);\n    }\n    return null;\n  },\n};\n\n/* -----------------------------------------------------------------------------------------------*/\n\ninterface ToastAnnounceProps\n  extends Omit<React.ComponentPropsWithoutRef<'div'>, 'children'>,\n    ScopedProps<{ children: string[] }> {}\n\nconst ToastAnnounce: React.FC<ToastAnnounceProps> = (props: ScopedProps<ToastAnnounceProps>) => {\n  const { __scopeToast, children, ...announceProps } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n\n  // render text content in the next frame to ensure toast is announced in NVDA\n  useNextFrame(() => setRenderAnnounceText(true));\n\n  // cleanup after announcing\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1000);\n    return () => window.clearTimeout(timer);\n  }, []);\n\n  return isAnnounced ? null : (\n    <Portal asChild>\n      <VisuallyHidden {...announceProps}>\n        {renderAnnounceText && (\n          <>\n            {context.label} {children}\n          </>\n        )}\n      </VisuallyHidden>\n    </Portal>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * ToastTitle\n * -----------------------------------------------------------------------------------------------*/\n\nconst TITLE_NAME = 'ToastTitle';\n\ntype ToastTitleElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface ToastTitleProps extends PrimitiveDivProps {}\n\nconst ToastTitle = React.forwardRef<ToastTitleElement, ToastTitleProps>(\n  (props: ScopedProps<ToastTitleProps>, forwardedRef) => {\n    const { __scopeToast, ...titleProps } = props;\n    return <Primitive.div {...titleProps} ref={forwardedRef} />;\n  }\n);\n\nToastTitle.displayName = TITLE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastDescription\n * -----------------------------------------------------------------------------------------------*/\n\nconst DESCRIPTION_NAME = 'ToastDescription';\n\ntype ToastDescriptionElement = React.ElementRef<typeof Primitive.div>;\ninterface ToastDescriptionProps extends PrimitiveDivProps {}\n\nconst ToastDescription = React.forwardRef<ToastDescriptionElement, ToastDescriptionProps>(\n  (props: ScopedProps<ToastDescriptionProps>, forwardedRef) => {\n    const { __scopeToast, ...descriptionProps } = props;\n    return <Primitive.div {...descriptionProps} ref={forwardedRef} />;\n  }\n);\n\nToastDescription.displayName = DESCRIPTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastAction\n * -----------------------------------------------------------------------------------------------*/\n\nconst ACTION_NAME = 'ToastAction';\n\ntype ToastActionElement = ToastCloseElement;\ninterface ToastActionProps extends ToastCloseProps {\n  /**\n   * A short description for an alternate way to carry out the action. For screen reader users\n   * who will not be able to navigate to the button easily/quickly.\n   * @example <ToastAction altText=\"Goto account settings to upgrade\">Upgrade</ToastAction>\n   * @example <ToastAction altText=\"Undo (Alt+U)\">Undo</ToastAction>\n   */\n  altText: string;\n}\n\nconst ToastAction = React.forwardRef<ToastActionElement, ToastActionProps>(\n  (props: ScopedProps<ToastActionProps>, forwardedRef) => {\n    const { altText, ...actionProps } = props;\n    if (!altText) return null;\n    return (\n      <ToastAnnounceExclude altText={altText} asChild>\n        <ToastClose {...actionProps} ref={forwardedRef} />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastAction.propTypes = {\n  altText(props) {\n    if (!props.altText) {\n      return new Error(`Missing prop \\`altText\\` expected on \\`${ACTION_NAME}\\``);\n    }\n    return null;\n  },\n};\n\nToastAction.displayName = ACTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastClose\n * -----------------------------------------------------------------------------------------------*/\n\nconst CLOSE_NAME = 'ToastClose';\n\ntype ToastCloseElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = Radix.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface ToastCloseProps extends PrimitiveButtonProps {}\n\nconst ToastClose = React.forwardRef<ToastCloseElement, ToastCloseProps>(\n  (props: ScopedProps<ToastCloseProps>, forwardedRef) => {\n    const { __scopeToast, ...closeProps } = props;\n    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n\n    return (\n      <ToastAnnounceExclude asChild>\n        <Primitive.button\n          type=\"button\"\n          {...closeProps}\n          ref={forwardedRef}\n          onClick={composeEventHandlers(props.onClick, interactiveContext.onClose)}\n        />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastClose.displayName = CLOSE_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype ToastAnnounceExcludeElement = React.ElementRef<typeof Primitive.div>;\ninterface ToastAnnounceExcludeProps extends PrimitiveDivProps {\n  altText?: string;\n}\n\nconst ToastAnnounceExclude = React.forwardRef<\n  ToastAnnounceExcludeElement,\n  ToastAnnounceExcludeProps\n>((props: ScopedProps<ToastAnnounceExcludeProps>, forwardedRef) => {\n  const { __scopeToast, altText, ...announceExcludeProps } = props;\n\n  return (\n    <Primitive.div\n      data-radix-toast-announce-exclude=\"\"\n      data-radix-toast-announce-alt={altText || undefined}\n      {...announceExcludeProps}\n      ref={forwardedRef}\n    />\n  );\n});\n\nfunction getAnnounceTextContent(container: HTMLElement) {\n  const textContent: string[] = [];\n  const childNodes = Array.from(container.childNodes);\n\n  childNodes.forEach((node) => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === 'none';\n      const isExcluded = node.dataset.radixToastAnnounceExclude === '';\n\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n\n  // We return a collection of text rather than a single concatenated string.\n  // This allows SR VO to naturally pause break between nodes while announcing.\n  return textContent;\n}\n\n/* ---------------------------------------------------------------------------------------------- */\n\nfunction handleAndDispatchCustomEvent<\n  E extends CustomEvent,\n  ReactEvent extends React.SyntheticEvent\n>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: ReactEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const currentTarget = detail.originalEvent.currentTarget as HTMLElement;\n  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });\n  if (handler) currentTarget.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\n\nconst isDeltaInDirection = (\n  delta: { x: number; y: number },\n  direction: SwipeDirection,\n  threshold = 0\n) => {\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n  if (direction === 'left' || direction === 'right') {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\n\nfunction useNextFrame(callback = () => {}) {\n  const fn = useCallbackRef(callback);\n  useLayoutEffect(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => (raf2 = window.requestAnimationFrame(fn)));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\n\nfunction isHTMLElement(node: any): node is HTMLElement {\n  return node.nodeType === node.ELEMENT_NODE;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some((candidate) => {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\n\nconst Provider = ToastProvider;\nconst Viewport = ToastViewport;\nconst Root = Toast;\nconst Title = ToastTitle;\nconst Description = ToastDescription;\nconst Action = ToastAction;\nconst Close = ToastClose;\n\nexport {\n  createToastScope,\n  //\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastAction,\n  ToastClose,\n  //\n  Provider,\n  Viewport,\n  Root,\n  Title,\n  Description,\n  Action,\n  Close,\n};\nexport type {\n  ToastProviderProps,\n  ToastViewportProps,\n  ToastProps,\n  ToastTitleProps,\n  ToastDescriptionProps,\n  ToastActionProps,\n  ToastCloseProps,\n};\n"],
  "mappings": "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",
  "names": ["composeEventHandlers", "originalEventHandler", "ourEventHandler", "checkForDefaultPrevented", "handleEvent", "event", "defaultPrevented", "createContextScope", "scopeName", "createContextScopeDeps", "defaultContexts", "createContext", "rootComponentName", "defaultContext", "BaseContext", "React", "index", "length", "Provider", "props", "context", "Context", "scope", "value", "Object", "values", "$3bkAK$createElement", "children", "useContext", "consumerName", "undefined", "Error", "displayName", "createScope", "scopeContexts", "map", "useScope", "contexts", "composeContextScopes", "scopes", "baseScope", "scopeHooks", "useComposedScopes", "overrideScopes", "nextScopes", "reduce", "scopeProps", "currentScope", "createCollection", "name", "PROVIDER_NAME", "createCollectionContext", "createCollectionScope", "createContextScope", "CollectionProviderImpl", "useCollectionContext", "collectionRef", "current", "itemMap", "Map", "CollectionProvider", "props", "children", "ref", "React", "useRef", "$6vYhU$react", "COLLECTION_SLOT_NAME", "CollectionSlot", "forwardRef", "forwardedRef", "context", "scope", "composedRefs", "useComposedRefs", "ITEM_SLOT_NAME", "ITEM_DATA_ATTR", "CollectionItemSlot", "itemData", "useEffect", "set", "delete", "useCollection", "getItems", "useCallback", "collectionNode", "orderedNodes", "Array", "from", "querySelectorAll", "items", "values", "orderedItems", "sort", "a", "b", "indexOf", "Provider", "Slot", "ItemSlot", "useCallbackRef", "callback", "callbackRef", "React", "current", "args", "useEscapeKeydown", "onEscapeKeyDownProp", "ownerDocument", "globalThis", "document", "onEscapeKeyDown", "useCallbackRef", "React", "handleKeyDown", "event", "key", "addEventListener", "removeEventListener", "DISMISSABLE_LAYER_NAME", "CONTEXT_UPDATE", "POINTER_DOWN_OUTSIDE", "FOCUS_OUTSIDE", "originalBodyPointerEvents", "DismissableLayerContext", "React", "layers", "Set", "layersWithOutsidePointerEventsDisabled", "branches", "DismissableLayer", "props", "forwardedRef", "layerProps", "context", "node", "setNode", "ownerDocument", "globalThis", "document", "force", "composedRefs", "useComposedRefs", "Array", "from", "highestLayerWithOutsidePointerEventsDisabled", "slice", "highestLayerWithOutsidePointerEventsDisabledIndex", "indexOf", "index", "isBodyPointerEventsDisabled", "size", "isPointerEventsEnabled", "pointerDownOutside", "usePointerDownOutside", "event", "target", "isPointerDownOnBranch", "some", "branch", "contains", "onPointerDownOutside", "onInteractOutside", "defaultPrevented", "onDismiss", "focusOutside", "useFocusOutside", "isFocusInBranch", "onFocusOutside", "useEscapeKeydown", "isHighestLayer", "onEscapeKeyDown", "preventDefault", "disableOutsidePointerEvents", "body", "style", "pointerEvents", "add", "dispatchUpdate", "delete", "handleUpdate", "addEventListener", "removeEventListener", "$kqwpH$createElement", "undefined", "composeEventHandlers", "onFocusCapture", "onBlurCapture", "onPointerDownCapture", "BRANCH_NAME", "DismissableLayerBranch", "ref", "current", "handlePointerDownOutside", "useCallbackRef", "isPointerInsideReactTreeRef", "handleClickRef", "handlePointerDown", "handleAndDispatchPointerDownOutsideEvent", "handleAndDispatchCustomEvent", "eventDetail", "discrete", "originalEvent", "pointerType", "once", "timerId", "window", "setTimeout", "clearTimeout", "handleFocusOutside", "isFocusInsideReactTreeRef", "handleFocus", "CustomEvent", "dispatchEvent", "name", "handler", "detail", "bubbles", "cancelable", "dispatchDiscreteCustomEvent", "Root", "Branch", "PORTAL_NAME", "Portal", "React", "props", "forwardedRef", "globalThis", "document", "body", "portalProps", "container", "ReactDOM", "createPortal", "$7SXl2$createElement", "useLayoutEffect", "Boolean", "globalThis", "document", "React", "useStateMachine", "initialState", "machine", "React", "state", "event", "nextState", "Presence", "props", "children", "presence", "usePresence", "present", "child", "isPresent", "only", "ref", "useComposedRefs", "forceMount", "displayName", "node", "setNode", "stylesRef", "prevPresentRef", "prevAnimationNameRef", "send", "mounted", "UNMOUNT", "ANIMATION_OUT", "unmountSuspended", "MOUNT", "ANIMATION_END", "unmounted", "currentAnimationName", "getAnimationName", "current", "useLayoutEffect", "styles", "wasPresent", "hasPresentChanged", "prevAnimationName", "display", "isAnimating", "handleAnimationEnd", "isCurrentAnimation", "includes", "animationName", "target", "ReactDOM", "handleAnimationStart", "addEventListener", "removeEventListener", "getComputedStyle", "useControllableState", "onChange", "uncontrolledProp", "setUncontrolledProp", "useUncontrolledState", "isControlled", "prop", "undefined", "value", "handleChange", "useCallbackRef", "setValue", "React", "nextValue", "setter", "uncontrolledState", "defaultProp", "prevValueRef", "current", "NAME", "VisuallyHidden", "React", "props", "forwardedRef", "$kVwnw$createElement", "position", "border", "width", "height", "padding", "margin", "overflow", "clip", "whiteSpace", "wordWrap", "style", "PROVIDER_NAME", "Collection", "useCollection", "createCollectionScope", "createCollection", "createToastContext", "createToastScope", "createContextScope", "ToastProviderProvider", "useToastProviderContext", "ToastProvider", "props", "children", "viewport", "setViewport", "React", "toastCount", "setToastCount", "isFocusedToastEscapeKeyDownRef", "isClosePausedRef", "$eyrYI$createElement", "__scopeToast", "prevCount", "propTypes", "label", "trim", "error", "Error", "VIEWPORT_NAME", "VIEWPORT_DEFAULT_HOTKEY", "VIEWPORT_PAUSE", "VIEWPORT_RESUME", "ToastViewport", "forwardedRef", "viewportProps", "context", "getItems", "wrapperRef", "headFocusProxyRef", "tailFocusProxyRef", "ref", "composedRefs", "useComposedRefs", "onViewportChange", "hotkeyLabel", "hotkey", "join", "replace", "hasToasts", "handleKeyDown", "event", "isHotkeyPressed", "every", "key", "code", "current", "focus", "document", "addEventListener", "removeEventListener", "wrapper", "handlePause", "pauseEvent", "CustomEvent", "dispatchEvent", "handleResume", "resumeEvent", "handleFocusOutResume", "isFocusMovingOutside", "contains", "relatedTarget", "handlePointerLeaveResume", "isFocusInside", "activeElement", "window", "getSortedTabbableCandidates", "tabbingDirection", "toastItems", "tabbableCandidates", "map", "toastItem", "toastNode", "toastTabbableCandidates", "getTabbableCandidates", "reverse", "flat", "isMetaKey", "altKey", "ctrlKey", "metaKey", "isTabKey", "focusedElement", "isTabbingBackwards", "shiftKey", "targetIsViewport", "target", "sortedCandidates", "index", "findIndex", "candidate", "focusFirst", "slice", "preventDefault", "pointerEvents", "undefined", "FOCUS_PROXY_NAME", "FocusProxy", "proxyProps", "position", "prevFocusedElement", "isFocusFromOutsideViewport", "onFocusFromOutsideViewport", "TOAST_NAME", "TOAST_SWIPE_START", "TOAST_SWIPE_MOVE", "TOAST_SWIPE_CANCEL", "TOAST_SWIPE_END", "Toast", "open", "openProp", "toastProps", "setOpen", "useControllableState", "prop", "defaultProp", "defaultOpen", "onChange", "onOpenChange", "forceMount", "useCallbackRef", "onPause", "onResume", "composeEventHandlers", "onSwipeStart", "currentTarget", "setAttribute", "onSwipeMove", "y", "detail", "delta", "style", "setProperty", "x", "onSwipeCancel", "removeProperty", "onSwipeEnd", "ToastInteractiveProvider", "useToastInteractiveContext", "onClose", "ToastImpl", "duration", "durationProp", "node", "setNode", "pointerStartRef", "swipeDeltaRef", "closeTimerStartTimeRef", "closeTimerRemainingTimeRef", "closeTimerRef", "onToastRemove", "handleClose", "isFocusInToast", "startTimer", "Infinity", "clearTimeout", "Date", "getTime", "setTimeout", "elapsedTime", "onToastAdd", "announceTextContent", "getAnnounceTextContent", "$eyrYI$Fragment", "type", "ReactDOM", "onEscapeKeyDown", "swipeDirection", "userSelect", "touchAction", "onKeyDown", "nativeEvent", "defaultPrevented", "onPointerDown", "button", "clientX", "clientY", "onPointerMove", "hasSwipeMoveStarted", "Boolean", "isHorizontalSwipe", "includes", "clamp", "Math", "min", "max", "clampedX", "clampedY", "moveStartBuffer", "pointerType", "eventDetail", "originalEvent", "handleAndDispatchCustomEvent", "discrete", "isDeltaInDirection", "setPointerCapture", "pointerId", "abs", "onPointerUp", "hasPointerCapture", "releasePointerCapture", "toast", "swipeThreshold", "once", "ToastAnnounce", "announceProps", "renderAnnounceText", "setRenderAnnounceText", "isAnnounced", "setIsAnnounced", "useNextFrame", "timer", "TITLE_NAME", "ToastTitle", "titleProps", "DESCRIPTION_NAME", "ToastDescription", "descriptionProps", "ACTION_NAME", "ToastAction", "actionProps", "altText", "CLOSE_NAME", "ToastClose", "closeProps", "interactiveContext", "onClick", "ToastAnnounceExclude", "announceExcludeProps", "container", "textContent", "childNodes", "Array", "from", "forEach", "nodeType", "TEXT_NODE", "push", "isHTMLElement", "isHidden", "ariaHidden", "hidden", "display", "isExcluded", "dataset", "radixToastAnnounceExclude", "radixToastAnnounceAlt", "name", "handler", "bubbles", "cancelable", "dispatchDiscreteCustomEvent", "direction", "threshold", "deltaX", "deltaY", "isDeltaX", "callback", "fn", "useLayoutEffect", "raf1", "raf2", "requestAnimationFrame", "cancelAnimationFrame", "ELEMENT_NODE", "nodes", "walker", "createTreeWalker", "NodeFilter", "SHOW_ELEMENT", "acceptNode", "isHiddenInput", "tagName", "disabled", "FILTER_SKIP", "tabIndex", "FILTER_ACCEPT", "nextNode", "currentNode", "candidates", "previouslyFocusedElement", "some", "Provider", "Viewport", "Root", "Title", "Description", "Action", "Close"]
}
